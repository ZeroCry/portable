{
  "mocha.js": "console.log('testing');\n\n\nreturn;\nvar Mocha = require('mocha');\nvar fs = require('fs');\nvar path = require('path');\n\n// First, you need to instantiate a Mocha instance.\nvar mocha = new Mocha;\n\n// Then, you need to use the method \"addFile\" on the mocha\n// object for each file.\n\n// Here is an example:\nfs.readdirSync('some/dir').filter(function(file){\n    // Only keep the .js files\n    return file.substr(-3) === '.js';\n\n}).forEach(function(file){\n    // Use the method \"addFile\" to add the file to mocha\n    mocha.addFile(\n        path.join('some/dir', file)\n    );\n});\n\n// Now, you can run the tests.\nmocha.run(function(failures){\n    process.on('exit', function () {\n        process.exit(failures);\n    });\n});",
  "node_modules/mocha/bin/options.js": "/**\n * Dependencies.\n */\n\nvar fs = require('fs');\n\n/**\n * Export `getOptions`.\n */\n\nmodule.exports = getOptions;\n\n/**\n * Get options.\n */\n\nfunction getOptions() {\n  var optsPath = process.argv.indexOf('--opts') !== -1\n        ? process.argv[process.argv.indexOf('--opts') + 1]\n        : 'test/mocha.opts';\n\n  try {\n    var opts = fs.readFileSync(optsPath, 'utf8')\n          .trim()\n          .split(/\\s+/)\n          .filter(function(value) {\n            return value ? true : false;\n          });\n\n    process.argv = process.argv\n      .slice(0, 2)\n      .concat(opts.concat(process.argv.slice(2)));\n  } catch (err) {\n    // ignore\n  }\n}\n",
  "node_modules/mocha/index.js": "module.exports = process.env.COV\n  ? require('./lib-cov/mocha')\n  : require('./lib/mocha');\n",
  "node_modules/mocha/lib/browser/debug.js": "module.exports = function(type){\n  return function(){\n  }\n};\n",
  "node_modules/mocha/lib/browser/escape-string-regexp.js": "'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  return str.replace(matchOperatorsRe,  '\\\\$&');\n};\n",
  "node_modules/mocha/lib/browser/events.js": "/**\n * Module exports.\n */\n\nexports.EventEmitter = EventEmitter;\n\n/**\n * Check if `obj` is an array.\n */\n\nfunction isArray(obj) {\n  return '[object Array]' == {}.toString.call(obj);\n}\n\n/**\n * Event emitter constructor.\n *\n * @api public\n */\n\nfunction EventEmitter(){};\n\n/**\n * Adds a listener.\n *\n * @api public\n */\n\nEventEmitter.prototype.on = function (name, fn) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = fn;\n  } else if (isArray(this.$events[name])) {\n    this.$events[name].push(fn);\n  } else {\n    this.$events[name] = [this.$events[name], fn];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n/**\n * Adds a volatile listener.\n *\n * @api public\n */\n\nEventEmitter.prototype.once = function (name, fn) {\n  var self = this;\n\n  function on () {\n    self.removeListener(name, on);\n    fn.apply(this, arguments);\n  };\n\n  on.listener = fn;\n  this.on(name, on);\n\n  return this;\n};\n\n/**\n * Removes a listener.\n *\n * @api public\n */\n\nEventEmitter.prototype.removeListener = function (name, fn) {\n  if (this.$events && this.$events[name]) {\n    var list = this.$events[name];\n\n    if (isArray(list)) {\n      var pos = -1;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n          pos = i;\n          break;\n        }\n      }\n\n      if (pos < 0) {\n        return this;\n      }\n\n      list.splice(pos, 1);\n\n      if (!list.length) {\n        delete this.$events[name];\n      }\n    } else if (list === fn || (list.listener && list.listener === fn)) {\n      delete this.$events[name];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Removes all listeners for an event.\n *\n * @api public\n */\n\nEventEmitter.prototype.removeAllListeners = function (name) {\n  if (name === undefined) {\n    this.$events = {};\n    return this;\n  }\n\n  if (this.$events && this.$events[name]) {\n    this.$events[name] = null;\n  }\n\n  return this;\n};\n\n/**\n * Gets all listeners for a certain event.\n *\n * @api public\n */\n\nEventEmitter.prototype.listeners = function (name) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = [];\n  }\n\n  if (!isArray(this.$events[name])) {\n    this.$events[name] = [this.$events[name]];\n  }\n\n  return this.$events[name];\n};\n\n/**\n * Emits an event.\n *\n * @api public\n */\n\nEventEmitter.prototype.emit = function (name) {\n  if (!this.$events) {\n    return false;\n  }\n\n  var handler = this.$events[name];\n\n  if (!handler) {\n    return false;\n  }\n\n  var args = [].slice.call(arguments, 1);\n\n  if ('function' == typeof handler) {\n    handler.apply(this, args);\n  } else if (isArray(handler)) {\n    var listeners = handler.slice();\n\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n};\n",
  "node_modules/mocha/lib/browser/fs.js": "",
  "node_modules/mocha/lib/browser/glob.js": "",
  "node_modules/mocha/lib/browser/path.js": "",
  "node_modules/mocha/lib/browser/progress.js": "/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\n\nfunction Progress() {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `n`.\n *\n * @param {Number} n\n * @return {Progress} for chaining\n * @api public\n */\n\nProgress.prototype.size = function(n){\n  this._size = n;\n  return this;\n};\n\n/**\n * Set text to `str`.\n *\n * @param {String} str\n * @return {Progress} for chaining\n * @api public\n */\n\nProgress.prototype.text = function(str){\n  this._text = str;\n  return this;\n};\n\n/**\n * Set font size to `n`.\n *\n * @param {Number} n\n * @return {Progress} for chaining\n * @api public\n */\n\nProgress.prototype.fontSize = function(n){\n  this._fontSize = n;\n  return this;\n};\n\n/**\n * Set font `family`.\n *\n * @param {String} family\n * @return {Progress} for chaining\n */\n\nProgress.prototype.font = function(family){\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {Number} n\n * @return {Progress} for chaining\n */\n\nProgress.prototype.update = function(n){\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} for chaining\n */\n\nProgress.prototype.draw = function(ctx){\n  try {\n    var percent = Math.min(this.percent, 100)\n      , size = this._size\n      , half = size / 2\n      , x = half\n      , y = half\n      , rad = half - 1\n      , fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%'\n      , w = ctx.measureText(text).width;\n\n    ctx.fillText(\n        text\n      , x - w / 2 + 1\n      , y + fontSize / 2 - 1);\n  } catch (ex) {} //don't fail if we can't render progress\n  return this;\n};\n",
  "node_modules/mocha/lib/browser/tty.js": "exports.isatty = function(){\n  return true;\n};\n\nexports.getWindowSize = function(){\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  } else {\n    // In a Web Worker, the DOM Window is not available.\n    return [640, 480];\n  }\n};\n",
  "node_modules/mocha/lib/context.js": "/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\n\nfunction Context(){}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @param {Runnable} runnable\n * @return {Context}\n * @api private\n */\n\nContext.prototype.runnable = function(runnable){\n  if (0 == arguments.length) return this._runnable;\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set test timeout `ms`.\n *\n * @param {Number} ms\n * @return {Context} self\n * @api private\n */\n\nContext.prototype.timeout = function(ms){\n  if (arguments.length === 0) return this.runnable().timeout();\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @param {Boolean} enabled\n * @return {Context} self\n * @api private\n */\n\nContext.prototype.enableTimeouts = function (enabled) {\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n\n/**\n * Set test slowness threshold `ms`.\n *\n * @param {Number} ms\n * @return {Context} self\n * @api private\n */\n\nContext.prototype.slow = function(ms){\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @return {Context} self\n * @api private\n */\n\nContext.prototype.skip = function(){\n    this.runnable().skip();\n    return this;\n};\n\n/**\n * Inspect the context void of `._runnable`.\n *\n * @return {String}\n * @api private\n */\n\nContext.prototype.inspect = function(){\n  return JSON.stringify(this, function(key, val){\n    if ('_runnable' == key) return;\n    if ('test' == key) return;\n    return val;\n  }, 2);\n};\n",
  "node_modules/mocha/lib/hook.js": "/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\n\nfunction Hook(title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\n\nHook.prototype.__proto__ = Runnable.prototype;\n\n/**\n * Get or set the test `err`.\n *\n * @param {Error} err\n * @return {Error}\n * @api public\n */\n\nHook.prototype.error = function(err){\n  if (0 == arguments.length) {\n    var err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n",
  "node_modules/mocha/lib/interfaces/bdd.js": "/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite')\n  , Test = require('../test')\n  , utils = require('../utils')\n  , escapeRe = require('escape-string-regexp');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function(){\n *        describe('#indexOf()', function(){\n *          it('should return -1 when not present', function(){\n *\n *          });\n *\n *          it('should return the index when present', function(){\n *\n *          });\n *        });\n *      });\n *\n */\n\nmodule.exports = function(suite){\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha){\n\n    var common = require('./common')(suites, context);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function(title, fn){\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n      return suite;\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe =\n    context.xcontext =\n    context.describe.skip = function(title, fn){\n      var suite = Suite.create(suites[0], title);\n      suite.pending = true;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function(title, fn){\n      var suite = context.describe(title, fn);\n      mocha.grep(suite.fullTitle());\n      return suite;\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.it = context.specify = function(title, fn){\n      var suite = suites[0];\n      if (suite.pending) fn = null;\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function(title, fn){\n      var test = context.it(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n      return test;\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit =\n    context.xspecify =\n    context.it.skip = function(title){\n      context.it(title);\n    };\n\n  });\n};\n",
  "node_modules/mocha/lib/interfaces/common.js": "/**\n * Functions common to more than one interface\n * @module lib/interfaces/common\n */\n\n'use strict';\n\nmodule.exports = function (suites, context) {\n\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha.  It triggers\n     * root suite execution.  Returns a function which runs the root suite.\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    test: {\n      /**\n       * Pending test case.\n       */\n      skip: function (title) {\n        context.test(title);\n      }\n    }\n  }\n};\n",
  "node_modules/mocha/lib/interfaces/exports.js": "/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite')\n  , Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function(){\n *\n *         },\n *\n *         'should return the correct index when the value is present': function(){\n *\n *         }\n *       }\n *     };\n *\n */\n\nmodule.exports = function(suite){\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit(obj, file) {\n    var suite;\n    for (var key in obj) {\n      if ('function' == typeof obj[key]) {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key]);\n        suites.shift();\n      }\n    }\n  }\n};\n",
  "node_modules/mocha/lib/interfaces/index.js": "exports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n",
  "node_modules/mocha/lib/interfaces/qunit.js": "/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite')\n  , Test = require('../test')\n  , escapeRe = require('escape-string-regexp')\n  , utils = require('../utils');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function(){\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function(){\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function(){\n *       ok('foo'.length == 3);\n *     });\n *\n */\n\nmodule.exports = function(suite){\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha){\n\n    var common = require('./common')(suites, context);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function(title){\n      if (suites.length > 1) suites.shift();\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      return suite;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.suite.only = function(title, fn){\n      var suite = context.suite(title, fn);\n      mocha.grep(suite.fullTitle());\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function(title, fn){\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn){\n      var test = context.test(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n    };\n\n    context.test.skip = common.test.skip;\n\n  });\n};\n",
  "node_modules/mocha/lib/interfaces/tdd.js": "/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite')\n  , Test = require('../test')\n  , escapeRe = require('escape-string-regexp')\n  , utils = require('../utils');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function(){\n *        suite('#indexOf()', function(){\n *          suiteSetup(function(){\n *\n *          });\n *\n *          test('should return -1 when not present', function(){\n *\n *          });\n *\n *          test('should return the index when present', function(){\n *\n *          });\n *\n *          suiteTeardown(function(){\n *\n *          });\n *        });\n *      });\n *\n */\n\nmodule.exports = function(suite){\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha){\n\n    var common = require('./common')(suites, context);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.suite = function(title, fn){\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n      return suite;\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.pending = true;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.suite.only = function(title, fn){\n      var suite = context.suite(title, fn);\n      mocha.grep(suite.fullTitle());\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function(title, fn){\n      var suite = suites[0];\n      if (suite.pending) fn = null;\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn){\n      var test = context.test(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n    };\n\n    context.test.skip = common.test.skip;\n  });\n};\n",
  "node_modules/mocha/lib/mocha.js": "/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar path = require('path')\n  , escapeRe = require('escape-string-regexp')\n  , utils = require('./utils');\n\n/**\n * Expose `Mocha`.\n */\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (typeof process !== 'undefined' && typeof process.cwd === 'function') {\n  var join = path.join\n    , cwd = process.cwd();\n  module.paths.push(cwd, join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\nexports.reporters = require('./reporters');\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @param {String} name\n * @return {String}\n * @api private\n */\n\nfunction image(name) {\n  return __dirname + '/../images/' + name + '.png';\n}\n\n/**\n * Setup mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Mocha(options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) this.grep(new RegExp(options.grep));\n  if (options.fgrep) this.grep(options.fgrep);\n  this.suite = new exports.Suite('', new exports.Context);\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (null != options.timeout) this.timeout(options.timeout);\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) this.enableTimeouts(options.enableTimeouts);\n  if (options.slow) this.slow(options.slow);\n\n  this.suite.on('pre-require', function (context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @param {Boolean} [bail]\n * @api public\n */\n\nMocha.prototype.bail = function(bail){\n  if (0 == arguments.length) bail = true;\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @param {String} file\n * @api public\n */\n\nMocha.prototype.addFile = function(file){\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n */\nMocha.prototype.reporter = function(reporter, reporterOptions){\n  if ('function' == typeof reporter) {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    try { _reporter = require('./reporters/' + reporter); } catch (err) {}\n    if (!_reporter) try { _reporter = require(reporter); } catch (err) {\n      err.message.indexOf('Cannot find module') !== -1\n        ? console.warn('\"' + reporter + '\" reporter not found')\n        : console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n    }\n    if (!_reporter && reporter === 'teamcity')\n      console.warn('The Teamcity reporter was moved to a package named ' +\n        'mocha-teamcity-reporter ' +\n        '(https://npmjs.org/package/mocha-teamcity-reporter).');\n    if (!_reporter) throw new Error('invalid reporter \"' + reporter + '\"');\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n *\n * @param {String} bdd\n * @api public\n */\n\nMocha.prototype.ui = function(name){\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) try { this._ui = require(name); } catch (err) {}\n  if (!this._ui) throw new Error('invalid interface \"' + name + '\"');\n  this._ui = this._ui(this.suite);\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\n\nMocha.prototype.loadFiles = function(fn){\n  var self = this;\n  var suite = this.suite;\n  var pending = this.files.length;\n  this.files.forEach(function(file){\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n    --pending || (fn && fn());\n  });\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\n\nMocha.prototype._growl = function(runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function(){\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n          name: 'mocha'\n        , title: 'Passed'\n        , image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.grep = function(re){\n  this.options.grep = 'string' == typeof re\n    ? new RegExp(escapeRe(re))\n    : re;\n  return this;\n};\n\n/**\n * Invert `.grep()` matches.\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.invert = function(){\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.ignoreLeaks = function(ignore){\n  this.options.ignoreLeaks = !!ignore;\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.checkLeaks = function(){\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.fullTrace = function() {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.growl = function(){\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.globals = function(globals){\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.useColors = function(colors){\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.useInlineDiffs = function(inlineDiffs) {\n  this.options.useInlineDiffs = arguments.length && inlineDiffs != undefined\n  ? inlineDiffs\n  : false;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.timeout = function(timeout){\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.slow = function(slow){\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.enableTimeouts = function(enabled) {\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined\n    ? enabled\n    : true);\n  return this\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.asyncOnly = function(){\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n * @returns {Mocha}\n * @api public\n */\nMocha.prototype.noHighlighting = function() {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n * @api public\n */\nMocha.prototype.delay = function delay() {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * @param {Function} fn\n * @return {Runner}\n * @api public\n */\nMocha.prototype.run = function(fn){\n  if (this.files.length) this.loadFiles();\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = false !== options.ignoreLeaks;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.asyncOnly = options.asyncOnly;\n  if (options.grep) runner.grep(options.grep, options.invert);\n  if (options.globals) runner.globals(options.globals);\n  if (options.growl) this._growl(runner, reporter);\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n\n  function done(failures) {\n      if (reporter.done) {\n          reporter.done(failures, fn);\n      } else fn && fn(failures);\n  }\n\n  return runner.run(done);\n};\n",
  "node_modules/mocha/lib/ms.js": "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options['long'] ? longFormat(val) : shortFormat(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction shortFormat(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction longFormat(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n",
  "node_modules/mocha/lib/pending.js": "\n/**\n * Expose `Pending`.\n */\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {String} message\n */\n\nfunction Pending(message) {\n    this.message = message;\n}\n",
  "node_modules/mocha/lib/reporters/base.js": "/**\n * Module dependencies.\n */\n\nvar tty = require('tty')\n  , diff = require('diff')\n  , ms = require('../ms')\n  , utils = require('../utils')\n  , supportsColor = process.env ? require('supports-color') : null;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date\n  , setTimeout = global.setTimeout\n  , setInterval = global.setInterval\n  , clearTimeout = global.clearTimeout\n  , clearInterval = global.clearInterval;\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors = process.env\n  ? (supportsColor || (process.env.MOCHA_COLORS !== undefined))\n  : false;\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n    'pass': 90\n  , 'fail': 31\n  , 'bright pass': 92\n  , 'bright fail': 91\n  , 'bright yellow': 93\n  , 'pending': 36\n  , 'suite': 0\n  , 'error title': 0\n  , 'error message': 31\n  , 'error stack': 90\n  , 'checkmark': 32\n  , 'fast': 90\n  , 'medium': 33\n  , 'slow': 31\n  , 'green': 32\n  , 'light': 90\n  , 'diff gutter': 90\n  , 'diff added': 32\n  , 'diff removed': 31\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '✓',\n  err: '✖',\n  dot: '․'\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif ('win32' == process.platform) {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {String} type\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nvar color = exports.color = function(type, str) {\n  if (!exports.useColors) return String(str);\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Expose term window size, with some\n * defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: isatty\n    ? process.stdout.getWindowSize\n      ? process.stdout.getWindowSize(1)[0]\n      : tty.getWindowSize()[1]\n    : 75\n};\n\n/**\n * Expose some basic cursor interactions\n * that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function(){\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function(){\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function(){\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function(){\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function(){\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\n/**\n * Outut the given `failures` as a list.\n *\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function(failures){\n  console.log();\n  failures.forEach(function(test, i){\n    // format\n    var fmt = color('error title', '  %s) %s:\\n')\n      + color('error message', '     %s')\n      + color('error stack', '\\n%s\\n');\n\n    // msg\n    var err = test.err\n      , message = err.message || ''\n      , stack = err.stack || message\n      , index = stack.indexOf(message)\n      , actual = err.actual\n      , expected = err.expected\n      , escape = true;\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (err.showDiff !== false && sameType(actual, expected)\n        && expected !== undefined) {\n\n      escape = false;\n      if (!(utils.isString(actual) && utils.isString(expected))) {\n        err.actual = actual = utils.stringify(actual);\n        err.expected = expected = utils.stringify(expected);\n      }\n\n      fmt = color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      if (exports.inlineDiffs) {\n        msg += inlineDiff(err, escape);\n      } else {\n        msg += unifiedDiff(err, escape);\n      }\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base(runner) {\n  var self = this\n    , stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 }\n    , failures = this.failures = [];\n\n  if (!runner) return;\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function(){\n    stats.start = new Date;\n  });\n\n  runner.on('suite', function(suite){\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function(test){\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function(test){\n    stats.passes = stats.passes || 0;\n\n    var medium = test.slow() / 2;\n    test.speed = test.duration > test.slow()\n      ? 'slow'\n      : test.duration > medium\n        ? 'medium'\n        : 'fast';\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function(test, err){\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.on('end', function(){\n    stats.end = new Date;\n    stats.duration = new Date - stats.start;\n  });\n\n  runner.on('pending', function(){\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @api public\n */\n\nBase.prototype.epilogue = function(){\n  var stats = this.stats;\n  var tests;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt = color('bright pass', ' ')\n    + color('green', ' %d passing')\n    + color('light', ' (%s)');\n\n  console.log(fmt,\n    stats.passes || 0,\n    ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ')\n      + color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @param {String} str\n * @param {String} len\n * @return {String}\n * @api private\n */\n\nfunction pad(str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output\n *\n * @param {Error} Error with actual/expected\n * @return {String} Diff\n * @api private\n */\n\nfunction inlineDiff(err, escape) {\n  var msg = errorDiff(err, 'WordsWithSpace', escape);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines.map(function(str, i){\n      return pad(++i, width) + ' |' + ' ' + str;\n    }).join('\\n');\n  }\n\n  // legend\n  msg = '\\n'\n    + color('diff removed', 'actual')\n    + ' '\n    + color('diff added', 'expected')\n    + '\\n\\n'\n    + msg\n    + '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between 2 strings\n *\n * @param {Error} Error with actual/expected\n * @return {String} Diff\n * @api private\n */\n\nfunction unifiedDiff(err, escape) {\n  var indent = '      ';\n  function cleanUp(line) {\n    if (escape) {\n      line = escapeInvisibles(line);\n    }\n    if (line[0] === '+') return indent + colorLines('diff added', line);\n    if (line[0] === '-') return indent + colorLines('diff removed', line);\n    if (line.match(/\\@\\@/)) return null;\n    if (line.match(/\\\\ No newline/)) return null;\n    else return indent + line;\n  }\n  function notBlank(line) {\n    return line != null;\n  }\n  var msg = diff.createPatch('string', err.actual, err.expected);\n  var lines = msg.split('\\n').splice(4);\n  return '\\n      '\n         + colorLines('diff added',   '+ expected') + ' '\n         + colorLines('diff removed', '- actual')\n         + '\\n\\n'\n         + lines.map(cleanUp).filter(notBlank).join('\\n');\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @param {Error} err\n * @return {String}\n * @api private\n */\n\nfunction errorDiff(err, type, escape) {\n  var actual   = escape ? escapeInvisibles(err.actual)   : err.actual;\n  var expected = escape ? escapeInvisibles(err.expected) : err.expected;\n  return diff['diff' + type](actual, expected).map(function(str){\n    if (str.added) return colorLines('diff added', str.value);\n    if (str.removed) return colorLines('diff removed', str.value);\n    return str.value;\n  }).join('');\n}\n\n/**\n * Returns a string with all invisible characters in plain text\n *\n * @param {String} line\n * @return {String}\n * @api private\n */\nfunction escapeInvisibles(line) {\n    return line.replace(/\\t/g, '<tab>')\n               .replace(/\\r/g, '<CR>')\n               .replace(/\\n/g, '<LF>\\n');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @param {String} name\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction colorLines(name, str) {\n  return str.split('\\n').map(function(str){\n    return color(name, str);\n  }).join('\\n');\n}\n\n/**\n * Check that a / b have the same type.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Boolean}\n * @api private\n */\n\nfunction sameType(a, b) {\n  a = Object.prototype.toString.call(a);\n  b = Object.prototype.toString.call(b);\n  return a == b;\n}\n",
  "node_modules/mocha/lib/reporters/doc.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Doc(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , total = runner.total\n    , indents = 2;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function(suite){\n    if (suite.root) return;\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function(suite){\n    if (suite.root) return;\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function(test){\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.fn.toString()));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function(test, err){\n    console.log('%s  <dt class=\"error\">%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.fn.toString()));\n    console.log('%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>', indent(), code);\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n",
  "node_modules/mocha/lib/reporters/dot.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Dot(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , width = Base.window.width * .75 | 0\n    , n = -1;\n\n  runner.on('start', function(){\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function(test){\n    if (++n % width == 0) process.stdout.write('\\n  ');\n    process.stdout.write(color('pending', Base.symbols.dot));\n  });\n\n  runner.on('pass', function(test){\n    if (++n % width == 0) process.stdout.write('\\n  ');\n    if ('slow' == test.speed) {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function(test, err){\n    if (++n % width == 0) process.stdout.write('\\n  ');\n    process.stdout.write(color('fail', Base.symbols.dot));\n  });\n\n  runner.on('end', function(){\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nDot.prototype.__proto__ = Base.prototype;\n",
  "node_modules/mocha/lib/reporters/html-cov.js": "/**\n * Module dependencies.\n */\n\nvar JSONCov = require('./json-cov')\n  , fs = require('fs');\n\n/**\n * Expose `HTMLCov`.\n */\n\nexports = module.exports = HTMLCov;\n\n/**\n * Initialize a new `JsCoverage` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction HTMLCov(runner) {\n  var jade = require('jade')\n    , file = __dirname + '/templates/coverage.jade'\n    , str = fs.readFileSync(file, 'utf8')\n    , fn = jade.compile(str, { filename: file })\n    , self = this;\n\n  JSONCov.call(this, runner, false);\n\n  runner.on('end', function(){\n    process.stdout.write(fn({\n        cov: self.cov\n      , coverageClass: coverageClass\n    }));\n  });\n}\n\n/**\n * Return coverage class for `n`.\n *\n * @return {String}\n * @api private\n */\n\nfunction coverageClass(n) {\n  if (n >= 75) return 'high';\n  if (n >= 50) return 'medium';\n  if (n >= 25) return 'low';\n  return 'terrible';\n}\n",
  "node_modules/mocha/lib/reporters/html.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , utils = require('../utils')\n  , Progress = require('../browser/progress')\n  , escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date\n  , setTimeout = global.setTimeout\n  , setInterval = global.setInterval\n  , clearTimeout = global.clearTimeout\n  , clearInterval = global.clearInterval;\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate = '<ul id=\"mocha-stats\">'\n  + '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>'\n  + '<li class=\"passes\"><a href=\"#\">passes:</a> <em>0</em></li>'\n  + '<li class=\"failures\"><a href=\"#\">failures:</a> <em>0</em></li>'\n  + '<li class=\"duration\">duration: <em>0</em>s</li>'\n  + '</ul>';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction HTML(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , total = runner.total\n    , stat = fragment(statsTemplate)\n    , items = stat.getElementsByTagName('li')\n    , passes = items[1].getElementsByTagName('em')[0]\n    , passesLink = items[1].getElementsByTagName('a')[0]\n    , failures = items[2].getElementsByTagName('em')[0]\n    , failuresLink = items[2].getElementsByTagName('a')[0]\n    , duration = items[3].getElementsByTagName('em')[0]\n    , canvas = stat.getElementsByTagName('canvas')[0]\n    , report = fragment('<ul id=\"mocha-report\"></ul>')\n    , stack = [report]\n    , progress\n    , ctx\n    , root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress;\n  }\n\n  if (!root) return error('#mocha div missing, add it to your document');\n\n  // pass toggle\n  on(passesLink, 'click', function(){\n    unhide();\n    var name = /pass/.test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) hideSuitesWithout('test pass');\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function(){\n    unhide();\n    var name = /fail/.test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) hideSuitesWithout('test fail');\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) progress.size(40);\n\n  runner.on('suite', function(suite){\n    if (suite.root) return;\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function(suite){\n    if (suite.root) return;\n    stack.shift();\n  });\n\n  runner.on('fail', function(test, err){\n    if ('hook' == test.type) runner.emit('test end', test);\n  });\n\n  runner.on('test end', function(test){\n    // TODO: add to stats\n    var percent = stats.tests / this.total * 100 | 0;\n    if (progress) progress.update(percent).draw(ctx);\n\n    // update stats\n    var ms = new Date - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n\n    // test\n    if ('passed' == test.state) {\n      var url = self.testURL(test);\n      var el = fragment('<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> <a href=\"%s\" class=\"replay\">‣</a></h2></li>', test.speed, test.title, test.duration, url);\n    } else if (test.pending) {\n      var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\n    } else {\n      var el = fragment('<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">‣</a></h2></li>', test.title, self.testURL(test));\n      var str = test.err.stack || test.err.toString();\n\n      // FF / Opera do not add the message\n      if (!~str.indexOf(test.err.message)) {\n        str = test.err.message + '\\n' + str;\n      }\n\n      // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n      // check for the result of the stringifying.\n      if ('[object Error]' == str) str = test.err.message;\n\n      // Safari doesn't give you a stack. Let's at least provide a source line.\n      if (!test.err.stack && test.err.sourceURL && test.err.line !== undefined) {\n        str += \"\\n(\" + test.err.sourceURL + \":\" + test.err.line + \")\";\n      }\n\n      el.appendChild(fragment('<pre class=\"error\">%e</pre>', str));\n    }\n\n    // toggle code\n    // TODO: defer\n    if (!test.pending) {\n      var h2 = el.getElementsByTagName('h2')[0];\n\n      on(h2, 'click', function(){\n        pre.style.display = 'none' == pre.style.display\n          ? 'block'\n          : 'none';\n      });\n\n      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.fn.toString()));\n      el.appendChild(pre);\n      pre.style.display = 'none';\n    }\n\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) stack[0].appendChild(el);\n  });\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n * @param {string} s\n * @returns {string} your new URL\n */\nvar makeUrl = function makeUrl(s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return window.location.pathname + (search ? search + '&' : '?' ) + 'grep=' + encodeURIComponent(s);\n};\n\n/**\n * Provide suite URL\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function(suite){\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL\n *\n * @param {Object} [test]\n */\n\nHTML.prototype.testURL = function(test){\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Display error `msg`.\n */\n\nfunction error(msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n */\n\nfunction fragment(html) {\n  var args = arguments\n    , div = document.createElement('div')\n    , i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function(_, type){\n    switch (type) {\n      case 's': return String(args[i++]);\n      case 'e': return escape(args[i++]);\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n */\n\nfunction hideSuitesWithout(classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (0 == els.length) suites[i].className += ' hidden';\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\n\nfunction unhide() {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set `el` text to `str`.\n */\n\nfunction text(el, str) {\n  if (el.textContent) {\n    el.textContent = str;\n  } else {\n    el.innerText = str;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\n\nfunction on(el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n",
  "node_modules/mocha/lib/reporters/index.js": "exports.Base = require('./base');\nexports.Dot = require('./dot');\nexports.Doc = require('./doc');\nexports.TAP = require('./tap');\nexports.JSON = require('./json');\nexports.HTML = require('./html');\nexports.List = require('./list');\nexports.Min = require('./min');\nexports.Spec = require('./spec');\nexports.Nyan = require('./nyan');\nexports.XUnit = require('./xunit');\nexports.Markdown = require('./markdown');\nexports.Progress = require('./progress');\nexports.Landing = require('./landing');\nexports.JSONCov = require('./json-cov');\nexports.HTMLCov = require('./html-cov');\nexports.JSONStream = require('./json-stream');\n",
  "node_modules/mocha/lib/reporters/json-cov.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSONCov`.\n */\n\nexports = module.exports = JSONCov;\n\n/**\n * Initialize a new `JsCoverage` reporter.\n *\n * @param {Runner} runner\n * @param {Boolean} output\n * @api public\n */\n\nfunction JSONCov(runner, output) {\n  var self = this\n    , output = 1 == arguments.length ? true : output;\n\n  Base.call(this, runner);\n\n  var tests = []\n    , failures = []\n    , passes = [];\n\n  runner.on('test end', function(test){\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test){\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test){\n    failures.push(test);\n  });\n\n  runner.on('end', function(){\n    var cov = global._$jscoverage || {};\n    var result = self.cov = map(cov);\n    result.stats = self.stats;\n    result.tests = tests.map(clean);\n    result.failures = failures.map(clean);\n    result.passes = passes.map(clean);\n    if (!output) return;\n    process.stdout.write(JSON.stringify(result, null, 2 ));\n  });\n}\n\n/**\n * Map jscoverage data to a JSON structure\n * suitable for reporting.\n *\n * @param {Object} cov\n * @return {Object}\n * @api private\n */\n\nfunction map(cov) {\n  var ret = {\n      instrumentation: 'node-jscoverage'\n    , sloc: 0\n    , hits: 0\n    , misses: 0\n    , coverage: 0\n    , files: []\n  };\n\n  for (var filename in cov) {\n    var data = coverage(filename, cov[filename]);\n    ret.files.push(data);\n    ret.hits += data.hits;\n    ret.misses += data.misses;\n    ret.sloc += data.sloc;\n  }\n\n  ret.files.sort(function(a, b) {\n    return a.filename.localeCompare(b.filename);\n  });\n\n  if (ret.sloc > 0) {\n    ret.coverage = (ret.hits / ret.sloc) * 100;\n  }\n\n  return ret;\n}\n\n/**\n * Map jscoverage data for a single source file\n * to a JSON structure suitable for reporting.\n *\n * @param {String} filename name of the source file\n * @param {Object} data jscoverage coverage data\n * @return {Object}\n * @api private\n */\n\nfunction coverage(filename, data) {\n  var ret = {\n    filename: filename,\n    coverage: 0,\n    hits: 0,\n    misses: 0,\n    sloc: 0,\n    source: {}\n  };\n\n  data.source.forEach(function(line, num){\n    num++;\n\n    if (data[num] === 0) {\n      ret.misses++;\n      ret.sloc++;\n    } else if (data[num] !== undefined) {\n      ret.hits++;\n      ret.sloc++;\n    }\n\n    ret.source[num] = {\n        source: line\n      , coverage: data[num] === undefined\n        ? ''\n        : data[num]\n    };\n  });\n\n  ret.coverage = ret.hits / ret.sloc * 100;\n\n  return ret;\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @param {Object} test\n * @return {Object}\n * @api private\n */\n\nfunction clean(test) {\n  return {\n      title: test.title\n    , fullTitle: test.fullTitle()\n    , duration: test.duration\n  }\n}\n",
  "node_modules/mocha/lib/reporters/json-stream.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , color = Base.color;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , total = runner.total;\n\n  runner.on('start', function(){\n    console.log(JSON.stringify(['start', { total: total }]));\n  });\n\n  runner.on('pass', function(test){\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function(test, err){\n    test = clean(test);\n    test.err = err.message;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.on('end', function(){\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @param {Object} test\n * @return {Object}\n * @api private\n */\n\nfunction clean(test) {\n  return {\n      title: test.title\n    , fullTitle: test.fullTitle()\n    , duration: test.duration\n  }\n}\n",
  "node_modules/mocha/lib/reporters/json.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction JSONReporter(runner) {\n  var self = this;\n  Base.call(this, runner);\n\n  var tests = []\n    , pending = []\n    , failures = []\n    , passes = [];\n\n  runner.on('test end', function(test){\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test){\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test){\n    failures.push(test);\n  });\n\n  runner.on('pending', function(test){\n    pending.push(test);\n  });\n\n  runner.on('end', function(){\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @param {Object} test\n * @return {Object}\n * @api private\n */\n\nfunction clean(test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    err: errorJSON(test.err || {})\n  }\n}\n\n/**\n * Transform `error` into a JSON object.\n * @param {Error} err\n * @return {Object}\n */\n\nfunction errorJSON(err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function(key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n",
  "node_modules/mocha/lib/reporters/landing.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Landing(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , width = Base.window.width * .75 | 0\n    , total = runner.total\n    , stream = process.stdout\n    , plane = color('plane', '✈')\n    , crashed = -1\n    , n = 0;\n\n  function runway() {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function(){\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function(test){\n    // check if the plane crashed\n    var col = -1 == crashed\n      ? width * ++n / total | 0\n      : crashed;\n\n    // show the crash\n    if ('failed' == test.state) {\n      plane = color('plane crash', '✈');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b['+(width+1)+'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('⋅')));\n    stream.write(plane)\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.on('end', function(){\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nLanding.prototype.__proto__ = Base.prototype;\n",
  "node_modules/mocha/lib/reporters/list.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , n = 0;\n\n  runner.on('start', function(){\n    console.log();\n  });\n\n  runner.on('test', function(test){\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function(test){\n    var fmt = color('checkmark', '  -')\n      + color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function(test){\n    var fmt = color('checkmark', '  '+Base.symbols.dot)\n      + color('pass', ' %s: ')\n      + color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function(test, err){\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nList.prototype.__proto__ = Base.prototype;\n",
  "node_modules/mocha/lib/reporters/markdown.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Markdown(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , level = 0\n    , buf = '';\n\n  function title(str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function indent() {\n    return Array(level).join('  ');\n  }\n\n  function mapTOC(suite, obj) {\n    var ret = obj,\n        key = SUITE_PREFIX + suite.title;\n    obj = obj[key] = obj[key] || { suite: suite };\n    suite.suites.forEach(function(suite){\n      mapTOC(suite, obj);\n    });\n    return ret;\n  }\n\n  function stringifyTOC(obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if ('suite' == key) continue;\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC(suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function(suite){\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function(suite){\n    --level;\n  });\n\n  runner.on('pass', function(test){\n    var code = utils.clean(test.fn.toString());\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.on('end', function(){\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n",
  "node_modules/mocha/lib/reporters/min.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Min(runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function(){\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.on('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nMin.prototype.__proto__ = Base.prototype;\n",
  "node_modules/mocha/lib/reporters/nyan.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction NyanCat(runner) {\n  Base.call(this, runner);\n  var self = this\n    , stats = this.stats\n    , width = Base.window.width * .75 | 0\n    , rainbowColors = this.rainbowColors = self.generateColors()\n    , colorIndex = this.colorIndex = 0\n    , numerOfLines = this.numberOfLines = 4\n    , trajectories = this.trajectories = [[], [], [], []]\n    , nyanCatWidth = this.nyanCatWidth = 11\n    , trajectoryWidthMax = this.trajectoryWidthMax = (width - nyanCatWidth)\n    , scoreboardWidth = this.scoreboardWidth = 5\n    , tick = this.tick = 0\n    , n = 0;\n\n  runner.on('start', function(){\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function(test){\n    self.draw();\n  });\n\n  runner.on('pass', function(test){\n    self.draw();\n  });\n\n  runner.on('fail', function(test, err){\n    self.draw();\n  });\n\n  runner.on('end', function(){\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) write('\\n');\n    self.epilogue();\n  });\n}\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function(){\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function(){\n  var stats = this.stats;\n\n  function draw(type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function(){\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) trajectory.shift();\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function(){\n  var self = this;\n\n  this.trajectories.forEach(function(line, index) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.drawNyanCat = function() {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  var face;\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @return {String}\n * @api private\n */\n\nNyanCat.prototype.face = function() {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if(stats.passes) {\n    return '( ^ .^)';\n  } else {\n    return '( - .-)';\n  }\n};\n\n/**\n * Move cursor up `n`.\n *\n * @param {Number} n\n * @api private\n */\n\nNyanCat.prototype.cursorUp = function(n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @param {Number} n\n * @api private\n */\n\nNyanCat.prototype.cursorDown = function(n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @return {Array}\n * @api private\n */\n\nNyanCat.prototype.generateColors = function(){\n  var colors = [];\n\n  for (var i = 0; i < (6 * 7); i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = (i * (1.0 / 6));\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nNyanCat.prototype.rainbowify = function(str){\n  if (!Base.useColors)\n    return str;\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n */\n\nfunction write(string) {\n  process.stdout.write(string);\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nNyanCat.prototype.__proto__ = Base.prototype;\n",
  "node_modules/mocha/lib/reporters/progress.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @param {Runner} runner\n * @param {Object} options\n * @api public\n */\n\nfunction Progress(runner, options) {\n  Base.call(this, runner);\n\n  var self = this\n    , options = options || {}\n    , stats = this.stats\n    , width = Base.window.width * .50 | 0\n    , total = runner.total\n    , complete = 0\n    , max = Math.max\n    , lastN = -1;\n\n  // default chars\n  options.open = options.open || '[';\n  options.complete = options.complete || '▬';\n  options.incomplete = options.incomplete || Base.symbols.dot;\n  options.close = options.close || ']';\n  options.verbose = false;\n\n  // tests started\n  runner.on('start', function(){\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function(){\n    complete++;\n    var incomplete = total - complete\n      , percent = complete / total\n      , n = width * percent | 0\n      , i = width - n;\n\n    if (lastN === n && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.on('end', function(){\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nProgress.prototype.__proto__ = Base.prototype;\n",
  "node_modules/mocha/lib/reporters/spec.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Spec(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , indents = 0\n    , n = 0;\n\n  function indent() {\n    return Array(indents).join('  ')\n  }\n\n  runner.on('start', function(){\n    console.log();\n  });\n\n  runner.on('suite', function(suite){\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function(suite){\n    --indents;\n    if (1 == indents) console.log();\n  });\n\n  runner.on('pending', function(test){\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function(test){\n    if ('fast' == test.speed) {\n      var fmt = indent()\n        + color('checkmark', '  ' + Base.symbols.ok)\n        + color('pass', ' %s');\n      cursor.CR();\n      console.log(fmt, test.title);\n    } else {\n      var fmt = indent()\n        + color('checkmark', '  ' + Base.symbols.ok)\n        + color('pass', ' %s')\n        + color(test.speed, ' (%dms)');\n      cursor.CR();\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function(test, err){\n    cursor.CR();\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nSpec.prototype.__proto__ = Base.prototype;\n",
  "node_modules/mocha/lib/reporters/tap.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction TAP(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , n = 1\n    , passes = 0\n    , failures = 0;\n\n  runner.on('start', function(){\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function(){\n    ++n;\n  });\n\n  runner.on('pending', function(test){\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function(test){\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function(test, err){\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) console.log(err.stack.replace(/^/gm, '  '));\n  });\n\n  runner.on('end', function(){\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @param {Object} test\n * @return {String}\n * @api private\n */\n\nfunction title(test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n",
  "node_modules/mocha/lib/reporters/xunit.js": "/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , utils = require('../utils')\n  , fs = require('fs')\n  , escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date\n  , setTimeout = global.setTimeout\n  , setInterval = global.setInterval\n  , clearTimeout = global.clearTimeout\n  , clearInterval = global.clearInterval;\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction XUnit(runner, options) {\n  Base.call(this, runner);\n  var stats = this.stats\n    , tests = []\n    , self = this;\n\n  if (options.reporterOptions && options.reporterOptions.output) {\n      if (! fs.createWriteStream) {\n          throw new Error('file output not supported in browser');\n      }\n      self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n  }\n\n  runner.on('pending', function(test){\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test){\n    tests.push(test);\n  });\n\n  runner.on('fail', function(test){\n    tests.push(test);\n  });\n\n  runner.on('end', function(){\n    self.write(tag('testsuite', {\n        name: 'Mocha Tests'\n      , tests: stats.tests\n      , failures: stats.failures\n      , errors: stats.failures\n      , skipped: stats.tests - stats.failures - stats.passes\n      , timestamp: (new Date).toUTCString()\n      , time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(function(t) { self.test(t); });\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Override done to close the stream (if it's a file).\n */\nXUnit.prototype.done = function(failures, fn) {\n    if (this.fileStream) {\n        this.fileStream.end(function() {\n            fn(failures);\n        });\n    } else {\n        fn(failures);\n    }\n};\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nXUnit.prototype.__proto__ = Base.prototype;\n\n/**\n * Write out the given line\n */\nXUnit.prototype.write = function(line) {\n    if (this.fileStream) {\n        this.fileStream.write(line + '\\n');\n    } else {\n        console.log(line);\n    }\n};\n\n/**\n * Output tag for the given `test.`\n */\n\nXUnit.prototype.test = function(test, ostream) {\n  var attrs = {\n      classname: test.parent.fullTitle()\n    , name: test.title\n    , time: (test.duration / 1000) || 0\n  };\n\n  if ('failed' == test.state) {\n    var err = test.err;\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, cdata(escape(err.message) + \"\\n\" + err.stack))));\n  } else if (test.pending) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true) );\n  }\n};\n\n/**\n * HTML tag helper.\n */\n\nfunction tag(name, attrs, close, content) {\n  var end = close ? '/>' : '>'\n    , pairs = []\n    , tag;\n\n  for (var key in attrs) {\n    pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) tag += content + '</' + name + end;\n  return tag;\n}\n\n/**\n * Return cdata escaped CDATA `str`.\n */\n\nfunction cdata(str) {\n  return '<![CDATA[' + escape(str) + ']]>';\n}\n",
  "node_modules/mocha/lib/runnable.js": "/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter\n  , debug = require('debug')('mocha:runnable')\n  , Pending = require('./pending')\n  , milliseconds = require('./ms')\n  , utils = require('./utils');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date\n  , setTimeout = global.setTimeout\n  , setInterval = global.setInterval\n  , clearTimeout = global.clearTimeout\n  , clearInterval = global.clearInterval;\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\n\nfunction Runnable(title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.async = fn && fn.length;\n  this.sync = ! this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._trace = new Error('done() called multiple times')\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nRunnable.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Set & get timeout `ms`.\n *\n * @param {Number|String} ms\n * @return {Runnable|Number} ms or self\n * @api private\n */\n\nRunnable.prototype.timeout = function(ms){\n  if (0 == arguments.length) return this._timeout;\n  if (ms === 0) this._enableTimeouts = false;\n  if ('string' == typeof ms) ms = milliseconds(ms);\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) this.resetTimeout();\n  return this;\n};\n\n/**\n * Set & get slow `ms`.\n *\n * @param {Number|String} ms\n * @return {Runnable|Number} ms or self\n * @api private\n */\n\nRunnable.prototype.slow = function(ms){\n  if (0 === arguments.length) return this._slow;\n  if ('string' == typeof ms) ms = milliseconds(ms);\n  debug('timeout %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and & get timeout `enabled`.\n *\n * @param {Boolean} enabled\n * @return {Runnable|Boolean} enabled or self\n * @api private\n */\n\nRunnable.prototype.enableTimeouts = function(enabled){\n  if (arguments.length === 0) return this._enableTimeouts;\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @api private\n */\n\nRunnable.prototype.skip = function(){\n    throw new Pending();\n};\n\n/**\n * Return the full title generated by recursively\n * concatenating the parent's full title.\n *\n * @return {String}\n * @api public\n */\n\nRunnable.prototype.fullTitle = function(){\n  return this.parent.fullTitle() + ' ' + this.title;\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\n\nRunnable.prototype.clearTimeout = function(){\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @return {String}\n * @api private\n */\n\nRunnable.prototype.inspect = function(){\n  return JSON.stringify(this, function(key, val){\n    if ('_' == key[0]) return;\n    if ('parent' == key) return '#<Suite>';\n    if ('ctx' == key) return '#<Context>';\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\n\nRunnable.prototype.resetTimeout = function(){\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) return;\n  this.clearTimeout();\n  this.timer = setTimeout(function(){\n    if (!self._enableTimeouts) return;\n    self.callback(new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.'));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Whitelist these globals for this test run\n *\n * @api private\n */\nRunnable.prototype.globals = function(arr){\n  var self = this;\n  this._allowedGlobals = arr;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\n\nRunnable.prototype.run = function(fn){\n  var self = this\n    , start = new Date\n    , ctx = this.ctx\n    , finished\n    , emitted;\n\n  // Some times the ctx exists but it is not runnable\n  if (ctx && ctx.runnable) ctx.runnable(this);\n\n  // called multiple times\n  function multiple(err) {\n    if (emitted) return;\n    emitted = true;\n    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));\n  }\n\n  // finished\n  function done(err) {\n    var ms = self.timeout();\n    if (self.timedOut) return;\n    if (finished) return multiple(err || self._trace);\n\n    // Discard the resolution if this test has already failed asynchronously\n    if (self.state) return;\n\n    self.clearTimeout();\n    self.duration = new Date - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) err = new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.');\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    try {\n      this.fn.call(ctx, function(err){\n        if (err instanceof Error || toString.call(err) === \"[object Error]\") return done(err);\n        if (null != err) {\n          if (Object.prototype.toString.call(err) === '[object Object]') {\n            return done(new Error('done() invoked with non-Error: ' + JSON.stringify(err)));\n          } else {\n            return done(new Error('done() invoked with non-Error: ' + err));\n          }\n        }\n        done();\n      });\n    } catch (err) {\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.asyncOnly) {\n    return done(new Error('--async-only option in use without declaring `done()`'));\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.pending) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    done(utils.getError(err));\n  }\n\n  function callFn(fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function() {\n          done()\n        },\n        function(reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'))\n        });\n    } else {\n      done();\n    }\n  }\n};\n",
  "node_modules/mocha/lib/runner.js": "/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter\n  , debug = require('debug')('mocha:runner')\n  , Pending = require('./pending')\n  , Test = require('./test')\n  , utils = require('./utils')\n  , filter = utils.filter\n  , keys = utils.keys\n  , type = utils.type\n  , stringify = utils.stringify\n  , stackFilter = utils.stackTraceFilter();\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`.\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @param {Suite} suite Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n *   until ready.\n * @api public\n */\n\nfunction Runner(suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function(test){ self.checkGlobals(test); });\n  this.on('hook end', function(hook){ self.checkGlobals(hook); });\n  this.grep(/.*/);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\n\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nRunner.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @param {RegExp} re\n * @param {Boolean} invert\n * @return {Runner} for chaining\n * @api public\n */\n\nRunner.prototype.grep = function(re, invert){\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @param {Suite} suite\n * @return {Number}\n * @api public\n */\n\nRunner.prototype.grepTotal = function(suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function(test){\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) match = !match;\n    if (match) total++;\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\n\nRunner.prototype.globalProps = function() {\n  var props = utils.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~utils.indexOf(props, globals[i])) continue;\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @param {Array} arr\n * @return {Runner} for chaining\n * @api public\n */\n\nRunner.prototype.globals = function(arr){\n  if (0 == arguments.length) return this._globals;\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\n\nRunner.prototype.checkGlobals = function(test){\n  if (this.ignoreLeaks) return;\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if(this.prevGlobalsLength == globals.length) return;\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @param {Test} test\n * @param {Error} err\n * @api private\n */\n\nRunner.prototype.fail = function(test, err) {\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error)) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  err.stack = (this.fullStackTrace || !err.stack)\n    ? err.stack\n    : stackFilter(err.stack);\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @param {Hook} hook\n * @param {Error} err\n * @api private\n */\n\nRunner.prototype.failHook = function(hook, err){\n  this.fail(hook, err);\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @param {String} name\n * @param {Function} function\n * @api private\n */\n\nRunner.prototype.hook = function(name, fn){\n  var suite = this.suite\n    , hooks = suite['_' + name]\n    , self = this\n    , timer;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) return fn();\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    hook.on('error', function(err){\n      self.failHook(hook, err);\n    });\n\n    hook.run(function(err){\n      hook.removeAllListeners('error');\n      var testError = hook.error();\n      if (testError) self.fail(self.test, testError);\n      if (err) {\n        if (err instanceof Pending) {\n          suite.pending = true;\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function(){\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @param {String} name\n * @param {Array} suites\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.hooks = function(name, suites, fn){\n  var self = this\n    , orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function(err){\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.hookUp = function(name, fn){\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.hookDown = function(name, fn){\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\n\nRunner.prototype.parents = function(){\n  var suite = this.suite\n    , suites = [];\n  while (suite = suite.parent) suites.push(suite);\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.runTest = function(fn){\n  var test = this.test\n    , self = this;\n\n  if (this.asyncOnly) test.asyncOnly = true;\n\n  try {\n    test.on('error', function(err){\n      self.fail(test, err);\n    });\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke\n * the callback `fn()` when complete.\n *\n * @param {Suite} suite\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.runTests = function(suite, fn){\n  var self = this\n    , tests = suite.tests.slice()\n    , test;\n\n\n  function hookErr(err, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function(err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) return hookErr(err2, errSuite2, true);\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) return fn();\n\n    if (self._abort) return fn();\n\n    if (err) return hookErr(err, errSuite, true);\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) return fn();\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) match = !match;\n    if (!match) return next();\n\n    // pending\n    if (test.pending) {\n      self.emit('pending', test);\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function(err, errSuite){\n\n      if (suite.pending) {\n        self.emit('pending', test);\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) return hookErr(err, errSuite, false);\n\n      self.currentRunnable = self.test;\n      self.runTest(function(err){\n        test = self.test;\n\n        if (err) {\n          if (err instanceof Pending) {\n            self.emit('pending', test);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the\n * callback `fn()` when complete.\n *\n * @param {Suite} suite\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.runSuite = function(suite, fn){\n  var total = this.grepTotal(suite)\n    , self = this\n    , i = 0;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total) return fn();\n\n  this.emit('suite', this.suite = suite);\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite == suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      } else {\n        // errSuite is among the parents of current suite\n        // stop execution of errSuite and all sub-suites\n        return done(errSuite);\n      }\n    }\n\n    if (self._abort) return done();\n\n    var curr = suite.suites[i++];\n    if (!curr) return done();\n    self.runSuite(curr, next);\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.hook('afterAll', function(){\n      self.emit('suite end', suite);\n      fn(errSuite);\n    });\n  }\n\n  this.hook('beforeAll', function(err){\n    if (err) return done();\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\n\nRunner.prototype.uncaught = function(err){\n  if (err) {\n    debug('uncaught exception %s', err !== function () {\n      return this;\n    }.call(err) ? err : ( err.message || err ));\n  } else {\n    debug('uncaught undefined exception');\n    err = utils.undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n  if (!runnable) return;\n\n  runnable.clearTimeout();\n\n  // Ignore errors if complete\n  if (runnable.state) return;\n  this.fail(runnable, err);\n\n  // recover from test\n  if ('test' == runnable.type) {\n    this.emit('test end', runnable);\n    this.hookUp('afterEach', this.next);\n    return;\n  }\n\n  // bail on hooks\n  this.emit('end');\n};\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @param {Function} fn\n * @return {Runner} for chaining\n * @api public\n */\n\nRunner.prototype.run = function(fn){\n  var self = this,\n    rootSuite = this.suite;\n\n  fn = fn || function(){};\n\n  function uncaught(err){\n    self.uncaught(err);\n  }\n\n  function start() {\n    self.emit('start');\n    self.runSuite(rootSuite, function(){\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // callback\n  this.on('end', function(){\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  }\n  else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution\n *\n * @return {Runner} for chaining\n * @api public\n */\nRunner.prototype.abort = function(){\n  debug('aborting');\n  this._abort = true;\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n * @api private\n */\n\nfunction filterLeaks(ok, globals) {\n  return filter(globals, function(key){\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^d+/.test(key)) return false;\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method not init at first\n    // it is assigned in some seconds\n    if (global.navigator && /^getInterface/.test(key)) return false;\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && /^\\d+/.test(key)) return false;\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) return false;\n\n    var matched = filter(ok, function(ok){\n      if (~ok.indexOf('*')) return 0 == key.indexOf(ok.split('*')[0]);\n      return key == ok;\n    });\n    return matched.length == 0 && (!global.navigator || 'onerror' !== key);\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\n\nfunction extraGlobals() {\n if (typeof(process) === 'object' &&\n     typeof(process.version) === 'string') {\n\n   var nodeVersion = process.version.split('.').reduce(function(a, v) {\n     return a << 8 | v;\n   });\n\n   // 'errno' was renamed to process._errno in v0.9.11.\n\n   if (nodeVersion < 0x00090B) {\n     return ['errno'];\n   }\n }\n\n return [];\n}\n",
  "node_modules/mocha/lib/suite.js": "/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter\n  , debug = require('debug')('mocha:suite')\n  , milliseconds = require('./ms')\n  , utils = require('./utils')\n  , Hook = require('./hook');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title`\n * and parent `Suite`. When a suite with the\n * same title is already present, that suite\n * is returned to provide nicer reporter\n * and more flexible meta-testing.\n *\n * @param {Suite} parent\n * @param {String} title\n * @return {Suite}\n * @api public\n */\n\nexports.create = function(parent, title){\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  if (parent.pending) suite.pending = true;\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given\n * `title` and `ctx`.\n *\n * @param {String} title\n * @param {Context} ctx\n * @api private\n */\n\nfunction Suite(title, parentContext) {\n  this.title = title;\n  var context = function() {};\n  context.prototype = parentContext;\n  this.ctx = new context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nSuite.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Return a clone of this `Suite`.\n *\n * @return {Suite}\n * @api private\n */\n\nSuite.prototype.clone = function(){\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set timeout `ms` or short-hand such as \"2s\".\n *\n * @param {Number|String} ms\n * @return {Suite|Number} for chaining\n * @api private\n */\n\nSuite.prototype.timeout = function(ms){\n  if (0 == arguments.length) return this._timeout;\n  if (ms.toString() === '0') this._enableTimeouts = false;\n  if ('string' == typeof ms) ms = milliseconds(ms);\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n  * Set timeout `enabled`.\n  *\n  * @param {Boolean} enabled\n  * @return {Suite|Boolean} self or enabled\n  * @api private\n  */\n\nSuite.prototype.enableTimeouts = function(enabled){\n  if (arguments.length === 0) return this._enableTimeouts;\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set slow `ms` or short-hand such as \"2s\".\n *\n * @param {Number|String} ms\n * @return {Suite|Number} for chaining\n * @api private\n */\n\nSuite.prototype.slow = function(ms){\n  if (0 === arguments.length) return this._slow;\n  if ('string' == typeof ms) ms = milliseconds(ms);\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Sets whether to bail after first error.\n *\n * @param {Boolean} bail\n * @return {Suite|Number} for chaining\n * @api private\n */\n\nSuite.prototype.bail = function(bail){\n  if (0 == arguments.length) return this._bail;\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @param {Function} fn\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.beforeAll = function(title, fn){\n  if (this.pending) return this;\n  if ('function' === typeof title) {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @param {Function} fn\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.afterAll = function(title, fn){\n  if (this.pending) return this;\n  if ('function' === typeof title) {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @param {Function} fn\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.beforeEach = function(title, fn){\n  if (this.pending) return this;\n  if ('function' === typeof title) {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @param {Function} fn\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.afterEach = function(title, fn){\n  if (this.pending) return this;\n  if ('function' === typeof title) {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @param {Suite} suite\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.addSuite = function(suite){\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @param {Test} test\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.addTest = function(test){\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively\n * concatenating the parent's full title.\n *\n * @return {String}\n * @api public\n */\n\nSuite.prototype.fullTitle = function(){\n  if (this.parent) {\n    var full = this.parent.fullTitle();\n    if (full) return full + ' ' + this.title;\n  }\n  return this.title;\n};\n\n/**\n * Return the total number of tests.\n *\n * @return {Number}\n * @api public\n */\n\nSuite.prototype.total = function(){\n  return utils.reduce(this.suites, function(sum, suite){\n    return sum + suite.total();\n  }, 0) + this.tests.length;\n};\n\n/**\n * Iterates through each suite recursively to find\n * all tests. Applies a function in the format\n * `fn(test)`.\n *\n * @param {Function} fn\n * @return {Suite}\n * @api private\n */\n\nSuite.prototype.eachTest = function(fn){\n  utils.forEach(this.tests, fn);\n  utils.forEach(this.suites, function(suite){\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run() {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n",
  "node_modules/mocha/lib/test.js": "/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\n\n/**\n * Expose `Test`.\n */\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\n\nfunction Test(title, fn) {\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\n\nTest.prototype.__proto__ = Runnable.prototype;\n",
  "node_modules/mocha/lib/utils.js": "/**\n * Module dependencies.\n */\n\nvar fs = require('fs')\n  , path = require('path')\n  , basename = path.basename\n  , exists = fs.existsSync || path.existsSync\n  , glob = require('glob')\n  , join = path.join\n  , debug = require('debug')('mocha:watch');\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function(html){\n  return String(html)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};\n\n/**\n * Array#forEach (<=IE8)\n *\n * @param {Array} array\n * @param {Function} fn\n * @param {Object} scope\n * @api private\n */\n\nexports.forEach = function(arr, fn, scope){\n  for (var i = 0, l = arr.length; i < l; i++)\n    fn.call(scope, arr[i], i);\n};\n\n/**\n * Test if the given obj is type of string\n *\n * @param {Object} obj\n * @returns Boolean\n */\n\nexports.isString = function(obj) {\n  return 'string' === typeof obj;\n};\n\n/**\n * Array#map (<=IE8)\n *\n * @param {Array} array\n * @param {Function} fn\n * @param {Object} scope\n * @api private\n */\n\nexports.map = function(arr, fn, scope){\n  var result = [];\n  for (var i = 0, l = arr.length; i < l; i++)\n    result.push(fn.call(scope, arr[i], i, arr));\n  return result;\n};\n\n/**\n * Array#indexOf (<=IE8)\n *\n * @parma {Array} arr\n * @param {Object} obj to find index of\n * @param {Number} start\n * @api private\n */\n\nexports.indexOf = function(arr, obj, start){\n  for (var i = start || 0, l = arr.length; i < l; i++) {\n    if (arr[i] === obj)\n      return i;\n  }\n  return -1;\n};\n\n/**\n * Array#reduce (<=IE8)\n *\n * @param {Array} array\n * @param {Function} fn\n * @param {Object} initial value\n * @api private\n */\n\nexports.reduce = function(arr, fn, val){\n  var rval = val;\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    rval = fn(rval, arr[i], i, arr);\n  }\n\n  return rval;\n};\n\n/**\n * Array#filter (<=IE8)\n *\n * @param {Array} array\n * @param {Function} fn\n * @api private\n */\n\nexports.filter = function(arr, fn){\n  var ret = [];\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    var val = arr[i];\n    if (fn(val, i, arr)) ret.push(val);\n  }\n\n  return ret;\n};\n\n/**\n * Object.keys (<=IE8)\n *\n * @param {Object} obj\n * @return {Array} keys\n * @api private\n */\n\nexports.keys = Object.keys || function(obj) {\n  var keys = []\n    , has = Object.prototype.hasOwnProperty; // for `window` on <=IE8\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @param {Array} files\n * @param {Function} fn\n * @api private\n */\n\nexports.watch = function(files, fn){\n  var options = { interval: 100 };\n  files.forEach(function(file){\n    debug('file %s', file);\n    fs.watchFile(file, options, function(curr, prev){\n      if (prev.mtime < curr.mtime) fn(file);\n    });\n  });\n};\n\n/**\n * Array.isArray (<=IE8)\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nvar isArray = Array.isArray || function (obj) {\n  return '[object Array]' == {}.toString.call(obj);\n};\n\n/**\n * @description\n * Buffer.prototype.toJSON polyfill\n * @type {Function}\n */\nif(typeof Buffer !== 'undefined' && Buffer.prototype) {\n  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function () {\n    return Array.prototype.slice.call(this, 0);\n  };\n}\n\n/**\n * Ignored files.\n */\n\nfunction ignored(path){\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @return {Array}\n * @api private\n */\n\nexports.files = function(dir, ext, ret){\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  fs.readdirSync(dir)\n    .filter(ignored)\n    .forEach(function(path){\n      path = join(dir, path);\n      if (fs.statSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.slug = function(str){\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`,\n * and re-indent for pre whitespace.\n */\n\nexports.clean = function(str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, '')\n    .replace(/^function *\\(.*\\)\\s*{|\\(.*\\) *=> *{?/, '')\n    .replace(/\\s+\\}$/, '');\n\n  var spaces = str.match(/^\\n?( *)/)[1].length\n    , tabs = str.match(/^\\n?(\\t*)/)[1].length\n    , re = new RegExp('^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs ? tabs : spaces) + '}', 'gm');\n\n  str = str.replace(re, '');\n\n  return exports.trim(str);\n};\n\n/**\n * Trim the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.trim = function(str){\n  return str.replace(/^\\s+|\\s+$/g, '');\n};\n\n/**\n * Parse the given `qs`.\n *\n * @param {String} qs\n * @return {Object}\n * @api private\n */\n\nexports.parseQuery = function(qs){\n  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair){\n    var i = pair.indexOf('=')\n      , key = pair.slice(0, i)\n      , val = pair.slice(++i);\n\n    obj[key] = decodeURIComponent(val);\n    return obj;\n  }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @param {String} js\n * @return {String}\n * @api private\n */\n\nfunction highlight(js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/\\bnew[ \\t]+(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>')\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @param {String} name\n * @api private\n */\n\nexports.highlightTags = function(name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called, which returns\n * a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @param {*} value Value to inspect\n * @param {string} [type] The type of the value, if known.\n * @returns {string}\n */\nvar emptyRepresentation = function emptyRepresentation(value, type) {\n  type = type || exports.type(value);\n\n  switch(type) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n};\n\n/**\n * Takes some variable and asks `{}.toString()` what it thinks it is.\n * @param {*} value Anything\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @returns {string}\n */\nexports.type = function type(value) {\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString.call(value)\n    .replace(/^\\[.+\\s(.+?)\\]$/, '$1')\n    .toLowerCase();\n};\n\n/**\n * @summary Stringify `value`.\n * @description Different behavior depending on type of value.\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @see exports.type\n * @param {*} value\n * @return {string}\n * @api private\n */\n\nexports.stringify = function(value) {\n  var type = exports.type(value);\n\n  if (!~exports.indexOf(['object', 'array', 'function'], type)) {\n    if(type != 'buffer') {\n      return jsonStringify(value);\n    }\n    var json = value.toJSON();\n    // Based on the toJSON result\n    return jsonStringify(json.data && json.type ? json.data : json, 2)\n      .replace(/,(\\n|$)/g, '$1');\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(exports.canonicalize(value), 2).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, type);\n};\n\n/**\n * @description\n * like JSON.stringify but more sense.\n * @param {Object}  object\n * @param {Number=} spaces\n * @param {number=} depth\n * @returns {*}\n * @private\n */\nfunction jsonStringify(object, spaces, depth) {\n  if(typeof spaces == 'undefined') return _stringify(object);  // primitive types\n\n  depth = depth || 1;\n  var space = spaces * depth\n    , str = isArray(object) ? '[' : '{'\n    , end = isArray(object) ? ']' : '}'\n    , length = object.length || exports.keys(object).length\n    , repeat = function(s, n) { return new Array(n).join(s); }; // `.repeat()` polyfill\n\n  function _stringify(val) {\n    switch (exports.type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'number':\n        val = val === 0 && (1/val) === -Infinity // `-0`\n          ? '-0'\n          : val.toString();\n        break;\n      case 'date':\n        var sDate = isNaN(val.getTime())        // Invalid date\n          ? val.toString()\n          : val.toISOString();\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val = (val == '[Function]' || val == '[Circular]')\n          ? val\n          : JSON.stringify(val); //string\n    }\n    return val;\n  }\n\n  for(var i in object) {\n    if(!object.hasOwnProperty(i)) continue;        // not my business\n    --length;\n    str += '\\n ' + repeat(' ', space)\n      + (isArray(object) ? '' : '\"' + i + '\": ') // key\n      +  _stringify(object[i])                   // value\n      + (length ? ',' : '');                     // comma\n  }\n\n  return str + (str.length != 1                    // [], {}\n    ? '\\n' + repeat(' ', --space) + end\n    : end);\n}\n\n/**\n * Return if obj is a Buffer\n * @param {Object} arg\n * @return {Boolean}\n * @api private\n */\nexports.isBuffer = function (arg) {\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(arg);\n};\n\n/**\n * @summary Return a new Thing that has the keys in sorted order.  Recursive.\n * @description If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @return {(Object|Array|Function|string|undefined)}\n * @see {@link exports.stringify}\n * @api private\n */\n\nexports.canonicalize = function(value, stack) {\n  var canonicalizedObj,\n    type = exports.type(value),\n    prop,\n    withStack = function withStack(value, fn) {\n      stack.push(value);\n      fn();\n      stack.pop();\n    };\n\n  stack = stack || [];\n\n  if (exports.indexOf(stack, value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch(type) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function () {\n        canonicalizedObj = exports.map(value, function (item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, type);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function () {\n        exports.forEach(exports.keys(value).sort(), function (key) {\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value.toString();\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n */\nexports.lookupFiles = function lookupFiles(path, extensions, recursive) {\n  var files = [];\n  var re = new RegExp('\\\\.(' + extensions.join('|') + ')$');\n\n  if (!exists(path)) {\n    if (exists(path + '.js')) {\n      path += '.js';\n    } else {\n      files = glob.sync(path);\n      if (!files.length) throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");\n      return files;\n    }\n  }\n\n  try {\n    var stat = fs.statSync(path);\n    if (stat.isFile()) return path;\n  }\n  catch (ignored) {\n    return;\n  }\n\n  fs.readdirSync(path).forEach(function(file) {\n    file = join(path, file);\n    try {\n      var stat = fs.statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    }\n    catch (ignored) {\n      return;\n    }\n    if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') return;\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function() {\n  return new Error('Caught undefined error, did you throw without specifying what?');\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function(err) {\n  return err || exports.undefinedError();\n};\n\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha, node_modules, bower and componentJS from stack trace).\n * @returns {Function}\n */\n\nexports.stackTraceFilter = function() {\n  var slash = '/'\n    , is = typeof document === 'undefined'\n      ? { node: true }\n      : { browser: true }\n    , cwd = is.node\n      ? process.cwd() + slash\n      : location.href.replace(/\\/[^\\/]*$/, '/');\n\n  function isNodeModule (line) {\n    return (~line.indexOf('node_modules'));\n  }\n\n  function isMochaInternal (line) {\n    return (~line.indexOf('node_modules' + slash + 'mocha'))  ||\n      (~line.indexOf('components' + slash + 'mochajs'))       ||\n      (~line.indexOf('components' + slash + 'mocha'));\n  }\n\n  // node_modules, bower, componentJS\n  function isBrowserModule(line) {\n    return (~line.indexOf('node_modules')) ||\n      (~line.indexOf('components'));\n  }\n\n  function isNodeInternal (line) {\n    return (~line.indexOf('(timers.js:')) ||\n      (~line.indexOf('(events.js:'))      ||\n      (~line.indexOf('(node.js:'))        ||\n      (~line.indexOf('(module.js:'))      ||\n      (~line.indexOf('GeneratorFunctionPrototype.next (native)')) ||\n      false\n  }\n\n  return function(stack) {\n    stack = stack.split('\\n');\n\n    stack = exports.reduce(stack, function(list, line) {\n      if (is.node && (isNodeModule(line) ||\n        isMochaInternal(line) ||\n        isNodeInternal(line)))\n        return list;\n\n      if (is.browser && (isBrowserModule(line)))\n        return list;\n\n      // Clean up cwd(absolute)\n      list.push(line.replace(cwd, ''));\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  }\n};",
  "node_modules/mocha/mocha.js": ";(function(){\n\n// CommonJS require()\n\nfunction require(p){\n    var path = require.resolve(p)\n      , mod = require.modules[path];\n    if (!mod) throw new Error('failed to require \"' + p + '\"');\n    if (!mod.exports) {\n      mod.exports = {};\n      mod.call(mod.exports, mod, mod.exports, require.relative(path));\n    }\n    return mod.exports;\n  }\n\nrequire.modules = {};\n\nrequire.resolve = function (path){\n    var orig = path\n      , reg = path + '.js'\n      , index = path + '/index.js';\n    return require.modules[reg] && reg\n      || require.modules[index] && index\n      || orig;\n  };\n\nrequire.register = function (path, fn){\n    require.modules[path] = fn;\n  };\n\nrequire.relative = function (parent) {\n    return function(p){\n      if ('.' != p.charAt(0)) return require(p);\n\n      var path = parent.split('/')\n        , segs = p.split('/');\n      path.pop();\n\n      for (var i = 0; i < segs.length; i++) {\n        var seg = segs[i];\n        if ('..' == seg) path.pop();\n        else if ('.' != seg) path.push(seg);\n      }\n\n      return require(path.join('/'));\n    };\n  };\n\n\nrequire.register(\"browser/debug.js\", function(module, exports, require){\nmodule.exports = function(type){\n  return function(){\n  }\n};\n\n}); // module: browser/debug.js\n\nrequire.register(\"browser/diff.js\", function(module, exports, require){\n/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\nvar JsDiff = (function() {\n  /*jshint maxparams: 5*/\n  function clonePath(path) {\n    return { newPos: path.newPos, components: path.components.slice(0) };\n  }\n  function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  }\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n\n    return n;\n  }\n\n  var Diff = function(ignoreWhitespace) {\n    this.ignoreWhitespace = ignoreWhitespace;\n  };\n  Diff.prototype = {\n      diff: function(oldString, newString) {\n        // Handle the identity case (this is due to unrolling editLength == 0\n        if (newString === oldString) {\n          return [{ value: newString }];\n        }\n        if (!newString) {\n          return [{ value: oldString, removed: true }];\n        }\n        if (!oldString) {\n          return [{ value: newString, added: true }];\n        }\n\n        newString = this.tokenize(newString);\n        oldString = this.tokenize(oldString);\n\n        var newLen = newString.length, oldLen = oldString.length;\n        var maxEditLength = newLen + oldLen;\n        var bestPath = [{ newPos: -1, components: [] }];\n\n        // Seed editLength = 0\n        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n        if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {\n          return bestPath[0].components;\n        }\n\n        for (var editLength = 1; editLength <= maxEditLength; editLength++) {\n          for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {\n            var basePath;\n            var addPath = bestPath[diagonalPath-1],\n                removePath = bestPath[diagonalPath+1];\n            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n            if (addPath) {\n              // No one else is going to attempt to use this value, clear it\n              bestPath[diagonalPath-1] = undefined;\n            }\n\n            var canAdd = addPath && addPath.newPos+1 < newLen;\n            var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n            if (!canAdd && !canRemove) {\n              bestPath[diagonalPath] = undefined;\n              continue;\n            }\n\n            // Select the diagonal that we want to branch from. We select the prior\n            // path whose position in the new string is the farthest from the origin\n            // and does not pass the bounds of the diff graph\n            if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n              basePath = clonePath(removePath);\n              this.pushComponent(basePath.components, oldString[oldPos], undefined, true);\n            } else {\n              basePath = clonePath(addPath);\n              basePath.newPos++;\n              this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);\n            }\n\n            var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);\n\n            if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {\n              return basePath.components;\n            } else {\n              bestPath[diagonalPath] = basePath;\n            }\n          }\n        }\n      },\n\n      pushComponent: function(components, value, added, removed) {\n        var last = components[components.length-1];\n        if (last && last.added === added && last.removed === removed) {\n          // We need to clone here as the component clone operation is just\n          // as shallow array clone\n          components[components.length-1] =\n            {value: this.join(last.value, value), added: added, removed: removed };\n        } else {\n          components.push({value: value, added: added, removed: removed });\n        }\n      },\n      extractCommon: function(basePath, newString, oldString, diagonalPath) {\n        var newLen = newString.length,\n            oldLen = oldString.length,\n            newPos = basePath.newPos,\n            oldPos = newPos - diagonalPath;\n        while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {\n          newPos++;\n          oldPos++;\n\n          this.pushComponent(basePath.components, newString[newPos], undefined, undefined);\n        }\n        basePath.newPos = newPos;\n        return oldPos;\n      },\n\n      equals: function(left, right) {\n        var reWhitespace = /\\S/;\n        if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {\n          return true;\n        } else {\n          return left === right;\n        }\n      },\n      join: function(left, right) {\n        return left + right;\n      },\n      tokenize: function(value) {\n        return value;\n      }\n  };\n\n  var CharDiff = new Diff();\n\n  var WordDiff = new Diff(true);\n  var WordWithSpaceDiff = new Diff();\n  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\s+|\\b)/));\n  };\n\n  var CssDiff = new Diff(true);\n  CssDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/([{}:;,]|\\s+)/));\n  };\n\n  var LineDiff = new Diff();\n  LineDiff.tokenize = function(value) {\n    var retLines = [],\n        lines = value.split(/^/m);\n\n    for(var i = 0; i < lines.length; i++) {\n      var line = lines[i],\n          lastLine = lines[i - 1];\n\n      // Merge lines that may contain windows new lines\n      if (line == '\\n' && lastLine && lastLine[lastLine.length - 1] === '\\r') {\n        retLines[retLines.length - 1] += '\\n';\n      } else if (line) {\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  return {\n    Diff: Diff,\n\n    diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },\n    diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },\n    diffWordsWithSpace: function(oldStr, newStr) { return WordWithSpaceDiff.diff(oldStr, newStr); },\n    diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },\n\n    diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },\n\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\n      var ret = [];\n\n      ret.push('Index: ' + fileName);\n      ret.push('===================================================================');\n      ret.push('--- ' + fileName + (typeof oldHeader === 'undefined' ? '' : '\\t' + oldHeader));\n      ret.push('+++ ' + fileName + (typeof newHeader === 'undefined' ? '' : '\\t' + newHeader));\n\n      var diff = LineDiff.diff(oldStr, newStr);\n      if (!diff[diff.length-1].value) {\n        diff.pop();   // Remove trailing newline add\n      }\n      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\n\n      function contextLines(lines) {\n        return lines.map(function(entry) { return ' ' + entry; });\n      }\n      function eofNL(curRange, i, current) {\n        var last = diff[diff.length-2],\n            isLast = i === diff.length-2,\n            isLastOfType = i === diff.length-3 && (current.added !== last.added || current.removed !== last.removed);\n\n        // Figure out if this is the last line for the given file and missing NL\n        if (!/\\n$/.test(current.value) && (isLast || isLastOfType)) {\n          curRange.push('\\\\ No newline at end of file');\n        }\n      }\n\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\n          oldLine = 1, newLine = 1;\n      for (var i = 0; i < diff.length; i++) {\n        var current = diff[i],\n            lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n        current.lines = lines;\n\n        if (current.added || current.removed) {\n          if (!oldRangeStart) {\n            var prev = diff[i-1];\n            oldRangeStart = oldLine;\n            newRangeStart = newLine;\n\n            if (prev) {\n              curRange = contextLines(prev.lines.slice(-4));\n              oldRangeStart -= curRange.length;\n              newRangeStart -= curRange.length;\n            }\n          }\n          curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?'+':'-') + entry; }));\n          eofNL(curRange, i, current);\n\n          if (current.added) {\n            newLine += lines.length;\n          } else {\n            oldLine += lines.length;\n          }\n        } else {\n          if (oldRangeStart) {\n            // Close out any changes that have been output (or join overlapping)\n            if (lines.length <= 8 && i < diff.length-2) {\n              // Overlapping\n              curRange.push.apply(curRange, contextLines(lines));\n            } else {\n              // end the range and output\n              var contextSize = Math.min(lines.length, 4);\n              ret.push(\n                  '@@ -' + oldRangeStart + ',' + (oldLine-oldRangeStart+contextSize)\n                  + ' +' + newRangeStart + ',' + (newLine-newRangeStart+contextSize)\n                  + ' @@');\n              ret.push.apply(ret, curRange);\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\n              if (lines.length <= 4) {\n                eofNL(ret, i, current);\n              }\n\n              oldRangeStart = 0;  newRangeStart = 0; curRange = [];\n            }\n          }\n          oldLine += lines.length;\n          newLine += lines.length;\n        }\n      }\n\n      return ret.join('\\n') + '\\n';\n    },\n\n    applyPatch: function(oldStr, uniDiff) {\n      var diffstr = uniDiff.split('\\n');\n      var diff = [];\n      var remEOFNL = false,\n          addEOFNL = false;\n\n      for (var i = (diffstr[0][0]==='I'?4:0); i < diffstr.length; i++) {\n        if(diffstr[i][0] === '@') {\n          var meh = diffstr[i].split(/@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@/);\n          diff.unshift({\n            start:meh[3],\n            oldlength:meh[2],\n            oldlines:[],\n            newlength:meh[4],\n            newlines:[]\n          });\n        } else if(diffstr[i][0] === '+') {\n          diff[0].newlines.push(diffstr[i].substr(1));\n        } else if(diffstr[i][0] === '-') {\n          diff[0].oldlines.push(diffstr[i].substr(1));\n        } else if(diffstr[i][0] === ' ') {\n          diff[0].newlines.push(diffstr[i].substr(1));\n          diff[0].oldlines.push(diffstr[i].substr(1));\n        } else if(diffstr[i][0] === '\\\\') {\n          if (diffstr[i-1][0] === '+') {\n            remEOFNL = true;\n          } else if(diffstr[i-1][0] === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n\n      var str = oldStr.split('\\n');\n      for (var i = diff.length - 1; i >= 0; i--) {\n        var d = diff[i];\n        for (var j = 0; j < d.oldlength; j++) {\n          if(str[d.start-1+j] !== d.oldlines[j]) {\n            return false;\n          }\n        }\n        Array.prototype.splice.apply(str,[d.start-1,+d.oldlength].concat(d.newlines));\n      }\n\n      if (remEOFNL) {\n        while (!str[str.length-1]) {\n          str.pop();\n        }\n      } else if (addEOFNL) {\n        str.push('');\n      }\n      return str.join('\\n');\n    },\n\n    convertChangesToXML: function(changes){\n      var ret = [];\n      for ( var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        if (change.added) {\n          ret.push('<ins>');\n        } else if (change.removed) {\n          ret.push('<del>');\n        }\n\n        ret.push(escapeHTML(change.value));\n\n        if (change.added) {\n          ret.push('</ins>');\n        } else if (change.removed) {\n          ret.push('</del>');\n        }\n      }\n      return ret.join('');\n    },\n\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n    convertChangesToDMP: function(changes){\n      var ret = [], change;\n      for ( var i = 0; i < changes.length; i++) {\n        change = changes[i];\n        ret.push([(change.added ? 1 : change.removed ? -1 : 0), change.value]);\n      }\n      return ret;\n    }\n  };\n})();\n\nif (typeof module !== 'undefined') {\n    module.exports = JsDiff;\n}\n\n}); // module: browser/diff.js\n\nrequire.register(\"browser/escape-string-regexp.js\", function(module, exports, require){\n'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  return str.replace(matchOperatorsRe,  '\\\\$&');\n};\n\n}); // module: browser/escape-string-regexp.js\n\nrequire.register(\"browser/events.js\", function(module, exports, require){\n/**\n * Module exports.\n */\n\nexports.EventEmitter = EventEmitter;\n\n/**\n * Check if `obj` is an array.\n */\n\nfunction isArray(obj) {\n  return '[object Array]' == {}.toString.call(obj);\n}\n\n/**\n * Event emitter constructor.\n *\n * @api public\n */\n\nfunction EventEmitter(){};\n\n/**\n * Adds a listener.\n *\n * @api public\n */\n\nEventEmitter.prototype.on = function (name, fn) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = fn;\n  } else if (isArray(this.$events[name])) {\n    this.$events[name].push(fn);\n  } else {\n    this.$events[name] = [this.$events[name], fn];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n/**\n * Adds a volatile listener.\n *\n * @api public\n */\n\nEventEmitter.prototype.once = function (name, fn) {\n  var self = this;\n\n  function on () {\n    self.removeListener(name, on);\n    fn.apply(this, arguments);\n  };\n\n  on.listener = fn;\n  this.on(name, on);\n\n  return this;\n};\n\n/**\n * Removes a listener.\n *\n * @api public\n */\n\nEventEmitter.prototype.removeListener = function (name, fn) {\n  if (this.$events && this.$events[name]) {\n    var list = this.$events[name];\n\n    if (isArray(list)) {\n      var pos = -1;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n          pos = i;\n          break;\n        }\n      }\n\n      if (pos < 0) {\n        return this;\n      }\n\n      list.splice(pos, 1);\n\n      if (!list.length) {\n        delete this.$events[name];\n      }\n    } else if (list === fn || (list.listener && list.listener === fn)) {\n      delete this.$events[name];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Removes all listeners for an event.\n *\n * @api public\n */\n\nEventEmitter.prototype.removeAllListeners = function (name) {\n  if (name === undefined) {\n    this.$events = {};\n    return this;\n  }\n\n  if (this.$events && this.$events[name]) {\n    this.$events[name] = null;\n  }\n\n  return this;\n};\n\n/**\n * Gets all listeners for a certain event.\n *\n * @api public\n */\n\nEventEmitter.prototype.listeners = function (name) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = [];\n  }\n\n  if (!isArray(this.$events[name])) {\n    this.$events[name] = [this.$events[name]];\n  }\n\n  return this.$events[name];\n};\n\n/**\n * Emits an event.\n *\n * @api public\n */\n\nEventEmitter.prototype.emit = function (name) {\n  if (!this.$events) {\n    return false;\n  }\n\n  var handler = this.$events[name];\n\n  if (!handler) {\n    return false;\n  }\n\n  var args = [].slice.call(arguments, 1);\n\n  if ('function' == typeof handler) {\n    handler.apply(this, args);\n  } else if (isArray(handler)) {\n    var listeners = handler.slice();\n\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n};\n\n}); // module: browser/events.js\n\nrequire.register(\"browser/fs.js\", function(module, exports, require){\n\n}); // module: browser/fs.js\n\nrequire.register(\"browser/glob.js\", function(module, exports, require){\n\n}); // module: browser/glob.js\n\nrequire.register(\"browser/path.js\", function(module, exports, require){\n\n}); // module: browser/path.js\n\nrequire.register(\"browser/progress.js\", function(module, exports, require){\n/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\n\nfunction Progress() {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `n`.\n *\n * @param {Number} n\n * @return {Progress} for chaining\n * @api public\n */\n\nProgress.prototype.size = function(n){\n  this._size = n;\n  return this;\n};\n\n/**\n * Set text to `str`.\n *\n * @param {String} str\n * @return {Progress} for chaining\n * @api public\n */\n\nProgress.prototype.text = function(str){\n  this._text = str;\n  return this;\n};\n\n/**\n * Set font size to `n`.\n *\n * @param {Number} n\n * @return {Progress} for chaining\n * @api public\n */\n\nProgress.prototype.fontSize = function(n){\n  this._fontSize = n;\n  return this;\n};\n\n/**\n * Set font `family`.\n *\n * @param {String} family\n * @return {Progress} for chaining\n */\n\nProgress.prototype.font = function(family){\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {Number} n\n * @return {Progress} for chaining\n */\n\nProgress.prototype.update = function(n){\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} for chaining\n */\n\nProgress.prototype.draw = function(ctx){\n  try {\n    var percent = Math.min(this.percent, 100)\n      , size = this._size\n      , half = size / 2\n      , x = half\n      , y = half\n      , rad = half - 1\n      , fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%'\n      , w = ctx.measureText(text).width;\n\n    ctx.fillText(\n        text\n      , x - w / 2 + 1\n      , y + fontSize / 2 - 1);\n  } catch (ex) {} //don't fail if we can't render progress\n  return this;\n};\n\n}); // module: browser/progress.js\n\nrequire.register(\"browser/tty.js\", function(module, exports, require){\nexports.isatty = function(){\n  return true;\n};\n\nexports.getWindowSize = function(){\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  } else {\n    // In a Web Worker, the DOM Window is not available.\n    return [640, 480];\n  }\n};\n\n}); // module: browser/tty.js\n\nrequire.register(\"context.js\", function(module, exports, require){\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\n\nfunction Context(){}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @param {Runnable} runnable\n * @return {Context}\n * @api private\n */\n\nContext.prototype.runnable = function(runnable){\n  if (0 == arguments.length) return this._runnable;\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set test timeout `ms`.\n *\n * @param {Number} ms\n * @return {Context} self\n * @api private\n */\n\nContext.prototype.timeout = function(ms){\n  if (arguments.length === 0) return this.runnable().timeout();\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @param {Boolean} enabled\n * @return {Context} self\n * @api private\n */\n\nContext.prototype.enableTimeouts = function (enabled) {\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n\n/**\n * Set test slowness threshold `ms`.\n *\n * @param {Number} ms\n * @return {Context} self\n * @api private\n */\n\nContext.prototype.slow = function(ms){\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @return {Context} self\n * @api private\n */\n\nContext.prototype.skip = function(){\n    this.runnable().skip();\n    return this;\n};\n\n/**\n * Inspect the context void of `._runnable`.\n *\n * @return {String}\n * @api private\n */\n\nContext.prototype.inspect = function(){\n  return JSON.stringify(this, function(key, val){\n    if ('_runnable' == key) return;\n    if ('test' == key) return;\n    return val;\n  }, 2);\n};\n\n}); // module: context.js\n\nrequire.register(\"hook.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\n\nfunction Hook(title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\n\nfunction F(){};\nF.prototype = Runnable.prototype;\nHook.prototype = new F;\nHook.prototype.constructor = Hook;\n\n\n/**\n * Get or set the test `err`.\n *\n * @param {Error} err\n * @return {Error}\n * @api public\n */\n\nHook.prototype.error = function(err){\n  if (0 == arguments.length) {\n    var err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n}); // module: hook.js\n\nrequire.register(\"interfaces/bdd.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite')\n  , Test = require('../test')\n  , utils = require('../utils')\n  , escapeRe = require('browser/escape-string-regexp');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function(){\n *        describe('#indexOf()', function(){\n *          it('should return -1 when not present', function(){\n *\n *          });\n *\n *          it('should return the index when present', function(){\n *\n *          });\n *        });\n *      });\n *\n */\n\nmodule.exports = function(suite){\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha){\n\n    var common = require('./common')(suites, context);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function(title, fn){\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n      return suite;\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe =\n    context.xcontext =\n    context.describe.skip = function(title, fn){\n      var suite = Suite.create(suites[0], title);\n      suite.pending = true;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function(title, fn){\n      var suite = context.describe(title, fn);\n      mocha.grep(suite.fullTitle());\n      return suite;\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.it = context.specify = function(title, fn){\n      var suite = suites[0];\n      if (suite.pending) fn = null;\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function(title, fn){\n      var test = context.it(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n      return test;\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit =\n    context.xspecify =\n    context.it.skip = function(title){\n      context.it(title);\n    };\n\n  });\n};\n\n}); // module: interfaces/bdd.js\n\nrequire.register(\"interfaces/common.js\", function(module, exports, require){\n/**\n * Functions common to more than one interface\n * @module lib/interfaces/common\n */\n\n'use strict';\n\nmodule.exports = function (suites, context) {\n\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha.  It triggers\n     * root suite execution.  Returns a function which runs the root suite.\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    test: {\n      /**\n       * Pending test case.\n       */\n      skip: function (title) {\n        context.test(title);\n      }\n    }\n  }\n};\n\n}); // module: interfaces/common.js\n\nrequire.register(\"interfaces/exports.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite')\n  , Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function(){\n *\n *         },\n *\n *         'should return the correct index when the value is present': function(){\n *\n *         }\n *       }\n *     };\n *\n */\n\nmodule.exports = function(suite){\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit(obj, file) {\n    var suite;\n    for (var key in obj) {\n      if ('function' == typeof obj[key]) {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key]);\n        suites.shift();\n      }\n    }\n  }\n};\n\n}); // module: interfaces/exports.js\n\nrequire.register(\"interfaces/index.js\", function(module, exports, require){\nexports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n\n}); // module: interfaces/index.js\n\nrequire.register(\"interfaces/qunit.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite')\n  , Test = require('../test')\n  , escapeRe = require('browser/escape-string-regexp')\n  , utils = require('../utils');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function(){\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function(){\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function(){\n *       ok('foo'.length == 3);\n *     });\n *\n */\n\nmodule.exports = function(suite){\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha){\n\n    var common = require('./common')(suites, context);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function(title){\n      if (suites.length > 1) suites.shift();\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      return suite;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.suite.only = function(title, fn){\n      var suite = context.suite(title, fn);\n      mocha.grep(suite.fullTitle());\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function(title, fn){\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn){\n      var test = context.test(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n    };\n\n    context.test.skip = common.test.skip;\n\n  });\n};\n\n}); // module: interfaces/qunit.js\n\nrequire.register(\"interfaces/tdd.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite')\n  , Test = require('../test')\n  , escapeRe = require('browser/escape-string-regexp')\n  , utils = require('../utils');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function(){\n *        suite('#indexOf()', function(){\n *          suiteSetup(function(){\n *\n *          });\n *\n *          test('should return -1 when not present', function(){\n *\n *          });\n *\n *          test('should return the index when present', function(){\n *\n *          });\n *\n *          suiteTeardown(function(){\n *\n *          });\n *        });\n *      });\n *\n */\n\nmodule.exports = function(suite){\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha){\n\n    var common = require('./common')(suites, context);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.suite = function(title, fn){\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n      return suite;\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.pending = true;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.suite.only = function(title, fn){\n      var suite = context.suite(title, fn);\n      mocha.grep(suite.fullTitle());\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function(title, fn){\n      var suite = suites[0];\n      if (suite.pending) fn = null;\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn){\n      var test = context.test(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n    };\n\n    context.test.skip = common.test.skip;\n  });\n};\n\n}); // module: interfaces/tdd.js\n\nrequire.register(\"mocha.js\", function(module, exports, require){\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar path = require('browser/path')\n  , escapeRe = require('browser/escape-string-regexp')\n  , utils = require('./utils');\n\n/**\n * Expose `Mocha`.\n */\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (typeof process !== 'undefined' && typeof process.cwd === 'function') {\n  var join = path.join\n    , cwd = process.cwd();\n  module.paths.push(cwd, join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\nexports.reporters = require('./reporters');\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @param {String} name\n * @return {String}\n * @api private\n */\n\nfunction image(name) {\n  return __dirname + '/../images/' + name + '.png';\n}\n\n/**\n * Setup mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Mocha(options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) this.grep(new RegExp(options.grep));\n  if (options.fgrep) this.grep(options.fgrep);\n  this.suite = new exports.Suite('', new exports.Context);\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (null != options.timeout) this.timeout(options.timeout);\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) this.enableTimeouts(options.enableTimeouts);\n  if (options.slow) this.slow(options.slow);\n\n  this.suite.on('pre-require', function (context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @param {Boolean} [bail]\n * @api public\n */\n\nMocha.prototype.bail = function(bail){\n  if (0 == arguments.length) bail = true;\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @param {String} file\n * @api public\n */\n\nMocha.prototype.addFile = function(file){\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n */\nMocha.prototype.reporter = function(reporter, reporterOptions){\n  if ('function' == typeof reporter) {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    try { _reporter = require('./reporters/' + reporter); } catch (err) {}\n    if (!_reporter) try { _reporter = require(reporter); } catch (err) {\n      err.message.indexOf('Cannot find module') !== -1\n        ? console.warn('\"' + reporter + '\" reporter not found')\n        : console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n    }\n    if (!_reporter && reporter === 'teamcity')\n      console.warn('The Teamcity reporter was moved to a package named ' +\n        'mocha-teamcity-reporter ' +\n        '(https://npmjs.org/package/mocha-teamcity-reporter).');\n    if (!_reporter) throw new Error('invalid reporter \"' + reporter + '\"');\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n *\n * @param {String} bdd\n * @api public\n */\n\nMocha.prototype.ui = function(name){\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) try { this._ui = require(name); } catch (err) {}\n  if (!this._ui) throw new Error('invalid interface \"' + name + '\"');\n  this._ui = this._ui(this.suite);\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\n\nMocha.prototype.loadFiles = function(fn){\n  var self = this;\n  var suite = this.suite;\n  var pending = this.files.length;\n  this.files.forEach(function(file){\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n    --pending || (fn && fn());\n  });\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\n\nMocha.prototype._growl = function(runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function(){\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n          name: 'mocha'\n        , title: 'Passed'\n        , image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.grep = function(re){\n  this.options.grep = 'string' == typeof re\n    ? new RegExp(escapeRe(re))\n    : re;\n  return this;\n};\n\n/**\n * Invert `.grep()` matches.\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.invert = function(){\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.ignoreLeaks = function(ignore){\n  this.options.ignoreLeaks = !!ignore;\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.checkLeaks = function(){\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.fullTrace = function() {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.growl = function(){\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.globals = function(globals){\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.useColors = function(colors){\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.useInlineDiffs = function(inlineDiffs) {\n  this.options.useInlineDiffs = arguments.length && inlineDiffs != undefined\n  ? inlineDiffs\n  : false;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.timeout = function(timeout){\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.slow = function(slow){\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.enableTimeouts = function(enabled) {\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined\n    ? enabled\n    : true);\n  return this\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n */\n\nMocha.prototype.asyncOnly = function(){\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n * @returns {Mocha}\n * @api public\n */\nMocha.prototype.noHighlighting = function() {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n * @api public\n */\nMocha.prototype.delay = function delay() {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * @param {Function} fn\n * @return {Runner}\n * @api public\n */\nMocha.prototype.run = function(fn){\n  if (this.files.length) this.loadFiles();\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = false !== options.ignoreLeaks;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.asyncOnly = options.asyncOnly;\n  if (options.grep) runner.grep(options.grep, options.invert);\n  if (options.globals) runner.globals(options.globals);\n  if (options.growl) this._growl(runner, reporter);\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n\n  function done(failures) {\n      if (reporter.done) {\n          reporter.done(failures, fn);\n      } else fn && fn(failures);\n  }\n\n  return runner.run(done);\n};\n\n}); // module: mocha.js\n\nrequire.register(\"ms.js\", function(module, exports, require){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options['long'] ? longFormat(val) : shortFormat(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction shortFormat(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction longFormat(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n}); // module: ms.js\n\nrequire.register(\"pending.js\", function(module, exports, require){\n\n/**\n * Expose `Pending`.\n */\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {String} message\n */\n\nfunction Pending(message) {\n    this.message = message;\n}\n\n}); // module: pending.js\n\nrequire.register(\"reporters/base.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar tty = require('browser/tty')\n  , diff = require('browser/diff')\n  , ms = require('../ms')\n  , utils = require('../utils')\n  , supportsColor = process.env ? require('supports-color') : null;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date\n  , setTimeout = global.setTimeout\n  , setInterval = global.setInterval\n  , clearTimeout = global.clearTimeout\n  , clearInterval = global.clearInterval;\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors = process.env\n  ? (supportsColor || (process.env.MOCHA_COLORS !== undefined))\n  : false;\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n    'pass': 90\n  , 'fail': 31\n  , 'bright pass': 92\n  , 'bright fail': 91\n  , 'bright yellow': 93\n  , 'pending': 36\n  , 'suite': 0\n  , 'error title': 0\n  , 'error message': 31\n  , 'error stack': 90\n  , 'checkmark': 32\n  , 'fast': 90\n  , 'medium': 33\n  , 'slow': 31\n  , 'green': 32\n  , 'light': 90\n  , 'diff gutter': 90\n  , 'diff added': 42\n  , 'diff removed': 41\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '✓',\n  err: '✖',\n  dot: '․'\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif ('win32' == process.platform) {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {String} type\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nvar color = exports.color = function(type, str) {\n  if (!exports.useColors) return String(str);\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Expose term window size, with some\n * defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: isatty\n    ? process.stdout.getWindowSize\n      ? process.stdout.getWindowSize(1)[0]\n      : tty.getWindowSize()[1]\n    : 75\n};\n\n/**\n * Expose some basic cursor interactions\n * that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function(){\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function(){\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function(){\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function(){\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function(){\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\n/**\n * Outut the given `failures` as a list.\n *\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function(failures){\n  console.log();\n  failures.forEach(function(test, i){\n    // format\n    var fmt = color('error title', '  %s) %s:\\n')\n      + color('error message', '     %s')\n      + color('error stack', '\\n%s\\n');\n\n    // msg\n    var err = test.err\n      , message = err.message || ''\n      , stack = err.stack || message\n      , index = stack.indexOf(message)\n      , actual = err.actual\n      , expected = err.expected\n      , escape = true;\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (err.showDiff !== false && sameType(actual, expected)\n        && expected !== undefined) {\n\n      if ('string' !== typeof actual) {\n        escape = false;\n        err.actual = actual = utils.stringify(actual);\n        err.expected = expected = utils.stringify(expected);\n      }\n\n      fmt = color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      if (exports.inlineDiffs) {\n        msg += inlineDiff(err, escape);\n      } else {\n        msg += unifiedDiff(err, escape);\n      }\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base(runner) {\n  var self = this\n    , stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 }\n    , failures = this.failures = [];\n\n  if (!runner) return;\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function(){\n    stats.start = new Date;\n  });\n\n  runner.on('suite', function(suite){\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function(test){\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function(test){\n    stats.passes = stats.passes || 0;\n\n    var medium = test.slow() / 2;\n    test.speed = test.duration > test.slow()\n      ? 'slow'\n      : test.duration > medium\n        ? 'medium'\n        : 'fast';\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function(test, err){\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.on('end', function(){\n    stats.end = new Date;\n    stats.duration = new Date - stats.start;\n  });\n\n  runner.on('pending', function(){\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @api public\n */\n\nBase.prototype.epilogue = function(){\n  var stats = this.stats;\n  var tests;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt = color('bright pass', ' ')\n    + color('green', ' %d passing')\n    + color('light', ' (%s)');\n\n  console.log(fmt,\n    stats.passes || 0,\n    ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ')\n      + color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @param {String} str\n * @param {String} len\n * @return {String}\n * @api private\n */\n\nfunction pad(str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output\n *\n * @param {Error} Error with actual/expected\n * @return {String} Diff\n * @api private\n */\n\nfunction inlineDiff(err, escape) {\n  var msg = errorDiff(err, 'WordsWithSpace', escape);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines.map(function(str, i){\n      return pad(++i, width) + ' |' + ' ' + str;\n    }).join('\\n');\n  }\n\n  // legend\n  msg = '\\n'\n    + color('diff removed', 'actual')\n    + ' '\n    + color('diff added', 'expected')\n    + '\\n\\n'\n    + msg\n    + '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between 2 strings\n *\n * @param {Error} Error with actual/expected\n * @return {String} Diff\n * @api private\n */\n\nfunction unifiedDiff(err, escape) {\n  var indent = '      ';\n  function cleanUp(line) {\n    if (escape) {\n      line = escapeInvisibles(line);\n    }\n    if (line[0] === '+') return indent + colorLines('diff added', line);\n    if (line[0] === '-') return indent + colorLines('diff removed', line);\n    if (line.match(/\\@\\@/)) return null;\n    if (line.match(/\\\\ No newline/)) return null;\n    else return indent + line;\n  }\n  function notBlank(line) {\n    return line != null;\n  }\n  var msg = diff.createPatch('string', err.actual, err.expected);\n  var lines = msg.split('\\n').splice(4);\n  return '\\n      '\n         + colorLines('diff added',   '+ expected') + ' '\n         + colorLines('diff removed', '- actual')\n         + '\\n\\n'\n         + lines.map(cleanUp).filter(notBlank).join('\\n');\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @param {Error} err\n * @return {String}\n * @api private\n */\n\nfunction errorDiff(err, type, escape) {\n  var actual   = escape ? escapeInvisibles(err.actual)   : err.actual;\n  var expected = escape ? escapeInvisibles(err.expected) : err.expected;\n  return diff['diff' + type](actual, expected).map(function(str){\n    if (str.added) return colorLines('diff added', str.value);\n    if (str.removed) return colorLines('diff removed', str.value);\n    return str.value;\n  }).join('');\n}\n\n/**\n * Returns a string with all invisible characters in plain text\n *\n * @param {String} line\n * @return {String}\n * @api private\n */\nfunction escapeInvisibles(line) {\n    return line.replace(/\\t/g, '<tab>')\n               .replace(/\\r/g, '<CR>')\n               .replace(/\\n/g, '<LF>\\n');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @param {String} name\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction colorLines(name, str) {\n  return str.split('\\n').map(function(str){\n    return color(name, str);\n  }).join('\\n');\n}\n\n/**\n * Check that a / b have the same type.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Boolean}\n * @api private\n */\n\nfunction sameType(a, b) {\n  a = Object.prototype.toString.call(a);\n  b = Object.prototype.toString.call(b);\n  return a == b;\n}\n\n}); // module: reporters/base.js\n\nrequire.register(\"reporters/doc.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Doc(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , total = runner.total\n    , indents = 2;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function(suite){\n    if (suite.root) return;\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function(suite){\n    if (suite.root) return;\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function(test){\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.fn.toString()));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function(test, err){\n    console.log('%s  <dt class=\"error\">%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.fn.toString()));\n    console.log('%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>', indent(), code);\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n\n}); // module: reporters/doc.js\n\nrequire.register(\"reporters/dot.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Dot(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , width = Base.window.width * .75 | 0\n    , n = -1;\n\n  runner.on('start', function(){\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function(test){\n    if (++n % width == 0) process.stdout.write('\\n  ');\n    process.stdout.write(color('pending', Base.symbols.dot));\n  });\n\n  runner.on('pass', function(test){\n    if (++n % width == 0) process.stdout.write('\\n  ');\n    if ('slow' == test.speed) {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function(test, err){\n    if (++n % width == 0) process.stdout.write('\\n  ');\n    process.stdout.write(color('fail', Base.symbols.dot));\n  });\n\n  runner.on('end', function(){\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nfunction F(){};\nF.prototype = Base.prototype;\nDot.prototype = new F;\nDot.prototype.constructor = Dot;\n\n\n}); // module: reporters/dot.js\n\nrequire.register(\"reporters/html-cov.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar JSONCov = require('./json-cov')\n  , fs = require('browser/fs');\n\n/**\n * Expose `HTMLCov`.\n */\n\nexports = module.exports = HTMLCov;\n\n/**\n * Initialize a new `JsCoverage` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction HTMLCov(runner) {\n  var jade = require('jade')\n    , file = __dirname + '/templates/coverage.jade'\n    , str = fs.readFileSync(file, 'utf8')\n    , fn = jade.compile(str, { filename: file })\n    , self = this;\n\n  JSONCov.call(this, runner, false);\n\n  runner.on('end', function(){\n    process.stdout.write(fn({\n        cov: self.cov\n      , coverageClass: coverageClass\n    }));\n  });\n}\n\n/**\n * Return coverage class for `n`.\n *\n * @return {String}\n * @api private\n */\n\nfunction coverageClass(n) {\n  if (n >= 75) return 'high';\n  if (n >= 50) return 'medium';\n  if (n >= 25) return 'low';\n  return 'terrible';\n}\n\n}); // module: reporters/html-cov.js\n\nrequire.register(\"reporters/html.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , utils = require('../utils')\n  , Progress = require('../browser/progress')\n  , escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date\n  , setTimeout = global.setTimeout\n  , setInterval = global.setInterval\n  , clearTimeout = global.clearTimeout\n  , clearInterval = global.clearInterval;\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate = '<ul id=\"mocha-stats\">'\n  + '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>'\n  + '<li class=\"passes\"><a href=\"#\">passes:</a> <em>0</em></li>'\n  + '<li class=\"failures\"><a href=\"#\">failures:</a> <em>0</em></li>'\n  + '<li class=\"duration\">duration: <em>0</em>s</li>'\n  + '</ul>';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction HTML(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , total = runner.total\n    , stat = fragment(statsTemplate)\n    , items = stat.getElementsByTagName('li')\n    , passes = items[1].getElementsByTagName('em')[0]\n    , passesLink = items[1].getElementsByTagName('a')[0]\n    , failures = items[2].getElementsByTagName('em')[0]\n    , failuresLink = items[2].getElementsByTagName('a')[0]\n    , duration = items[3].getElementsByTagName('em')[0]\n    , canvas = stat.getElementsByTagName('canvas')[0]\n    , report = fragment('<ul id=\"mocha-report\"></ul>')\n    , stack = [report]\n    , progress\n    , ctx\n    , root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress;\n  }\n\n  if (!root) return error('#mocha div missing, add it to your document');\n\n  // pass toggle\n  on(passesLink, 'click', function(){\n    unhide();\n    var name = /pass/.test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) hideSuitesWithout('test pass');\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function(){\n    unhide();\n    var name = /fail/.test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) hideSuitesWithout('test fail');\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) progress.size(40);\n\n  runner.on('suite', function(suite){\n    if (suite.root) return;\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function(suite){\n    if (suite.root) return;\n    stack.shift();\n  });\n\n  runner.on('fail', function(test, err){\n    if ('hook' == test.type) runner.emit('test end', test);\n  });\n\n  runner.on('test end', function(test){\n    // TODO: add to stats\n    var percent = stats.tests / this.total * 100 | 0;\n    if (progress) progress.update(percent).draw(ctx);\n\n    // update stats\n    var ms = new Date - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n\n    // test\n    if ('passed' == test.state) {\n      var url = self.testURL(test);\n      var el = fragment('<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> <a href=\"%s\" class=\"replay\">‣</a></h2></li>', test.speed, test.title, test.duration, url);\n    } else if (test.pending) {\n      var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\n    } else {\n      var el = fragment('<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">‣</a></h2></li>', test.title, self.testURL(test));\n      var str = test.err.stack || test.err.toString();\n\n      // FF / Opera do not add the message\n      if (!~str.indexOf(test.err.message)) {\n        str = test.err.message + '\\n' + str;\n      }\n\n      // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n      // check for the result of the stringifying.\n      if ('[object Error]' == str) str = test.err.message;\n\n      // Safari doesn't give you a stack. Let's at least provide a source line.\n      if (!test.err.stack && test.err.sourceURL && test.err.line !== undefined) {\n        str += \"\\n(\" + test.err.sourceURL + \":\" + test.err.line + \")\";\n      }\n\n      el.appendChild(fragment('<pre class=\"error\">%e</pre>', str));\n    }\n\n    // toggle code\n    // TODO: defer\n    if (!test.pending) {\n      var h2 = el.getElementsByTagName('h2')[0];\n\n      on(h2, 'click', function(){\n        pre.style.display = 'none' == pre.style.display\n          ? 'block'\n          : 'none';\n      });\n\n      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.fn.toString()));\n      el.appendChild(pre);\n      pre.style.display = 'none';\n    }\n\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) stack[0].appendChild(el);\n  });\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n * @param {string} s\n * @returns {string} your new URL\n */\nvar makeUrl = function makeUrl(s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return window.location.pathname + (search ? search + '&' : '?' ) + 'grep=' + encodeURIComponent(s);\n};\n\n/**\n * Provide suite URL\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function(suite){\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL\n *\n * @param {Object} [test]\n */\n\nHTML.prototype.testURL = function(test){\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Display error `msg`.\n */\n\nfunction error(msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n */\n\nfunction fragment(html) {\n  var args = arguments\n    , div = document.createElement('div')\n    , i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function(_, type){\n    switch (type) {\n      case 's': return String(args[i++]);\n      case 'e': return escape(args[i++]);\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n */\n\nfunction hideSuitesWithout(classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (0 == els.length) suites[i].className += ' hidden';\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\n\nfunction unhide() {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set `el` text to `str`.\n */\n\nfunction text(el, str) {\n  if (el.textContent) {\n    el.textContent = str;\n  } else {\n    el.innerText = str;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\n\nfunction on(el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\n}); // module: reporters/html.js\n\nrequire.register(\"reporters/index.js\", function(module, exports, require){\nexports.Base = require('./base');\nexports.Dot = require('./dot');\nexports.Doc = require('./doc');\nexports.TAP = require('./tap');\nexports.JSON = require('./json');\nexports.HTML = require('./html');\nexports.List = require('./list');\nexports.Min = require('./min');\nexports.Spec = require('./spec');\nexports.Nyan = require('./nyan');\nexports.XUnit = require('./xunit');\nexports.Markdown = require('./markdown');\nexports.Progress = require('./progress');\nexports.Landing = require('./landing');\nexports.JSONCov = require('./json-cov');\nexports.HTMLCov = require('./html-cov');\nexports.JSONStream = require('./json-stream');\n\n}); // module: reporters/index.js\n\nrequire.register(\"reporters/json-cov.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSONCov`.\n */\n\nexports = module.exports = JSONCov;\n\n/**\n * Initialize a new `JsCoverage` reporter.\n *\n * @param {Runner} runner\n * @param {Boolean} output\n * @api public\n */\n\nfunction JSONCov(runner, output) {\n  var self = this\n    , output = 1 == arguments.length ? true : output;\n\n  Base.call(this, runner);\n\n  var tests = []\n    , failures = []\n    , passes = [];\n\n  runner.on('test end', function(test){\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test){\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test){\n    failures.push(test);\n  });\n\n  runner.on('end', function(){\n    var cov = global._$jscoverage || {};\n    var result = self.cov = map(cov);\n    result.stats = self.stats;\n    result.tests = tests.map(clean);\n    result.failures = failures.map(clean);\n    result.passes = passes.map(clean);\n    if (!output) return;\n    process.stdout.write(JSON.stringify(result, null, 2 ));\n  });\n}\n\n/**\n * Map jscoverage data to a JSON structure\n * suitable for reporting.\n *\n * @param {Object} cov\n * @return {Object}\n * @api private\n */\n\nfunction map(cov) {\n  var ret = {\n      instrumentation: 'node-jscoverage'\n    , sloc: 0\n    , hits: 0\n    , misses: 0\n    , coverage: 0\n    , files: []\n  };\n\n  for (var filename in cov) {\n    var data = coverage(filename, cov[filename]);\n    ret.files.push(data);\n    ret.hits += data.hits;\n    ret.misses += data.misses;\n    ret.sloc += data.sloc;\n  }\n\n  ret.files.sort(function(a, b) {\n    return a.filename.localeCompare(b.filename);\n  });\n\n  if (ret.sloc > 0) {\n    ret.coverage = (ret.hits / ret.sloc) * 100;\n  }\n\n  return ret;\n}\n\n/**\n * Map jscoverage data for a single source file\n * to a JSON structure suitable for reporting.\n *\n * @param {String} filename name of the source file\n * @param {Object} data jscoverage coverage data\n * @return {Object}\n * @api private\n */\n\nfunction coverage(filename, data) {\n  var ret = {\n    filename: filename,\n    coverage: 0,\n    hits: 0,\n    misses: 0,\n    sloc: 0,\n    source: {}\n  };\n\n  data.source.forEach(function(line, num){\n    num++;\n\n    if (data[num] === 0) {\n      ret.misses++;\n      ret.sloc++;\n    } else if (data[num] !== undefined) {\n      ret.hits++;\n      ret.sloc++;\n    }\n\n    ret.source[num] = {\n        source: line\n      , coverage: data[num] === undefined\n        ? ''\n        : data[num]\n    };\n  });\n\n  ret.coverage = ret.hits / ret.sloc * 100;\n\n  return ret;\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @param {Object} test\n * @return {Object}\n * @api private\n */\n\nfunction clean(test) {\n  return {\n      title: test.title\n    , fullTitle: test.fullTitle()\n    , duration: test.duration\n  }\n}\n\n}); // module: reporters/json-cov.js\n\nrequire.register(\"reporters/json-stream.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , color = Base.color;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , total = runner.total;\n\n  runner.on('start', function(){\n    console.log(JSON.stringify(['start', { total: total }]));\n  });\n\n  runner.on('pass', function(test){\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function(test, err){\n    test = clean(test);\n    test.err = err.message;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.on('end', function(){\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @param {Object} test\n * @return {Object}\n * @api private\n */\n\nfunction clean(test) {\n  return {\n      title: test.title\n    , fullTitle: test.fullTitle()\n    , duration: test.duration\n  }\n}\n\n}); // module: reporters/json-stream.js\n\nrequire.register(\"reporters/json.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction JSONReporter(runner) {\n  var self = this;\n  Base.call(this, runner);\n\n  var tests = []\n    , pending = []\n    , failures = []\n    , passes = [];\n\n  runner.on('test end', function(test){\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test){\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test){\n    failures.push(test);\n  });\n\n  runner.on('pending', function(test){\n    pending.push(test);\n  });\n\n  runner.on('end', function(){\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @param {Object} test\n * @return {Object}\n * @api private\n */\n\nfunction clean(test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    err: errorJSON(test.err || {})\n  }\n}\n\n/**\n * Transform `error` into a JSON object.\n * @param {Error} err\n * @return {Object}\n */\n\nfunction errorJSON(err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function(key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\n}); // module: reporters/json.js\n\nrequire.register(\"reporters/landing.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Landing(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , width = Base.window.width * .75 | 0\n    , total = runner.total\n    , stream = process.stdout\n    , plane = color('plane', '✈')\n    , crashed = -1\n    , n = 0;\n\n  function runway() {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function(){\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function(test){\n    // check if the plane crashed\n    var col = -1 == crashed\n      ? width * ++n / total | 0\n      : crashed;\n\n    // show the crash\n    if ('failed' == test.state) {\n      plane = color('plane crash', '✈');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b['+(width+1)+'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('⋅')));\n    stream.write(plane)\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.on('end', function(){\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nfunction F(){};\nF.prototype = Base.prototype;\nLanding.prototype = new F;\nLanding.prototype.constructor = Landing;\n\n\n}); // module: reporters/landing.js\n\nrequire.register(\"reporters/list.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , n = 0;\n\n  runner.on('start', function(){\n    console.log();\n  });\n\n  runner.on('test', function(test){\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function(test){\n    var fmt = color('checkmark', '  -')\n      + color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function(test){\n    var fmt = color('checkmark', '  '+Base.symbols.dot)\n      + color('pass', ' %s: ')\n      + color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function(test, err){\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nfunction F(){};\nF.prototype = Base.prototype;\nList.prototype = new F;\nList.prototype.constructor = List;\n\n\n}); // module: reporters/list.js\n\nrequire.register(\"reporters/markdown.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Markdown(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , level = 0\n    , buf = '';\n\n  function title(str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function indent() {\n    return Array(level).join('  ');\n  }\n\n  function mapTOC(suite, obj) {\n    var ret = obj,\n        key = SUITE_PREFIX + suite.title;\n    obj = obj[key] = obj[key] || { suite: suite };\n    suite.suites.forEach(function(suite){\n      mapTOC(suite, obj);\n    });\n    return ret;\n  }\n\n  function stringifyTOC(obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if ('suite' == key) continue;\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC(suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function(suite){\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function(suite){\n    --level;\n  });\n\n  runner.on('pass', function(test){\n    var code = utils.clean(test.fn.toString());\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.on('end', function(){\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\n}); // module: reporters/markdown.js\n\nrequire.register(\"reporters/min.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Min(runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function(){\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.on('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nfunction F(){};\nF.prototype = Base.prototype;\nMin.prototype = new F;\nMin.prototype.constructor = Min;\n\n\n}); // module: reporters/min.js\n\nrequire.register(\"reporters/nyan.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction NyanCat(runner) {\n  Base.call(this, runner);\n  var self = this\n    , stats = this.stats\n    , width = Base.window.width * .75 | 0\n    , rainbowColors = this.rainbowColors = self.generateColors()\n    , colorIndex = this.colorIndex = 0\n    , numerOfLines = this.numberOfLines = 4\n    , trajectories = this.trajectories = [[], [], [], []]\n    , nyanCatWidth = this.nyanCatWidth = 11\n    , trajectoryWidthMax = this.trajectoryWidthMax = (width - nyanCatWidth)\n    , scoreboardWidth = this.scoreboardWidth = 5\n    , tick = this.tick = 0\n    , n = 0;\n\n  runner.on('start', function(){\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function(test){\n    self.draw();\n  });\n\n  runner.on('pass', function(test){\n    self.draw();\n  });\n\n  runner.on('fail', function(test, err){\n    self.draw();\n  });\n\n  runner.on('end', function(){\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) write('\\n');\n    self.epilogue();\n  });\n}\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function(){\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function(){\n  var stats = this.stats;\n\n  function draw(type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function(){\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) trajectory.shift();\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function(){\n  var self = this;\n\n  this.trajectories.forEach(function(line, index) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.drawNyanCat = function() {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  var face;\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @return {String}\n * @api private\n */\n\nNyanCat.prototype.face = function() {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if(stats.passes) {\n    return '( ^ .^)';\n  } else {\n    return '( - .-)';\n  }\n};\n\n/**\n * Move cursor up `n`.\n *\n * @param {Number} n\n * @api private\n */\n\nNyanCat.prototype.cursorUp = function(n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @param {Number} n\n * @api private\n */\n\nNyanCat.prototype.cursorDown = function(n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @return {Array}\n * @api private\n */\n\nNyanCat.prototype.generateColors = function(){\n  var colors = [];\n\n  for (var i = 0; i < (6 * 7); i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = (i * (1.0 / 6));\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nNyanCat.prototype.rainbowify = function(str){\n  if (!Base.useColors)\n    return str;\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n */\n\nfunction write(string) {\n  process.stdout.write(string);\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nfunction F(){};\nF.prototype = Base.prototype;\nNyanCat.prototype = new F;\nNyanCat.prototype.constructor = NyanCat;\n\n\n}); // module: reporters/nyan.js\n\nrequire.register(\"reporters/progress.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @param {Runner} runner\n * @param {Object} options\n * @api public\n */\n\nfunction Progress(runner, options) {\n  Base.call(this, runner);\n\n  var self = this\n    , options = options || {}\n    , stats = this.stats\n    , width = Base.window.width * .50 | 0\n    , total = runner.total\n    , complete = 0\n    , max = Math.max\n    , lastN = -1;\n\n  // default chars\n  options.open = options.open || '[';\n  options.complete = options.complete || '▬';\n  options.incomplete = options.incomplete || Base.symbols.dot;\n  options.close = options.close || ']';\n  options.verbose = false;\n\n  // tests started\n  runner.on('start', function(){\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function(){\n    complete++;\n    var incomplete = total - complete\n      , percent = complete / total\n      , n = width * percent | 0\n      , i = width - n;\n\n    if (lastN === n && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.on('end', function(){\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nfunction F(){};\nF.prototype = Base.prototype;\nProgress.prototype = new F;\nProgress.prototype.constructor = Progress;\n\n\n}); // module: reporters/progress.js\n\nrequire.register(\"reporters/spec.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Spec(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , indents = 0\n    , n = 0;\n\n  function indent() {\n    return Array(indents).join('  ')\n  }\n\n  runner.on('start', function(){\n    console.log();\n  });\n\n  runner.on('suite', function(suite){\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function(suite){\n    --indents;\n    if (1 == indents) console.log();\n  });\n\n  runner.on('pending', function(test){\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function(test){\n    if ('fast' == test.speed) {\n      var fmt = indent()\n        + color('checkmark', '  ' + Base.symbols.ok)\n        + color('pass', ' %s');\n      cursor.CR();\n      console.log(fmt, test.title);\n    } else {\n      var fmt = indent()\n        + color('checkmark', '  ' + Base.symbols.ok)\n        + color('pass', ' %s')\n        + color(test.speed, ' (%dms)');\n      cursor.CR();\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function(test, err){\n    cursor.CR();\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nfunction F(){};\nF.prototype = Base.prototype;\nSpec.prototype = new F;\nSpec.prototype.constructor = Spec;\n\n\n}); // module: reporters/spec.js\n\nrequire.register(\"reporters/tap.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , cursor = Base.cursor\n  , color = Base.color;\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction TAP(runner) {\n  Base.call(this, runner);\n\n  var self = this\n    , stats = this.stats\n    , n = 1\n    , passes = 0\n    , failures = 0;\n\n  runner.on('start', function(){\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function(){\n    ++n;\n  });\n\n  runner.on('pending', function(test){\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function(test){\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function(test, err){\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) console.log(err.stack.replace(/^/gm, '  '));\n  });\n\n  runner.on('end', function(){\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @param {Object} test\n * @return {String}\n * @api private\n */\n\nfunction title(test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n}); // module: reporters/tap.js\n\nrequire.register(\"reporters/xunit.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base')\n  , utils = require('../utils')\n  , fs = require('browser/fs')\n  , escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date\n  , setTimeout = global.setTimeout\n  , setInterval = global.setInterval\n  , clearTimeout = global.clearTimeout\n  , clearInterval = global.clearInterval;\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction XUnit(runner, options) {\n  Base.call(this, runner);\n  var stats = this.stats\n    , tests = []\n    , self = this;\n\n  if (options.reporterOptions && options.reporterOptions.output) {\n      if (! fs.createWriteStream) {\n          throw new Error('file output not supported in browser');\n      }\n      self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n  }\n\n  runner.on('pending', function(test){\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test){\n    tests.push(test);\n  });\n\n  runner.on('fail', function(test){\n    tests.push(test);\n  });\n\n  runner.on('end', function(){\n    self.write(tag('testsuite', {\n        name: 'Mocha Tests'\n      , tests: stats.tests\n      , failures: stats.failures\n      , errors: stats.failures\n      , skipped: stats.tests - stats.failures - stats.passes\n      , timestamp: (new Date).toUTCString()\n      , time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(function(t) { self.test(t); });\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Override done to close the stream (if it's a file).\n */\nXUnit.prototype.done = function(failures, fn) {\n    if (this.fileStream) {\n        this.fileStream.end(function() {\n            fn(failures);\n        });\n    } else {\n        fn(failures);\n    }\n};\n\n/**\n * Inherit from `Base.prototype`.\n */\n\nfunction F(){};\nF.prototype = Base.prototype;\nXUnit.prototype = new F;\nXUnit.prototype.constructor = XUnit;\n\n\n/**\n * Write out the given line\n */\nXUnit.prototype.write = function(line) {\n    if (this.fileStream) {\n        this.fileStream.write(line + '\\n');\n    } else {\n        console.log(line);\n    }\n};\n\n/**\n * Output tag for the given `test.`\n */\n\nXUnit.prototype.test = function(test, ostream) {\n  var attrs = {\n      classname: test.parent.fullTitle()\n    , name: test.title\n    , time: (test.duration / 1000) || 0\n  };\n\n  if ('failed' == test.state) {\n    var err = test.err;\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, cdata(escape(err.message) + \"\\n\" + err.stack))));\n  } else if (test.pending) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true) );\n  }\n};\n\n/**\n * HTML tag helper.\n */\n\nfunction tag(name, attrs, close, content) {\n  var end = close ? '/>' : '>'\n    , pairs = []\n    , tag;\n\n  for (var key in attrs) {\n    pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) tag += content + '</' + name + end;\n  return tag;\n}\n\n/**\n * Return cdata escaped CDATA `str`.\n */\n\nfunction cdata(str) {\n  return '<![CDATA[' + escape(str) + ']]>';\n}\n\n}); // module: reporters/xunit.js\n\nrequire.register(\"runnable.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('browser/events').EventEmitter\n  , debug = require('browser/debug')('mocha:runnable')\n  , Pending = require('./pending')\n  , milliseconds = require('./ms')\n  , utils = require('./utils');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date\n  , setTimeout = global.setTimeout\n  , setInterval = global.setInterval\n  , clearTimeout = global.clearTimeout\n  , clearInterval = global.clearInterval;\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\n\nfunction Runnable(title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.async = fn && fn.length;\n  this.sync = ! this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._trace = new Error('done() called multiple times')\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nfunction F(){};\nF.prototype = EventEmitter.prototype;\nRunnable.prototype = new F;\nRunnable.prototype.constructor = Runnable;\n\n\n/**\n * Set & get timeout `ms`.\n *\n * @param {Number|String} ms\n * @return {Runnable|Number} ms or self\n * @api private\n */\n\nRunnable.prototype.timeout = function(ms){\n  if (0 == arguments.length) return this._timeout;\n  if (ms === 0) this._enableTimeouts = false;\n  if ('string' == typeof ms) ms = milliseconds(ms);\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) this.resetTimeout();\n  return this;\n};\n\n/**\n * Set & get slow `ms`.\n *\n * @param {Number|String} ms\n * @return {Runnable|Number} ms or self\n * @api private\n */\n\nRunnable.prototype.slow = function(ms){\n  if (0 === arguments.length) return this._slow;\n  if ('string' == typeof ms) ms = milliseconds(ms);\n  debug('timeout %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and & get timeout `enabled`.\n *\n * @param {Boolean} enabled\n * @return {Runnable|Boolean} enabled or self\n * @api private\n */\n\nRunnable.prototype.enableTimeouts = function(enabled){\n  if (arguments.length === 0) return this._enableTimeouts;\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @api private\n */\n\nRunnable.prototype.skip = function(){\n    throw new Pending();\n};\n\n/**\n * Return the full title generated by recursively\n * concatenating the parent's full title.\n *\n * @return {String}\n * @api public\n */\n\nRunnable.prototype.fullTitle = function(){\n  return this.parent.fullTitle() + ' ' + this.title;\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\n\nRunnable.prototype.clearTimeout = function(){\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @return {String}\n * @api private\n */\n\nRunnable.prototype.inspect = function(){\n  return JSON.stringify(this, function(key, val){\n    if ('_' == key[0]) return;\n    if ('parent' == key) return '#<Suite>';\n    if ('ctx' == key) return '#<Context>';\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\n\nRunnable.prototype.resetTimeout = function(){\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) return;\n  this.clearTimeout();\n  this.timer = setTimeout(function(){\n    if (!self._enableTimeouts) return;\n    self.callback(new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.'));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Whitelist these globals for this test run\n *\n * @api private\n */\nRunnable.prototype.globals = function(arr){\n  var self = this;\n  this._allowedGlobals = arr;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\n\nRunnable.prototype.run = function(fn){\n  var self = this\n    , start = new Date\n    , ctx = this.ctx\n    , finished\n    , emitted;\n\n  // Some times the ctx exists but it is not runnable\n  if (ctx && ctx.runnable) ctx.runnable(this);\n\n  // called multiple times\n  function multiple(err) {\n    if (emitted) return;\n    emitted = true;\n    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));\n  }\n\n  // finished\n  function done(err) {\n    var ms = self.timeout();\n    if (self.timedOut) return;\n    if (finished) return multiple(err || self._trace);\n\n    // Discard the resolution if this test has already failed asynchronously\n    if (self.state) return;\n\n    self.clearTimeout();\n    self.duration = new Date - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) err = new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.');\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    try {\n      this.fn.call(ctx, function(err){\n        if (err instanceof Error || toString.call(err) === \"[object Error]\") return done(err);\n        if (null != err) {\n          if (Object.prototype.toString.call(err) === '[object Object]') {\n            return done(new Error('done() invoked with non-Error: ' + JSON.stringify(err)));\n          } else {\n            return done(new Error('done() invoked with non-Error: ' + err));\n          }\n        }\n        done();\n      });\n    } catch (err) {\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.asyncOnly) {\n    return done(new Error('--async-only option in use without declaring `done()`'));\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.pending) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    done(utils.getError(err));\n  }\n\n  function callFn(fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function() {\n          done()\n        },\n        function(reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'))\n        });\n    } else {\n      done();\n    }\n  }\n};\n\n}); // module: runnable.js\n\nrequire.register(\"runner.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('browser/events').EventEmitter\n  , debug = require('browser/debug')('mocha:runner')\n  , Pending = require('./pending')\n  , Test = require('./test')\n  , utils = require('./utils')\n  , filter = utils.filter\n  , keys = utils.keys\n  , type = utils.type\n  , stringify = utils.stringify\n  , stackFilter = utils.stackTraceFilter();\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`.\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @param {Suite} suite Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n *   until ready.\n * @api public\n */\n\nfunction Runner(suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function(test){ self.checkGlobals(test); });\n  this.on('hook end', function(hook){ self.checkGlobals(hook); });\n  this.grep(/.*/);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\n\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nfunction F(){};\nF.prototype = EventEmitter.prototype;\nRunner.prototype = new F;\nRunner.prototype.constructor = Runner;\n\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @param {RegExp} re\n * @param {Boolean} invert\n * @return {Runner} for chaining\n * @api public\n */\n\nRunner.prototype.grep = function(re, invert){\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @param {Suite} suite\n * @return {Number}\n * @api public\n */\n\nRunner.prototype.grepTotal = function(suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function(test){\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) match = !match;\n    if (match) total++;\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\n\nRunner.prototype.globalProps = function() {\n  var props = utils.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~utils.indexOf(props, globals[i])) continue;\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @param {Array} arr\n * @return {Runner} for chaining\n * @api public\n */\n\nRunner.prototype.globals = function(arr){\n  if (0 == arguments.length) return this._globals;\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\n\nRunner.prototype.checkGlobals = function(test){\n  if (this.ignoreLeaks) return;\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if(this.prevGlobalsLength == globals.length) return;\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @param {Test} test\n * @param {Error} err\n * @api private\n */\n\nRunner.prototype.fail = function(test, err) {\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error)) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  err.stack = (this.fullStackTrace || !err.stack)\n    ? err.stack\n    : stackFilter(err.stack);\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @param {Hook} hook\n * @param {Error} err\n * @api private\n */\n\nRunner.prototype.failHook = function(hook, err){\n  this.fail(hook, err);\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @param {String} name\n * @param {Function} function\n * @api private\n */\n\nRunner.prototype.hook = function(name, fn){\n  var suite = this.suite\n    , hooks = suite['_' + name]\n    , self = this\n    , timer;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) return fn();\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    hook.on('error', function(err){\n      self.failHook(hook, err);\n    });\n\n    hook.run(function(err){\n      hook.removeAllListeners('error');\n      var testError = hook.error();\n      if (testError) self.fail(self.test, testError);\n      if (err) {\n        if (err instanceof Pending) {\n          suite.pending = true;\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function(){\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @param {String} name\n * @param {Array} suites\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.hooks = function(name, suites, fn){\n  var self = this\n    , orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function(err){\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.hookUp = function(name, fn){\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.hookDown = function(name, fn){\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\n\nRunner.prototype.parents = function(){\n  var suite = this.suite\n    , suites = [];\n  while (suite = suite.parent) suites.push(suite);\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.runTest = function(fn){\n  var test = this.test\n    , self = this;\n\n  if (this.asyncOnly) test.asyncOnly = true;\n\n  try {\n    test.on('error', function(err){\n      self.fail(test, err);\n    });\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke\n * the callback `fn()` when complete.\n *\n * @param {Suite} suite\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.runTests = function(suite, fn){\n  var self = this\n    , tests = suite.tests.slice()\n    , test;\n\n\n  function hookErr(err, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function(err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) return hookErr(err2, errSuite2, true);\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) return fn();\n\n    if (self._abort) return fn();\n\n    if (err) return hookErr(err, errSuite, true);\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) return fn();\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) match = !match;\n    if (!match) return next();\n\n    // pending\n    if (test.pending) {\n      self.emit('pending', test);\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function(err, errSuite){\n\n      if (suite.pending) {\n        self.emit('pending', test);\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) return hookErr(err, errSuite, false);\n\n      self.currentRunnable = self.test;\n      self.runTest(function(err){\n        test = self.test;\n\n        if (err) {\n          if (err instanceof Pending) {\n            self.emit('pending', test);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the\n * callback `fn()` when complete.\n *\n * @param {Suite} suite\n * @param {Function} fn\n * @api private\n */\n\nRunner.prototype.runSuite = function(suite, fn){\n  var total = this.grepTotal(suite)\n    , self = this\n    , i = 0;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total) return fn();\n\n  this.emit('suite', this.suite = suite);\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite == suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      } else {\n        // errSuite is among the parents of current suite\n        // stop execution of errSuite and all sub-suites\n        return done(errSuite);\n      }\n    }\n\n    if (self._abort) return done();\n\n    var curr = suite.suites[i++];\n    if (!curr) return done();\n    self.runSuite(curr, next);\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.hook('afterAll', function(){\n      self.emit('suite end', suite);\n      fn(errSuite);\n    });\n  }\n\n  this.hook('beforeAll', function(err){\n    if (err) return done();\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\n\nRunner.prototype.uncaught = function(err){\n  if (err) {\n    debug('uncaught exception %s', err !== function () {\n      return this;\n    }.call(err) ? err : ( err.message || err ));\n  } else {\n    debug('uncaught undefined exception');\n    err = utils.undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n  if (!runnable) return;\n\n  runnable.clearTimeout();\n\n  // Ignore errors if complete\n  if (runnable.state) return;\n  this.fail(runnable, err);\n\n  // recover from test\n  if ('test' == runnable.type) {\n    this.emit('test end', runnable);\n    this.hookUp('afterEach', this.next);\n    return;\n  }\n\n  // bail on hooks\n  this.emit('end');\n};\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @param {Function} fn\n * @return {Runner} for chaining\n * @api public\n */\n\nRunner.prototype.run = function(fn){\n  var self = this,\n    rootSuite = this.suite;\n\n  fn = fn || function(){};\n\n  function uncaught(err){\n    self.uncaught(err);\n  }\n\n  function start() {\n    self.emit('start');\n    self.runSuite(rootSuite, function(){\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // callback\n  this.on('end', function(){\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  }\n  else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution\n *\n * @return {Runner} for chaining\n * @api public\n */\nRunner.prototype.abort = function(){\n  debug('aborting');\n  this._abort = true;\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n * @api private\n */\n\nfunction filterLeaks(ok, globals) {\n  return filter(globals, function(key){\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^d+/.test(key)) return false;\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method not init at first\n    // it is assigned in some seconds\n    if (global.navigator && /^getInterface/.test(key)) return false;\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && /^\\d+/.test(key)) return false;\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) return false;\n\n    var matched = filter(ok, function(ok){\n      if (~ok.indexOf('*')) return 0 == key.indexOf(ok.split('*')[0]);\n      return key == ok;\n    });\n    return matched.length == 0 && (!global.navigator || 'onerror' !== key);\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\n\nfunction extraGlobals() {\n if (typeof(process) === 'object' &&\n     typeof(process.version) === 'string') {\n\n   var nodeVersion = process.version.split('.').reduce(function(a, v) {\n     return a << 8 | v;\n   });\n\n   // 'errno' was renamed to process._errno in v0.9.11.\n\n   if (nodeVersion < 0x00090B) {\n     return ['errno'];\n   }\n }\n\n return [];\n}\n\n}); // module: runner.js\n\nrequire.register(\"suite.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('browser/events').EventEmitter\n  , debug = require('browser/debug')('mocha:suite')\n  , milliseconds = require('./ms')\n  , utils = require('./utils')\n  , Hook = require('./hook');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title`\n * and parent `Suite`. When a suite with the\n * same title is already present, that suite\n * is returned to provide nicer reporter\n * and more flexible meta-testing.\n *\n * @param {Suite} parent\n * @param {String} title\n * @return {Suite}\n * @api public\n */\n\nexports.create = function(parent, title){\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  if (parent.pending) suite.pending = true;\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given\n * `title` and `ctx`.\n *\n * @param {String} title\n * @param {Context} ctx\n * @api private\n */\n\nfunction Suite(title, parentContext) {\n  this.title = title;\n  var context = function() {};\n  context.prototype = parentContext;\n  this.ctx = new context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nfunction F(){};\nF.prototype = EventEmitter.prototype;\nSuite.prototype = new F;\nSuite.prototype.constructor = Suite;\n\n\n/**\n * Return a clone of this `Suite`.\n *\n * @return {Suite}\n * @api private\n */\n\nSuite.prototype.clone = function(){\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set timeout `ms` or short-hand such as \"2s\".\n *\n * @param {Number|String} ms\n * @return {Suite|Number} for chaining\n * @api private\n */\n\nSuite.prototype.timeout = function(ms){\n  if (0 == arguments.length) return this._timeout;\n  if (ms.toString() === '0') this._enableTimeouts = false;\n  if ('string' == typeof ms) ms = milliseconds(ms);\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n  * Set timeout `enabled`.\n  *\n  * @param {Boolean} enabled\n  * @return {Suite|Boolean} self or enabled\n  * @api private\n  */\n\nSuite.prototype.enableTimeouts = function(enabled){\n  if (arguments.length === 0) return this._enableTimeouts;\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set slow `ms` or short-hand such as \"2s\".\n *\n * @param {Number|String} ms\n * @return {Suite|Number} for chaining\n * @api private\n */\n\nSuite.prototype.slow = function(ms){\n  if (0 === arguments.length) return this._slow;\n  if ('string' == typeof ms) ms = milliseconds(ms);\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Sets whether to bail after first error.\n *\n * @param {Boolean} bail\n * @return {Suite|Number} for chaining\n * @api private\n */\n\nSuite.prototype.bail = function(bail){\n  if (0 == arguments.length) return this._bail;\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @param {Function} fn\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.beforeAll = function(title, fn){\n  if (this.pending) return this;\n  if ('function' === typeof title) {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @param {Function} fn\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.afterAll = function(title, fn){\n  if (this.pending) return this;\n  if ('function' === typeof title) {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @param {Function} fn\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.beforeEach = function(title, fn){\n  if (this.pending) return this;\n  if ('function' === typeof title) {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @param {Function} fn\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.afterEach = function(title, fn){\n  if (this.pending) return this;\n  if ('function' === typeof title) {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @param {Suite} suite\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.addSuite = function(suite){\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @param {Test} test\n * @return {Suite} for chaining\n * @api private\n */\n\nSuite.prototype.addTest = function(test){\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively\n * concatenating the parent's full title.\n *\n * @return {String}\n * @api public\n */\n\nSuite.prototype.fullTitle = function(){\n  if (this.parent) {\n    var full = this.parent.fullTitle();\n    if (full) return full + ' ' + this.title;\n  }\n  return this.title;\n};\n\n/**\n * Return the total number of tests.\n *\n * @return {Number}\n * @api public\n */\n\nSuite.prototype.total = function(){\n  return utils.reduce(this.suites, function(sum, suite){\n    return sum + suite.total();\n  }, 0) + this.tests.length;\n};\n\n/**\n * Iterates through each suite recursively to find\n * all tests. Applies a function in the format\n * `fn(test)`.\n *\n * @param {Function} fn\n * @return {Suite}\n * @api private\n */\n\nSuite.prototype.eachTest = function(fn){\n  utils.forEach(this.tests, fn);\n  utils.forEach(this.suites, function(suite){\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run() {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n\n}); // module: suite.js\n\nrequire.register(\"test.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\n\n/**\n * Expose `Test`.\n */\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\n\nfunction Test(title, fn) {\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\n\nfunction F(){};\nF.prototype = Runnable.prototype;\nTest.prototype = new F;\nTest.prototype.constructor = Test;\n\n\n}); // module: test.js\n\nrequire.register(\"utils.js\", function(module, exports, require){\n/**\n * Module dependencies.\n */\n\nvar fs = require('browser/fs')\n  , path = require('browser/path')\n  , basename = path.basename\n  , exists = fs.existsSync || path.existsSync\n  , glob = require('browser/glob')\n  , join = path.join\n  , debug = require('browser/debug')('mocha:watch');\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function(html){\n  return String(html)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};\n\n/**\n * Array#forEach (<=IE8)\n *\n * @param {Array} array\n * @param {Function} fn\n * @param {Object} scope\n * @api private\n */\n\nexports.forEach = function(arr, fn, scope){\n  for (var i = 0, l = arr.length; i < l; i++)\n    fn.call(scope, arr[i], i);\n};\n\n/**\n * Array#map (<=IE8)\n *\n * @param {Array} array\n * @param {Function} fn\n * @param {Object} scope\n * @api private\n */\n\nexports.map = function(arr, fn, scope){\n  var result = [];\n  for (var i = 0, l = arr.length; i < l; i++)\n    result.push(fn.call(scope, arr[i], i, arr));\n  return result;\n};\n\n/**\n * Array#indexOf (<=IE8)\n *\n * @parma {Array} arr\n * @param {Object} obj to find index of\n * @param {Number} start\n * @api private\n */\n\nexports.indexOf = function(arr, obj, start){\n  for (var i = start || 0, l = arr.length; i < l; i++) {\n    if (arr[i] === obj)\n      return i;\n  }\n  return -1;\n};\n\n/**\n * Array#reduce (<=IE8)\n *\n * @param {Array} array\n * @param {Function} fn\n * @param {Object} initial value\n * @api private\n */\n\nexports.reduce = function(arr, fn, val){\n  var rval = val;\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    rval = fn(rval, arr[i], i, arr);\n  }\n\n  return rval;\n};\n\n/**\n * Array#filter (<=IE8)\n *\n * @param {Array} array\n * @param {Function} fn\n * @api private\n */\n\nexports.filter = function(arr, fn){\n  var ret = [];\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    var val = arr[i];\n    if (fn(val, i, arr)) ret.push(val);\n  }\n\n  return ret;\n};\n\n/**\n * Object.keys (<=IE8)\n *\n * @param {Object} obj\n * @return {Array} keys\n * @api private\n */\n\nexports.keys = Object.keys || function(obj) {\n  var keys = []\n    , has = Object.prototype.hasOwnProperty; // for `window` on <=IE8\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @param {Array} files\n * @param {Function} fn\n * @api private\n */\n\nexports.watch = function(files, fn){\n  var options = { interval: 100 };\n  files.forEach(function(file){\n    debug('file %s', file);\n    fs.watchFile(file, options, function(curr, prev){\n      if (prev.mtime < curr.mtime) fn(file);\n    });\n  });\n};\n\n/**\n * Array.isArray (<=IE8)\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nvar isArray = Array.isArray || function (obj) {\n  return '[object Array]' == {}.toString.call(obj);\n};\n\n/**\n * @description\n * Buffer.prototype.toJSON polyfill\n * @type {Function}\n */\nif(typeof Buffer !== 'undefined' && Buffer.prototype) {\n  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function () {\n    return Array.prototype.slice.call(this, 0);\n  };\n}\n\n/**\n * Ignored files.\n */\n\nfunction ignored(path){\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @return {Array}\n * @api private\n */\n\nexports.files = function(dir, ext, ret){\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  fs.readdirSync(dir)\n    .filter(ignored)\n    .forEach(function(path){\n      path = join(dir, path);\n      if (fs.statSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.slug = function(str){\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`,\n * and re-indent for pre whitespace.\n */\n\nexports.clean = function(str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, '')\n    .replace(/^function *\\(.*\\)\\s*{|\\(.*\\) *=> *{?/, '')\n    .replace(/\\s+\\}$/, '');\n\n  var spaces = str.match(/^\\n?( *)/)[1].length\n    , tabs = str.match(/^\\n?(\\t*)/)[1].length\n    , re = new RegExp('^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs ? tabs : spaces) + '}', 'gm');\n\n  str = str.replace(re, '');\n\n  return exports.trim(str);\n};\n\n/**\n * Trim the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.trim = function(str){\n  return str.replace(/^\\s+|\\s+$/g, '');\n};\n\n/**\n * Parse the given `qs`.\n *\n * @param {String} qs\n * @return {Object}\n * @api private\n */\n\nexports.parseQuery = function(qs){\n  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair){\n    var i = pair.indexOf('=')\n      , key = pair.slice(0, i)\n      , val = pair.slice(++i);\n\n    obj[key] = decodeURIComponent(val);\n    return obj;\n  }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @param {String} js\n * @return {String}\n * @api private\n */\n\nfunction highlight(js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/\\bnew[ \\t]+(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>')\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @param {String} name\n * @api private\n */\n\nexports.highlightTags = function(name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called, which returns\n * a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @param {*} value Value to inspect\n * @param {string} [type] The type of the value, if known.\n * @returns {string}\n */\nvar emptyRepresentation = function emptyRepresentation(value, type) {\n  type = type || exports.type(value);\n\n  switch(type) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n};\n\n/**\n * Takes some variable and asks `{}.toString()` what it thinks it is.\n * @param {*} value Anything\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @returns {string}\n */\nexports.type = function type(value) {\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString.call(value)\n    .replace(/^\\[.+\\s(.+?)\\]$/, '$1')\n    .toLowerCase();\n};\n\n/**\n * @summary Stringify `value`.\n * @description Different behavior depending on type of value.\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @see exports.type\n * @param {*} value\n * @return {string}\n * @api private\n */\n\nexports.stringify = function(value) {\n  var type = exports.type(value);\n\n  if (!~exports.indexOf(['object', 'array', 'function'], type)) {\n    if(type != 'buffer') {\n      return jsonStringify(value);\n    }\n    var json = value.toJSON();\n    // Based on the toJSON result\n    return jsonStringify(json.data && json.type ? json.data : json, 2)\n      .replace(/,(\\n|$)/g, '$1');\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(exports.canonicalize(value), 2).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, type);\n};\n\n/**\n * @description\n * like JSON.stringify but more sense.\n * @param {Object}  object\n * @param {Number=} spaces\n * @param {number=} depth\n * @returns {*}\n * @private\n */\nfunction jsonStringify(object, spaces, depth) {\n  if(typeof spaces == 'undefined') return _stringify(object);  // primitive types\n\n  depth = depth || 1;\n  var space = spaces * depth\n    , str = isArray(object) ? '[' : '{'\n    , end = isArray(object) ? ']' : '}'\n    , length = object.length || exports.keys(object).length\n    , repeat = function(s, n) { return new Array(n).join(s); }; // `.repeat()` polyfill\n\n  function _stringify(val) {\n    switch (exports.type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'number':\n        val = val === 0 && (1/val) === -Infinity // `-0`\n          ? '-0'\n          : val.toString();\n        break;\n      case 'date':\n        val = '[Date: ' + val.toISOString() + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val = (val == '[Function]' || val == '[Circular]')\n          ? val\n          : '\"' + val + '\"'; //string\n    }\n    return val;\n  }\n\n  for(var i in object) {\n    if(!object.hasOwnProperty(i)) continue;        // not my business\n    --length;\n    str += '\\n ' + repeat(' ', space)\n      + (isArray(object) ? '' : '\"' + i + '\": ') // key\n      +  _stringify(object[i])                   // value\n      + (length ? ',' : '');                     // comma\n  }\n\n  return str + (str.length != 1                    // [], {}\n    ? '\\n' + repeat(' ', --space) + end\n    : end);\n}\n\n/**\n * Return if obj is a Buffer\n * @param {Object} arg\n * @return {Boolean}\n * @api private\n */\nexports.isBuffer = function (arg) {\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(arg);\n};\n\n/**\n * @summary Return a new Thing that has the keys in sorted order.  Recursive.\n * @description If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @return {(Object|Array|Function|string|undefined)}\n * @see {@link exports.stringify}\n * @api private\n */\n\nexports.canonicalize = function(value, stack) {\n  var canonicalizedObj,\n    type = exports.type(value),\n    prop,\n    withStack = function withStack(value, fn) {\n      stack.push(value);\n      fn();\n      stack.pop();\n    };\n\n  stack = stack || [];\n\n  if (exports.indexOf(stack, value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch(type) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function () {\n        canonicalizedObj = exports.map(value, function (item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, type);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function () {\n        exports.forEach(exports.keys(value).sort(), function (key) {\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value.toString();\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n */\nexports.lookupFiles = function lookupFiles(path, extensions, recursive) {\n  var files = [];\n  var re = new RegExp('\\\\.(' + extensions.join('|') + ')$');\n\n  if (!exists(path)) {\n    if (exists(path + '.js')) {\n      path += '.js';\n    } else {\n      files = glob.sync(path);\n      if (!files.length) throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");\n      return files;\n    }\n  }\n\n  try {\n    var stat = fs.statSync(path);\n    if (stat.isFile()) return path;\n  }\n  catch (ignored) {\n    return;\n  }\n\n  fs.readdirSync(path).forEach(function(file) {\n    file = join(path, file);\n    try {\n      var stat = fs.statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    }\n    catch (ignored) {\n      return;\n    }\n    if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') return;\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function() {\n  return new Error('Caught undefined error, did you throw without specifying what?');\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function(err) {\n  return err || exports.undefinedError();\n};\n\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha, node_modules, bower and componentJS from stack trace).\n * @returns {Function}\n */\n\nexports.stackTraceFilter = function() {\n  var slash = '/'\n    , is = typeof document === 'undefined'\n      ? { node: true }\n      : { browser: true }\n    , cwd = is.node\n      ? process.cwd() + slash\n      : location.href.replace(/\\/[^\\/]*$/, '/');\n\n  function isNodeModule (line) {\n    return (~line.indexOf('node_modules'));\n  }\n\n  function isMochaInternal (line) {\n    return (~line.indexOf('node_modules' + slash + 'mocha'))  ||\n      (~line.indexOf('components' + slash + 'mochajs'))       ||\n      (~line.indexOf('components' + slash + 'mocha'));\n  }\n\n  // node_modules, bower, componentJS\n  function isBrowserModule(line) {\n    return (~line.indexOf('node_modules')) ||\n      (~line.indexOf('components'));\n  }\n\n  function isNodeInternal (line) {\n    return (~line.indexOf('(timers.js:')) ||\n      (~line.indexOf('(events.js:'))      ||\n      (~line.indexOf('(node.js:'))        ||\n      (~line.indexOf('(module.js:'))      ||\n      (~line.indexOf('GeneratorFunctionPrototype.next (native)')) ||\n      false\n  }\n\n  return function(stack) {\n    stack = stack.split('\\n');\n\n    stack = exports.reduce(stack, function(list, line) {\n      if (is.node && (isNodeModule(line) ||\n        isMochaInternal(line) ||\n        isNodeInternal(line)))\n        return list;\n\n      if (is.browser && (isBrowserModule(line)))\n        return list;\n\n      // Clean up cwd(absolute)\n      list.push(line.replace(cwd, ''));\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  }\n};\n}); // module: utils.js\n// The global object is \"self\" in Web Workers.\nvar global = (function() { return this; })();\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n\n/**\n * Node shims.\n *\n * These are meant only to allow\n * mocha.js to run untouched, not\n * to allow running node code in\n * the browser.\n */\n\nvar process = {};\nprocess.exit = function(status){};\nprocess.stdout = {};\n\nvar uncaughtExceptionHandlers = [];\n\nvar originalOnerrorHandler = global.onerror;\n\n/**\n * Remove uncaughtException listener.\n * Revert to original onerror handler if previously defined.\n */\n\nprocess.removeListener = function(e, fn){\n  if ('uncaughtException' == e) {\n    if (originalOnerrorHandler) {\n      global.onerror = originalOnerrorHandler;\n    } else {\n      global.onerror = function() {};\n    }\n    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);\n    if (i != -1) { uncaughtExceptionHandlers.splice(i, 1); }\n  }\n};\n\n/**\n * Implements uncaughtException listener.\n */\n\nprocess.on = function(e, fn){\n  if ('uncaughtException' == e) {\n    global.onerror = function(err, url, line){\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\n      return true;\n    };\n    uncaughtExceptionHandlers.push(fn);\n  }\n};\n\n/**\n * Expose mocha.\n */\n\nvar Mocha = global.Mocha = require('mocha'),\n    mocha = global.mocha = new Mocha({ reporter: 'html' });\n\n// The BDD UI is registered by default, but no UI will be functional in the\n// browser without an explicit call to the overridden `mocha.ui` (see below).\n// Ensure that this default UI does not expose its methods to the global scope.\nmocha.suite.removeAllListeners('pre-require');\n\nvar immediateQueue = []\n  , immediateTimeout;\n\nfunction timeslice() {\n  var immediateStart = new Date().getTime();\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\n    immediateQueue.shift()();\n  }\n  if (immediateQueue.length) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  } else {\n    immediateTimeout = null;\n  }\n}\n\n/**\n * High-performance override of Runner.immediately.\n */\n\nMocha.Runner.immediately = function(callback) {\n  immediateQueue.push(callback);\n  if (!immediateTimeout) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  }\n};\n\n/**\n * Function to allow assertion libraries to throw errors directly into mocha.\n * This is useful when running tests in a browser because window.onerror will\n * only receive the 'message' attribute of the Error.\n */\nmocha.throwError = function(err) {\n  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {\n    fn(err);\n  });\n  throw err;\n};\n\n/**\n * Override ui to ensure that the ui functions are initialized.\n * Normally this would happen in Mocha.prototype.loadFiles.\n */\n\nmocha.ui = function(ui){\n  Mocha.prototype.ui.call(this, ui);\n  this.suite.emit('pre-require', global, null, this);\n  return this;\n};\n\n/**\n * Setup mocha with the given setting options.\n */\n\nmocha.setup = function(opts){\n  if ('string' == typeof opts) opts = { ui: opts };\n  for (var opt in opts) this[opt](opts[opt]);\n  return this;\n};\n\n/**\n * Run mocha, returning the Runner.\n */\n\nmocha.run = function(fn){\n  var options = mocha.options;\n  mocha.globals('location');\n\n  var query = Mocha.utils.parseQuery(global.location.search || '');\n  if (query.grep) mocha.grep(new RegExp(query.grep));\n  if (query.fgrep) mocha.grep(query.fgrep);\n  if (query.invert) mocha.invert();\n\n  return Mocha.prototype.run.call(mocha, function(err){\n    // The DOM Document is not available in Web Workers.\n    var document = global.document;\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\n      Mocha.utils.highlightTags('code');\n    }\n    if (fn) fn(err);\n  });\n};\n\n/**\n * Expose the process shim.\n */\n\nMocha.process = process;\n})();\n",
  "node_modules/mocha/node_modules/commander/index.js": "\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar spawn = require('child_process').spawn;\nvar path = require('path');\nvar dirname = path.dirname;\nvar basename = path.basename;\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command;\n\n/**\n * Expose `Command`.\n */\n\nexports.Command = Command;\n\n/**\n * Expose `Option`.\n */\n\nexports.Option = Option;\n\n/**\n * Initialize a new `Option` with the given `flags` and `description`.\n *\n * @param {String} flags\n * @param {String} description\n * @api public\n */\n\nfunction Option(flags, description) {\n  this.flags = flags;\n  this.required = ~flags.indexOf('<');\n  this.optional = ~flags.indexOf('[');\n  this.bool = !~flags.indexOf('-no-');\n  flags = flags.split(/[ ,|]+/);\n  if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();\n  this.long = flags.shift();\n  this.description = description || '';\n}\n\n/**\n * Return option name.\n *\n * @return {String}\n * @api private\n */\n\nOption.prototype.name = function(){\n  return this.long\n    .replace('--', '')\n    .replace('no-', '');\n};\n\n/**\n * Check if `arg` matches the short or long flag.\n *\n * @param {String} arg\n * @return {Boolean}\n * @api private\n */\n\nOption.prototype.is = function(arg){\n  return arg == this.short\n    || arg == this.long;\n};\n\n/**\n * Initialize a new `Command`.\n *\n * @param {String} name\n * @api public\n */\n\nfunction Command(name) {\n  this.commands = [];\n  this.options = [];\n  this._execs = [];\n  this._args = [];\n  this._name = name;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nCommand.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Add command `name`.\n *\n * The `.action()` callback is invoked when the\n * command `name` is specified via __ARGV__,\n * and the remaining arguments are applied to the\n * function for access.\n *\n * When the `name` is \"*\" an un-matched command\n * will be passed as the first arg, followed by\n * the rest of __ARGV__ remaining.\n *\n * Examples:\n *\n *      program\n *        .version('0.0.1')\n *        .option('-C, --chdir <path>', 'change the working directory')\n *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')\n *        .option('-T, --no-tests', 'ignore test hook')\n *\n *      program\n *        .command('setup')\n *        .description('run remote setup commands')\n *        .action(function(){\n *          console.log('setup');\n *        });\n *\n *      program\n *        .command('exec <cmd>')\n *        .description('run the given remote command')\n *        .action(function(cmd){\n *          console.log('exec \"%s\"', cmd);\n *        });\n *\n *      program\n *        .command('*')\n *        .description('deploy the given env')\n *        .action(function(env){\n *          console.log('deploying \"%s\"', env);\n *        });\n *\n *      program.parse(process.argv);\n  *\n * @param {String} name\n * @param {String} [desc]\n * @return {Command} the new command\n * @api public\n */\n\nCommand.prototype.command = function(name, desc) {\n  var args = name.split(/ +/);\n  var cmd = new Command(args.shift());\n  if (desc) cmd.description(desc);\n  if (desc) this.executables = true;\n  if (desc) this._execs[cmd._name] = true;\n  this.commands.push(cmd);\n  cmd.parseExpectedArgs(args);\n  cmd.parent = this;\n  if (desc) return this;\n  return cmd;\n};\n\n/**\n * Add an implicit `help [cmd]` subcommand\n * which invokes `--help` for the given command.\n *\n * @api private\n */\n\nCommand.prototype.addImplicitHelpCommand = function() {\n  this.command('help [cmd]', 'display help for [cmd]');\n};\n\n/**\n * Parse expected `args`.\n *\n * For example `[\"[type]\"]` becomes `[{ required: false, name: 'type' }]`.\n *\n * @param {Array} args\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.parseExpectedArgs = function(args){\n  if (!args.length) return;\n  var self = this;\n  args.forEach(function(arg){\n    switch (arg[0]) {\n      case '<':\n        self._args.push({ required: true, name: arg.slice(1, -1) });\n        break;\n      case '[':\n        self._args.push({ required: false, name: arg.slice(1, -1) });\n        break;\n    }\n  });\n  return this;\n};\n\n/**\n * Register callback `fn` for the command.\n *\n * Examples:\n *\n *      program\n *        .command('help')\n *        .description('display verbose help')\n *        .action(function(){\n *           // output help here\n *        });\n *\n * @param {Function} fn\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.action = function(fn){\n  var self = this;\n  var listener = function(args, unknown){\n    // Parse any so-far unknown options\n    args = args || [];\n    unknown = unknown || [];\n\n    var parsed = self.parseOptions(unknown);\n\n    // Output help if necessary\n    outputHelpIfNecessary(self, parsed.unknown);\n\n    // If there are still any unknown options, then we simply\n    // die, unless someone asked for help, in which case we give it\n    // to them, and then we die.\n    if (parsed.unknown.length > 0) {\n      self.unknownOption(parsed.unknown[0]);\n    }\n\n    // Leftover arguments need to be pushed back. Fixes issue #56\n    if (parsed.args.length) args = parsed.args.concat(args);\n\n    self._args.forEach(function(arg, i){\n      if (arg.required && null == args[i]) {\n        self.missingArgument(arg.name);\n      }\n    });\n\n    // Always append ourselves to the end of the arguments,\n    // to make sure we match the number of arguments the user\n    // expects\n    if (self._args.length) {\n      args[self._args.length] = self;\n    } else {\n      args.push(self);\n    }\n\n    fn.apply(this, args);\n  };\n  this.parent.on(this._name, listener);\n  if (this._alias) this.parent.on(this._alias, listener);\n  return this;\n};\n\n/**\n * Define option with `flags`, `description` and optional\n * coercion `fn`.\n *\n * The `flags` string should contain both the short and long flags,\n * separated by comma, a pipe or space. The following are all valid\n * all will output this way when `--help` is used.\n *\n *    \"-p, --pepper\"\n *    \"-p|--pepper\"\n *    \"-p --pepper\"\n *\n * Examples:\n *\n *     // simple boolean defaulting to false\n *     program.option('-p, --pepper', 'add pepper');\n *\n *     --pepper\n *     program.pepper\n *     // => Boolean\n *\n *     // simple boolean defaulting to true\n *     program.option('-C, --no-cheese', 'remove cheese');\n *\n *     program.cheese\n *     // => true\n *\n *     --no-cheese\n *     program.cheese\n *     // => false\n *\n *     // required argument\n *     program.option('-C, --chdir <path>', 'change the working directory');\n *\n *     --chdir /tmp\n *     program.chdir\n *     // => \"/tmp\"\n *\n *     // optional argument\n *     program.option('-c, --cheese [type]', 'add cheese [marble]');\n *\n * @param {String} flags\n * @param {String} description\n * @param {Function|Mixed} fn or default\n * @param {Mixed} defaultValue\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.option = function(flags, description, fn, defaultValue){\n  var self = this\n    , option = new Option(flags, description)\n    , oname = option.name()\n    , name = camelcase(oname);\n\n  // default as 3rd arg\n  if ('function' != typeof fn) defaultValue = fn, fn = null;\n\n  // preassign default value only for --no-*, [optional], or <required>\n  if (false == option.bool || option.optional || option.required) {\n    // when --no-* we make sure default is true\n    if (false == option.bool) defaultValue = true;\n    // preassign only if we have a default\n    if (undefined !== defaultValue) self[name] = defaultValue;\n  }\n\n  // register the option\n  this.options.push(option);\n\n  // when it's passed assign the value\n  // and conditionally invoke the callback\n  this.on(oname, function(val){\n    // coercion\n    if (null !== val && fn) val = fn(val, undefined === self[name] ? defaultValue : self[name]);\n\n    // unassigned or bool\n    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {\n      // if no value, bool true, and we have a default, then use it!\n      if (null == val) {\n        self[name] = option.bool\n          ? defaultValue || true\n          : false;\n      } else {\n        self[name] = val;\n      }\n    } else if (null !== val) {\n      // reassign\n      self[name] = val;\n    }\n  });\n\n  return this;\n};\n\n/**\n * Parse `argv`, settings options and invoking commands when defined.\n *\n * @param {Array} argv\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.parse = function(argv){\n  // implicit help\n  if (this.executables) this.addImplicitHelpCommand();\n\n  // store raw args\n  this.rawArgs = argv;\n\n  // guess name\n  this._name = this._name || basename(argv[1], '.js');\n\n  // process argv\n  var parsed = this.parseOptions(this.normalize(argv.slice(2)));\n  var args = this.args = parsed.args;\n\n  var result = this.parseArgs(this.args, parsed.unknown);\n\n  // executable sub-commands\n  var name = result.args[0];\n  if (this._execs[name]) return this.executeSubCommand(argv, args, parsed.unknown);\n\n  return result;\n};\n\n/**\n * Execute a sub-command executable.\n *\n * @param {Array} argv\n * @param {Array} args\n * @param {Array} unknown\n * @api private\n */\n\nCommand.prototype.executeSubCommand = function(argv, args, unknown) {\n  args = args.concat(unknown);\n\n  if (!args.length) this.help();\n  if ('help' == args[0] && 1 == args.length) this.help();\n\n  // <cmd> --help\n  if ('help' == args[0]) {\n    args[0] = args[1];\n    args[1] = '--help';\n  }\n\n  // executable\n  var dir = dirname(argv[1]);\n  var bin = basename(argv[1], '.js') + '-' + args[0];\n\n  // check for ./<bin> first\n  var local = path.join(dir, bin);\n\n  // run it\n  args = args.slice(1);\n  args.unshift(local);\n  var proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });\n  proc.on('error', function(err){\n    if (err.code == \"ENOENT\") {\n      console.error('\\n  %s(1) does not exist, try --help\\n', bin);\n    } else if (err.code == \"EACCES\") {\n      console.error('\\n  %s(1) not executable. try chmod or run with root\\n', bin);\n    }\n  });\n\n  this.runningCommand = proc;\n};\n\n/**\n * Normalize `args`, splitting joined short flags. For example\n * the arg \"-abc\" is equivalent to \"-a -b -c\".\n * This also normalizes equal sign and splits \"--abc=def\" into \"--abc def\".\n *\n * @param {Array} args\n * @return {Array}\n * @api private\n */\n\nCommand.prototype.normalize = function(args){\n  var ret = []\n    , arg\n    , lastOpt\n    , index;\n\n  for (var i = 0, len = args.length; i < len; ++i) {\n    arg = args[i];\n    i > 0 && (lastOpt = this.optionFor(args[i-1]));\n\n    if (lastOpt && lastOpt.required) {\n     \tret.push(arg);\n    } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {\n      arg.slice(1).split('').forEach(function(c){\n        ret.push('-' + c);\n      });\n    } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {\n      ret.push(arg.slice(0, index), arg.slice(index + 1));\n    } else {\n      ret.push(arg);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Parse command `args`.\n *\n * When listener(s) are available those\n * callbacks are invoked, otherwise the \"*\"\n * event is emitted and those actions are invoked.\n *\n * @param {Array} args\n * @return {Command} for chaining\n * @api private\n */\n\nCommand.prototype.parseArgs = function(args, unknown){\n  var cmds = this.commands\n    , len = cmds.length\n    , name;\n\n  if (args.length) {\n    name = args[0];\n    if (this.listeners(name).length) {\n      this.emit(args.shift(), args, unknown);\n    } else {\n      this.emit('*', args);\n    }\n  } else {\n    outputHelpIfNecessary(this, unknown);\n\n    // If there were no args and we have unknown options,\n    // then they are extraneous and we need to error.\n    if (unknown.length > 0) {\n      this.unknownOption(unknown[0]);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return an option matching `arg` if any.\n *\n * @param {String} arg\n * @return {Option}\n * @api private\n */\n\nCommand.prototype.optionFor = function(arg){\n  for (var i = 0, len = this.options.length; i < len; ++i) {\n    if (this.options[i].is(arg)) {\n      return this.options[i];\n    }\n  }\n};\n\n/**\n * Parse options from `argv` returning `argv`\n * void of these options.\n *\n * @param {Array} argv\n * @return {Array}\n * @api public\n */\n\nCommand.prototype.parseOptions = function(argv){\n  var args = []\n    , len = argv.length\n    , literal\n    , option\n    , arg;\n\n  var unknownOptions = [];\n\n  // parse options\n  for (var i = 0; i < len; ++i) {\n    arg = argv[i];\n\n    // literal args after --\n    if ('--' == arg) {\n      literal = true;\n      continue;\n    }\n\n    if (literal) {\n      args.push(arg);\n      continue;\n    }\n\n    // find matching Option\n    option = this.optionFor(arg);\n\n    // option is defined\n    if (option) {\n      // requires arg\n      if (option.required) {\n        arg = argv[++i];\n        if (null == arg) return this.optionMissingArgument(option);\n        this.emit(option.name(), arg);\n      // optional arg\n      } else if (option.optional) {\n        arg = argv[i+1];\n        if (null == arg || ('-' == arg[0] && '-' != arg)) {\n          arg = null;\n        } else {\n          ++i;\n        }\n        this.emit(option.name(), arg);\n      // bool\n      } else {\n        this.emit(option.name());\n      }\n      continue;\n    }\n\n    // looks like an option\n    if (arg.length > 1 && '-' == arg[0]) {\n      unknownOptions.push(arg);\n\n      // If the next argument looks like it might be\n      // an argument for this option, we pass it on.\n      // If it isn't, then it'll simply be ignored\n      if (argv[i+1] && '-' != argv[i+1][0]) {\n        unknownOptions.push(argv[++i]);\n      }\n      continue;\n    }\n\n    // arg\n    args.push(arg);\n  }\n\n  return { args: args, unknown: unknownOptions };\n};\n\n/**\n * Argument `name` is missing.\n *\n * @param {String} name\n * @api private\n */\n\nCommand.prototype.missingArgument = function(name){\n  console.error();\n  console.error(\"  error: missing required argument `%s'\", name);\n  console.error();\n  process.exit(1);\n};\n\n/**\n * `Option` is missing an argument, but received `flag` or nothing.\n *\n * @param {String} option\n * @param {String} flag\n * @api private\n */\n\nCommand.prototype.optionMissingArgument = function(option, flag){\n  console.error();\n  if (flag) {\n    console.error(\"  error: option `%s' argument missing, got `%s'\", option.flags, flag);\n  } else {\n    console.error(\"  error: option `%s' argument missing\", option.flags);\n  }\n  console.error();\n  process.exit(1);\n};\n\n/**\n * Unknown option `flag`.\n *\n * @param {String} flag\n * @api private\n */\n\nCommand.prototype.unknownOption = function(flag){\n  console.error();\n  console.error(\"  error: unknown option `%s'\", flag);\n  console.error();\n  process.exit(1);\n};\n\n\n/**\n * Set the program version to `str`.\n *\n * This method auto-registers the \"-V, --version\" flag\n * which will print the version number when passed.\n *\n * @param {String} str\n * @param {String} flags\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.version = function(str, flags){\n  if (0 == arguments.length) return this._version;\n  this._version = str;\n  flags = flags || '-V, --version';\n  this.option(flags, 'output the version number');\n  this.on('version', function(){\n    console.log(str);\n    process.exit(0);\n  });\n  return this;\n};\n\n/**\n * Set the description `str`.\n *\n * @param {String} str\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.description = function(str){\n  if (0 == arguments.length) return this._description;\n  this._description = str;\n  return this;\n};\n\n/**\n * Set an alias for the command\n *\n * @param {String} alias\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.alias = function(alias){\n  if (0 == arguments.length) return this._alias;\n  this._alias = alias;\n  return this;\n};\n\n/**\n * Set / get the command usage `str`.\n *\n * @param {String} str\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.usage = function(str){\n  var args = this._args.map(function(arg){\n    return arg.required\n      ? '<' + arg.name + '>'\n      : '[' + arg.name + ']';\n  });\n\n  var usage = '[options'\n    + (this.commands.length ? '] [command' : '')\n    + ']'\n    + (this._args.length ? ' ' + args : '');\n\n  if (0 == arguments.length) return this._usage || usage;\n  this._usage = str;\n\n  return this;\n};\n\n/**\n * Return the largest option length.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.largestOptionLength = function(){\n  return this.options.reduce(function(max, option){\n    return Math.max(max, option.flags.length);\n  }, 0);\n};\n\n/**\n * Return help for options.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.optionHelp = function(){\n  var width = this.largestOptionLength();\n\n  // Prepend the help information\n  return [pad('-h, --help', width) + '  ' + 'output usage information']\n    .concat(this.options.map(function(option){\n      return pad(option.flags, width)\n        + '  ' + option.description;\n      }))\n    .join('\\n');\n};\n\n/**\n * Return command help documentation.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.commandHelp = function(){\n  if (!this.commands.length) return '';\n  return [\n      ''\n    , '  Commands:'\n    , ''\n    , this.commands.map(function(cmd){\n      var args = cmd._args.map(function(arg){\n        return arg.required\n          ? '<' + arg.name + '>'\n          : '[' + arg.name + ']';\n      }).join(' ');\n\n      return cmd._name\n        + (cmd._alias\n          ? '|' + cmd._alias\n          : '')\n        + (cmd.options.length\n          ? ' [options]'\n          : '') + ' ' + args\n        + (cmd.description()\n          ? '\\n   ' + cmd.description()\n          : '')\n        + '\\n';\n    }).join('\\n').replace(/^/gm, '    ')\n    , ''\n  ].join('\\n');\n};\n\n/**\n * Return program help documentation.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.helpInformation = function(){\n  return [\n      ''\n    , '  Usage: ' + this._name\n        + (this._alias\n          ? '|' + this._alias\n          : '')\n        + ' ' + this.usage()\n    , '' + this.commandHelp()\n    , '  Options:'\n    , ''\n    , '' + this.optionHelp().replace(/^/gm, '    ')\n    , ''\n    , ''\n  ].join('\\n');\n};\n\n/**\n * Output help information for this command\n *\n * @api public\n */\n\nCommand.prototype.outputHelp = function(){\n  process.stdout.write(this.helpInformation());\n  this.emit('--help');\n};\n\n/**\n * Output help information and exit.\n *\n * @api public\n */\n\nCommand.prototype.help = function(){\n  this.outputHelp();\n  process.exit();\n};\n\n/**\n * Camel-case the given `flag`\n *\n * @param {String} flag\n * @return {String}\n * @api private\n */\n\nfunction camelcase(flag) {\n  return flag.split('-').reduce(function(str, word){\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Pad `str` to `width`.\n *\n * @param {String} str\n * @param {Number} width\n * @return {String}\n * @api private\n */\n\nfunction pad(str, width) {\n  var len = Math.max(0, width - str.length);\n  return str + Array(len + 1).join(' ');\n}\n\n/**\n * Output help information if necessary\n *\n * @param {Command} command to output help for\n * @param {Array} array of options to search for -h or --help\n * @api private\n */\n\nfunction outputHelpIfNecessary(cmd, options) {\n  options = options || [];\n  for (var i = 0; i < options.length; i++) {\n    if (options[i] == '--help' || options[i] == '-h') {\n      cmd.outputHelp();\n      process.exit(0);\n    }\n  }\n}\n",
  "node_modules/mocha/node_modules/commander/package.json": "{\n  \"name\": \"commander\",\n  \"version\": \"2.3.0\",\n  \"description\": \"the complete solution for node.js command-line programs\",\n  \"keywords\": [\n    \"command\",\n    \"option\",\n    \"parser\",\n    \"prompt\",\n    \"stdin\"\n  ],\n  \"author\": {\n    \"name\": \"TJ Holowaychuk\",\n    \"email\": \"tj@vision-media.ca\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/visionmedia/commander.js.git\"\n  },\n  \"devDependencies\": {\n    \"should\": \">= 0.0.1\"\n  },\n  \"scripts\": {\n    \"test\": \"make test\"\n  },\n  \"main\": \"index\",\n  \"engines\": {\n    \"node\": \">= 0.6.x\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"gitHead\": \"7e9f407ec03d4371a478c2fe417db4998ecb6169\",\n  \"bugs\": {\n    \"url\": \"https://github.com/visionmedia/commander.js/issues\"\n  },\n  \"homepage\": \"https://github.com/visionmedia/commander.js\",\n  \"_id\": \"commander@2.3.0\",\n  \"_shasum\": \"fd430e889832ec353b9acd1de217c11cb3eef873\",\n  \"_from\": \"commander@2.3.0\",\n  \"_npmVersion\": \"1.4.21\",\n  \"_npmUser\": {\n    \"name\": \"somekittens\",\n    \"email\": \"rkoutnik@gmail.com\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"tjholowaychuk\",\n      \"email\": \"tj@vision-media.ca\"\n    },\n    {\n      \"name\": \"somekittens\",\n      \"email\": \"rkoutnik@gmail.com\"\n    },\n    {\n      \"name\": \"zhiyelee\",\n      \"email\": \"zhiyelee@gmail.com\"\n    },\n    {\n      \"name\": \"thethomaseffect\",\n      \"email\": \"thethomaseffect@gmail.com\"\n    }\n  ],\n  \"dist\": {\n    \"shasum\": \"fd430e889832ec353b9acd1de217c11cb3eef873\",\n    \"tarball\": \"http://registry.npmjs.org/commander/-/commander-2.3.0.tgz\"\n  },\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/commander/-/commander-2.3.0.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/debug/browser.js": "\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // This hackery is required for IE8,\n  // where the `console.log` function doesn't have 'apply'\n  return 'object' == typeof console\n    && 'function' == typeof console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      localStorage.removeItem('debug');\n    } else {\n      localStorage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = localStorage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n",
  "node_modules/mocha/node_modules/debug/component.json": "{\n  \"name\": \"debug\",\n  \"repo\": \"visionmedia/debug\",\n  \"description\": \"small debugging utility\",\n  \"version\": \"2.0.0\",\n  \"keywords\": [\n    \"debug\",\n    \"log\",\n    \"debugger\"\n  ],\n  \"main\": \"browser.js\",\n  \"scripts\": [\n    \"browser.js\",\n    \"debug.js\"\n  ],\n  \"dependencies\": {\n    \"guille/ms.js\": \"0.6.1\"\n  }\n}\n",
  "node_modules/mocha/node_modules/debug/debug.js": "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n",
  "node_modules/mocha/node_modules/debug/node_modules/ms/index.js": "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n",
  "node_modules/mocha/node_modules/debug/node_modules/ms/package.json": "{\n  \"name\": \"ms\",\n  \"version\": \"0.6.2\",\n  \"description\": \"Tiny ms conversion utility\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/guille/ms.js.git\"\n  },\n  \"main\": \"./index\",\n  \"devDependencies\": {\n    \"mocha\": \"*\",\n    \"expect.js\": \"*\",\n    \"serve\": \"*\"\n  },\n  \"component\": {\n    \"scripts\": {\n      \"ms/index.js\": \"index.js\"\n    }\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/guille/ms.js/issues\"\n  },\n  \"_id\": \"ms@0.6.2\",\n  \"dist\": {\n    \"shasum\": \"d89c2124c6fdc1353d65a8b77bf1aac4b193708c\",\n    \"tarball\": \"http://registry.npmjs.org/ms/-/ms-0.6.2.tgz\"\n  },\n  \"_from\": \"ms@0.6.2\",\n  \"_npmVersion\": \"1.2.30\",\n  \"_npmUser\": {\n    \"name\": \"rauchg\",\n    \"email\": \"rauchg@gmail.com\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"rauchg\",\n      \"email\": \"rauchg@gmail.com\"\n    }\n  ],\n  \"directories\": {},\n  \"_shasum\": \"d89c2124c6fdc1353d65a8b77bf1aac4b193708c\",\n  \"_resolved\": \"https://registry.npmjs.org/ms/-/ms-0.6.2.tgz\",\n  \"readme\": \"ERROR: No README data found!\",\n  \"homepage\": \"https://github.com/guille/ms.js#readme\"\n}\n",
  "node_modules/mocha/node_modules/debug/node.js": "\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();\n  if (0 === debugColors.length) {\n    return tty.isatty(1);\n  } else {\n    return '0' !== debugColors\n        && 'no' !== debugColors\n        && 'false' !== debugColors\n        && 'disabled' !== debugColors;\n  }\n}\n\n/**\n * Map %o to `util.inspect()`, since Node doesn't do that out of the box.\n */\n\nvar inspect = (4 === util.inspect.length ?\n  // node <= 0.8.x\n  function (v, colors) {\n    return util.inspect(v, void 0, void 0, colors);\n  } :\n  // node > 0.8.x\n  function (v, colors) {\n    return util.inspect(v, { colors: colors });\n  }\n);\n\nexports.formatters.o = function(v) {\n  return inspect(v, this.useColors)\n    .replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n  var name = this.namespace;\n\n  if (useColors) {\n    var c = this.color;\n\n    args[0] = '  \\u001b[9' + c + 'm' + name + ' '\n      + '\\u001b[0m'\n      + args[0] + '\\u001b[3' + c + 'm'\n      + ' +' + exports.humanize(this.diff) + '\\u001b[0m';\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n  return args;\n}\n\n/**\n * Invokes `console.error()` with the specified arguments.\n */\n\nfunction log() {\n  return console.error.apply(console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n",
  "node_modules/mocha/node_modules/debug/package.json": "{\n  \"name\": \"debug\",\n  \"version\": \"2.0.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/visionmedia/debug.git\"\n  },\n  \"description\": \"small debugging utility\",\n  \"keywords\": [\n    \"debug\",\n    \"log\",\n    \"debugger\"\n  ],\n  \"author\": {\n    \"name\": \"TJ Holowaychuk\",\n    \"email\": \"tj@vision-media.ca\"\n  },\n  \"contributors\": [\n    {\n      \"name\": \"Nathan Rajlich\",\n      \"email\": \"nathan@tootallnate.net\",\n      \"url\": \"http://n8.io\"\n    }\n  ],\n  \"dependencies\": {\n    \"ms\": \"0.6.2\"\n  },\n  \"devDependencies\": {\n    \"browserify\": \"5.11.0\",\n    \"mocha\": \"*\"\n  },\n  \"main\": \"./node.js\",\n  \"browser\": \"./browser.js\",\n  \"component\": {\n    \"scripts\": {\n      \"debug/index.js\": \"browser.js\",\n      \"debug/debug.js\": \"debug.js\"\n    }\n  },\n  \"gitHead\": \"c61ae82bde19c6fdedfc6684817ff7eb541ff029\",\n  \"bugs\": {\n    \"url\": \"https://github.com/visionmedia/debug/issues\"\n  },\n  \"homepage\": \"https://github.com/visionmedia/debug\",\n  \"_id\": \"debug@2.0.0\",\n  \"scripts\": {},\n  \"_shasum\": \"89bd9df6732b51256bc6705342bba02ed12131ef\",\n  \"_from\": \"debug@2.0.0\",\n  \"_npmVersion\": \"1.4.21\",\n  \"_npmUser\": {\n    \"name\": \"tootallnate\",\n    \"email\": \"nathan@tootallnate.net\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"tjholowaychuk\",\n      \"email\": \"tj@vision-media.ca\"\n    },\n    {\n      \"name\": \"tootallnate\",\n      \"email\": \"nathan@tootallnate.net\"\n    }\n  ],\n  \"dist\": {\n    \"shasum\": \"89bd9df6732b51256bc6705342bba02ed12131ef\",\n    \"tarball\": \"http://registry.npmjs.org/debug/-/debug-2.0.0.tgz\"\n  },\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/debug/-/debug-2.0.0.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/diff/diff.js": "/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\n(function(global, undefined) {\n  var objectPrototypeToString = Object.prototype.toString;\n\n  /*istanbul ignore next*/\n  function map(arr, mapper, that) {\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, mapper, that);\n    }\n\n    var other = new Array(arr.length);\n\n    for (var i = 0, n = arr.length; i < n; i++) {\n      other[i] = mapper.call(that, arr[i], i, arr);\n    }\n    return other;\n  }\n  function clonePath(path) {\n    return { newPos: path.newPos, components: path.components.slice(0) };\n  }\n  function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  }\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n\n    return n;\n  }\n\n  // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed.\n  function canonicalize(obj, stack, replacementStack) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else if (typeof obj === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n      var sortedKeys = [],\n          key;\n      for (key in obj) {\n        sortedKeys.push(key);\n      }\n      sortedKeys.sort();\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        key = sortedKeys[i];\n        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n  }\n\n  function buildValues(components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = map(value, function(value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n\n          component.value = value.join('');\n        } else {\n          component.value = newString.slice(newPos, newPos + component.count).join('');\n        }\n        newPos += component.count;\n\n        // Common case\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = oldString.slice(oldPos, oldPos + component.count).join('');\n        oldPos += component.count;\n\n        // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    }\n\n    return components;\n  }\n\n  function Diff(ignoreWhitespace) {\n    this.ignoreWhitespace = ignoreWhitespace;\n  }\n  Diff.prototype = {\n    diff: function(oldString, newString, callback) {\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function() { callback(undefined, value); }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      }\n\n      // Handle the identity case (this is due to unrolling editLength == 0\n      if (newString === oldString) {\n        return done([{ value: newString }]);\n      }\n      if (!newString) {\n        return done([{ value: oldString, removed: true }]);\n      }\n      if (!oldString) {\n        return done([{ value: newString, added: true }]);\n      }\n\n      newString = this.tokenize(newString);\n      oldString = this.tokenize(oldString);\n\n      var newLen = newString.length, oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{ newPos: -1, components: [] }];\n\n      // Seed editLength = 0, i.e. the content starts with the same values\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{value: newString.join('')}]);\n      }\n\n      // Main worker method. checks all permutations of a given edit length for acceptance.\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath;\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          }\n\n          // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath;   // No need to clone, we've pulled it from the list\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n          // If we have hit the end of both strings, then we are done\n          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      }\n\n      // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n      if (callback) {\n        (function exec() {\n          setTimeout(function() {\n            // This should not happen, but we want to be safe.\n            /*istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        }());\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n\n    pushComponent: function(components, added, removed) {\n      var last = components[components.length - 1];\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n      } else {\n        components.push({count: 1, added: added, removed: removed });\n      }\n    },\n    extractCommon: function(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n\n          commonCount = 0;\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({count: commonCount});\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n\n    equals: function(left, right) {\n      var reWhitespace = /\\S/;\n      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\n    },\n    tokenize: function(value) {\n      return value.split('');\n    }\n  };\n\n  var CharDiff = new Diff();\n\n  var WordDiff = new Diff(true);\n  var WordWithSpaceDiff = new Diff();\n  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\s+|\\b)/));\n  };\n\n  var CssDiff = new Diff(true);\n  CssDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/([{}:;,]|\\s+)/));\n  };\n\n  var LineDiff = new Diff();\n\n  var TrimmedLineDiff = new Diff();\n  TrimmedLineDiff.ignoreTrim = true;\n\n  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {\n    var retLines = [],\n        lines = value.split(/^/m);\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i],\n          lastLine = lines[i - 1],\n          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];\n\n      // Merge lines that may contain windows new lines\n      if (line === '\\n' && lastLineLastChar === '\\r') {\n          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\\r\\n';\n      } else {\n        if (this.ignoreTrim) {\n          line = line.trim();\n          // add a newline unless this is the last line.\n          if (i < lines.length - 1) {\n            line += '\\n';\n          }\n        }\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  var PatchDiff = new Diff();\n  PatchDiff.tokenize = function(value) {\n    var ret = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    }\n\n    // Merge the content and line separators into single tokens\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2) {\n        ret[ret.length - 1] += line;\n      } else {\n        ret.push(line);\n      }\n    }\n    return ret;\n  };\n\n  var SentenceDiff = new Diff();\n  SentenceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\S.+?[.!?])(?=\\s+|$)/));\n  };\n\n  var JsonDiff = new Diff();\n  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n  JsonDiff.useLongestToken = true;\n  JsonDiff.tokenize = LineDiff.tokenize;\n  JsonDiff.equals = function(left, right) {\n    return LineDiff.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  var JsDiff = {\n    Diff: Diff,\n\n    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },\n    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },\n    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },\n    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },\n    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },\n\n    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },\n\n    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },\n    diffJson: function(oldObj, newObj, callback) {\n      return JsonDiff.diff(\n        typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),\n        typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),\n        callback\n      );\n    },\n\n    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {\n      var ret = [];\n\n      if (oldFileName == newFileName) {\n        ret.push('Index: ' + oldFileName);\n      }\n      ret.push('===================================================================');\n      ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\\t' + oldHeader));\n      ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\\t' + newHeader));\n\n      var diff = PatchDiff.diff(oldStr, newStr);\n      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\n\n      // Formats a given set of lines for printing as context lines in a patch\n      function contextLines(lines) {\n        return map(lines, function(entry) { return ' ' + entry; });\n      }\n\n      // Outputs the no newline at end of file warning if needed\n      function eofNL(curRange, i, current) {\n        var last = diff[diff.length - 2],\n            isLast = i === diff.length - 2,\n            isLastOfType = i === diff.length - 3 && current.added !== last.added;\n\n        // Figure out if this is the last line for the given file and missing NL\n        if (!(/\\n$/.test(current.value)) && (isLast || isLastOfType)) {\n          curRange.push('\\\\ No newline at end of file');\n        }\n      }\n\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\n          oldLine = 1, newLine = 1;\n      for (var i = 0; i < diff.length; i++) {\n        var current = diff[i],\n            lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n        current.lines = lines;\n\n        if (current.added || current.removed) {\n          // If we have previous context, start with that\n          if (!oldRangeStart) {\n            var prev = diff[i - 1];\n            oldRangeStart = oldLine;\n            newRangeStart = newLine;\n\n            if (prev) {\n              curRange = contextLines(prev.lines.slice(-4));\n              oldRangeStart -= curRange.length;\n              newRangeStart -= curRange.length;\n            }\n          }\n\n          // Output our changes\n          curRange.push.apply(curRange, map(lines, function(entry) {\n            return (current.added ? '+' : '-') + entry;\n          }));\n          eofNL(curRange, i, current);\n\n          // Track the updated file position\n          if (current.added) {\n            newLine += lines.length;\n          } else {\n            oldLine += lines.length;\n          }\n        } else {\n          // Identical context lines. Track line changes\n          if (oldRangeStart) {\n            // Close out any changes that have been output (or join overlapping)\n            if (lines.length <= 8 && i < diff.length - 2) {\n              // Overlapping\n              curRange.push.apply(curRange, contextLines(lines));\n            } else {\n              // end the range and output\n              var contextSize = Math.min(lines.length, 4);\n              ret.push(\n                  '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)\n                  + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)\n                  + ' @@');\n              ret.push.apply(ret, curRange);\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\n              if (lines.length <= 4) {\n                eofNL(ret, i, current);\n              }\n\n              oldRangeStart = 0;\n              newRangeStart = 0;\n              curRange = [];\n            }\n          }\n          oldLine += lines.length;\n          newLine += lines.length;\n        }\n      }\n\n      return ret.join('\\n') + '\\n';\n    },\n\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\n      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);\n    },\n\n    applyPatch: function(oldStr, uniDiff) {\n      var diffstr = uniDiff.split('\\n'),\n          hunks = [],\n          i = 0,\n          remEOFNL = false,\n          addEOFNL = false;\n\n      // Skip to the first change hunk\n      while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {\n        i++;\n      }\n\n      // Parse the unified diff\n      for (; i < diffstr.length; i++) {\n        if (diffstr[i][0] === '@') {\n          var chnukHeader = diffstr[i].split(/@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@/);\n          hunks.unshift({\n            start: chnukHeader[3],\n            oldlength: +chnukHeader[2],\n            removed: [],\n            newlength: chnukHeader[4],\n            added: []\n          });\n        } else if (diffstr[i][0] === '+') {\n          hunks[0].added.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '-') {\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === ' ') {\n          hunks[0].added.push(diffstr[i].substr(1));\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '\\\\') {\n          if (diffstr[i - 1][0] === '+') {\n            remEOFNL = true;\n          } else if (diffstr[i - 1][0] === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n\n      // Apply the diff to the input\n      var lines = oldStr.split('\\n');\n      for (i = hunks.length - 1; i >= 0; i--) {\n        var hunk = hunks[i];\n        // Sanity check the input string. Bail if we don't match.\n        for (var j = 0; j < hunk.oldlength; j++) {\n          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {\n            return false;\n          }\n        }\n        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));\n      }\n\n      // Handle EOFNL insertion/removal\n      if (remEOFNL) {\n        while (!lines[lines.length - 1]) {\n          lines.pop();\n        }\n      } else if (addEOFNL) {\n        lines.push('');\n      }\n      return lines.join('\\n');\n    },\n\n    convertChangesToXML: function(changes) {\n      var ret = [];\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        if (change.added) {\n          ret.push('<ins>');\n        } else if (change.removed) {\n          ret.push('<del>');\n        }\n\n        ret.push(escapeHTML(change.value));\n\n        if (change.added) {\n          ret.push('</ins>');\n        } else if (change.removed) {\n          ret.push('</del>');\n        }\n      }\n      return ret.join('');\n    },\n\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n    convertChangesToDMP: function(changes) {\n      var ret = [],\n          change,\n          operation;\n      for (var i = 0; i < changes.length; i++) {\n        change = changes[i];\n        if (change.added) {\n          operation = 1;\n        } else if (change.removed) {\n          operation = -1;\n        } else {\n          operation = 0;\n        }\n\n        ret.push([operation, change.value]);\n      }\n      return ret;\n    },\n\n    canonicalize: canonicalize\n  };\n\n  /*istanbul ignore next */\n  /*global module */\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = JsDiff;\n  } else if (typeof define === 'function' && define.amd) {\n    /*global define */\n    define([], function() { return JsDiff; });\n  } else if (typeof global.JsDiff === 'undefined') {\n    global.JsDiff = JsDiff;\n  }\n}(this));\n",
  "node_modules/mocha/node_modules/diff/package.json": "{\n  \"name\": \"diff\",\n  \"version\": \"1.4.0\",\n  \"description\": \"A javascript text diff implementation.\",\n  \"keywords\": [\n    \"diff\",\n    \"javascript\"\n  ],\n  \"maintainers\": [\n    {\n      \"name\": \"kpdecker\",\n      \"email\": \"kpdecker@gmail.com\"\n    }\n  ],\n  \"bugs\": {\n    \"url\": \"http://github.com/kpdecker/jsdiff/issues\",\n    \"email\": \"kpdecker@gmail.com\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"BSD\",\n      \"url\": \"http://github.com/kpdecker/jsdiff/blob/master/LICENSE\"\n    }\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/kpdecker/jsdiff.git\"\n  },\n  \"engines\": {\n    \"node\": \">=0.3.1\"\n  },\n  \"main\": \"./diff\",\n  \"scripts\": {\n    \"test\": \"istanbul cover node_modules/.bin/_mocha test/*.js && istanbul check-coverage --statements 100 --functions 100 --branches 100 --lines 100 coverage/coverage.json\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"colors\": \"^1.1.0\",\n    \"istanbul\": \"^0.3.2\",\n    \"mocha\": \"^2.2.4\",\n    \"should\": \"^6.0.1\"\n  },\n  \"optionalDependencies\": {},\n  \"files\": [\n    \"diff.js\"\n  ],\n  \"gitHead\": \"27a750e9116e6ade6303bc24a9be72f6845e00ed\",\n  \"homepage\": \"https://github.com/kpdecker/jsdiff\",\n  \"_id\": \"diff@1.4.0\",\n  \"_shasum\": \"7f28d2eb9ee7b15a97efd89ce63dcfdaa3ccbabf\",\n  \"_from\": \"diff@1.4.0\",\n  \"_npmVersion\": \"1.4.28\",\n  \"_npmUser\": {\n    \"name\": \"kpdecker\",\n    \"email\": \"kpdecker@gmail.com\"\n  },\n  \"dist\": {\n    \"shasum\": \"7f28d2eb9ee7b15a97efd89ce63dcfdaa3ccbabf\",\n    \"tarball\": \"http://registry.npmjs.org/diff/-/diff-1.4.0.tgz\"\n  },\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/diff/-/diff-1.4.0.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/escape-string-regexp/index.js": "'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe,  '\\\\$&');\n};\n",
  "node_modules/mocha/node_modules/escape-string-regexp/package.json": "{\n  \"name\": \"escape-string-regexp\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Escape RegExp special characters\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/sindresorhus/escape-string-regexp.git\"\n  },\n  \"author\": {\n    \"name\": \"Sindre Sorhus\",\n    \"email\": \"sindresorhus@gmail.com\",\n    \"url\": \"http://sindresorhus.com\"\n  },\n  \"engines\": {\n    \"node\": \">=0.8.0\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"keywords\": [\n    \"regex\",\n    \"regexp\",\n    \"re\",\n    \"regular\",\n    \"expression\",\n    \"escape\",\n    \"string\",\n    \"str\",\n    \"special\",\n    \"characters\"\n  ],\n  \"devDependencies\": {\n    \"mocha\": \"*\"\n  },\n  \"gitHead\": \"0587ee0ee03ea3fcbfa3c15cf67b47f214e20987\",\n  \"bugs\": {\n    \"url\": \"https://github.com/sindresorhus/escape-string-regexp/issues\"\n  },\n  \"homepage\": \"https://github.com/sindresorhus/escape-string-regexp\",\n  \"_id\": \"escape-string-regexp@1.0.2\",\n  \"_shasum\": \"4dbc2fe674e71949caf3fb2695ce7f2dc1d9a8d1\",\n  \"_from\": \"escape-string-regexp@1.0.2\",\n  \"_npmVersion\": \"1.4.23\",\n  \"_npmUser\": {\n    \"name\": \"jbnicolai\",\n    \"email\": \"jappelman@xebia.com\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"sindresorhus\",\n      \"email\": \"sindresorhus@gmail.com\"\n    },\n    {\n      \"name\": \"jbnicolai\",\n      \"email\": \"jappelman@xebia.com\"\n    }\n  ],\n  \"dist\": {\n    \"shasum\": \"4dbc2fe674e71949caf3fb2695ce7f2dc1d9a8d1\",\n    \"tarball\": \"http://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.2.tgz\"\n  },\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.2.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/glob/examples/g.js": "var Glob = require(\"../\").Glob\n\nvar pattern = \"test/a/**/[cg]/../[cg]\"\nconsole.log(pattern)\n\nvar mg = new Glob(pattern, {mark: true, sync:true}, function (er, matches) {\n  console.log(\"matches\", matches)\n})\nconsole.log(\"after\")\n",
  "node_modules/mocha/node_modules/glob/examples/usr-local.js": "var Glob = require(\"../\").Glob\n\nvar pattern = \"{./*/*,/*,/usr/local/*}\"\nconsole.log(pattern)\n\nvar mg = new Glob(pattern, {mark: true}, function (er, matches) {\n  console.log(\"matches\", matches)\n})\nconsole.log(\"after\")\n",
  "node_modules/mocha/node_modules/glob/glob.js": "// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n// readdir(PREFIX) as ENTRIES\n//   If fails, END\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $])\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $])\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\n\n\nmodule.exports = glob\n\nvar fs = require(\"graceful-fs\")\n, minimatch = require(\"minimatch\")\n, Minimatch = minimatch.Minimatch\n, inherits = require(\"inherits\")\n, EE = require(\"events\").EventEmitter\n, path = require(\"path\")\n, isDir = {}\n, assert = require(\"assert\").ok\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === \"function\") cb = options, options = {}\n  if (!options) options = {}\n\n  if (typeof options === \"number\") {\n    deprecated()\n    return\n  }\n\n  var g = new Glob(pattern, options, cb)\n  return g.sync ? g.found : g\n}\n\nglob.fnmatch = deprecated\n\nfunction deprecated () {\n  throw new Error(\"glob's interface has changed. Please see the docs.\")\n}\n\nglob.sync = globSync\nfunction globSync (pattern, options) {\n  if (typeof options === \"number\") {\n    deprecated()\n    return\n  }\n\n  options = options || {}\n  options.sync = true\n  return glob(pattern, options)\n}\n\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (!(this instanceof Glob)) {\n    return new Glob(pattern, options, cb)\n  }\n\n  if (typeof cb === \"function\") {\n    this.on(\"error\", cb)\n    this.on(\"end\", function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  options = options || {}\n\n  this.EOF = {}\n  this._emitQueue = []\n\n  this.maxDepth = options.maxDepth || 1000\n  this.maxLength = options.maxLength || Infinity\n  this.cache = options.cache || {}\n  this.statCache = options.statCache || {}\n\n  this.changedCwd = false\n  var cwd = process.cwd()\n  if (!options.hasOwnProperty(\"cwd\")) this.cwd = cwd\n  else {\n    this.cwd = options.cwd\n    this.changedCwd = path.resolve(options.cwd) !== cwd\n  }\n\n  this.root = options.root || path.resolve(this.cwd, \"/\")\n  this.root = path.resolve(this.root)\n  if (process.platform === \"win32\")\n    this.root = this.root.replace(/\\\\/g, \"/\")\n\n  this.nomount = !!options.nomount\n\n  if (!pattern) {\n    throw new Error(\"must provide pattern\")\n  }\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  this.strict = options.strict !== false\n  this.dot = !!options.dot\n  this.mark = !!options.mark\n  this.sync = !!options.sync\n  this.nounique = !!options.nounique\n  this.nonull = !!options.nonull\n  this.nosort = !!options.nosort\n  this.nocase = !!options.nocase\n  this.stat = !!options.stat\n\n  this.debug = !!options.debug || !!options.globDebug\n  if (this.debug)\n    this.log = console.error\n\n  this.silent = !!options.silent\n\n  var mm = this.minimatch = new Minimatch(pattern, options)\n  this.options = mm.options\n  pattern = this.pattern = mm.pattern\n\n  this.error = null\n  this.aborted = false\n\n  // list of all the patterns that ** has resolved do, so\n  // we can avoid visiting multiple times.\n  this._globstars = {}\n\n  EE.call(this)\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  this.minimatch.set.forEach(iterator.bind(this))\n  function iterator (pattern, i, set) {\n    this._process(pattern, 0, i, function (er) {\n      if (er) this.emit(\"error\", er)\n      if (-- n <= 0) this._finish()\n    })\n  }\n}\n\nGlob.prototype.log = function () {}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n\n  var nou = this.nounique\n  , all = nou ? [] : {}\n\n  for (var i = 0, l = this.matches.length; i < l; i ++) {\n    var matches = this.matches[i]\n    this.log(\"matches[%d] =\", i, matches)\n    // do like the shell, and spit out the literal glob\n    if (!matches) {\n      if (this.nonull) {\n        var literal = this.minimatch.globSet[i]\n        if (nou) all.push(literal)\n        else all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou) all.push.apply(all, m)\n      else m.forEach(function (m) {\n        all[m] = true\n      })\n    }\n  }\n\n  if (!nou) all = Object.keys(all)\n\n  if (!this.nosort) {\n    all = all.sort(this.nocase ? alphasorti : alphasort)\n  }\n\n  if (this.mark) {\n    // at *some* point we statted all of these\n    all = all.map(function (m) {\n      var sc = this.cache[m]\n      if (!sc)\n        return m\n      var isDir = (Array.isArray(sc) || sc === 2)\n      if (isDir && m.slice(-1) !== \"/\") {\n        return m + \"/\"\n      }\n      if (!isDir && m.slice(-1) === \"/\") {\n        return m.replace(/\\/+$/, \"\")\n      }\n      return m\n    }, this)\n  }\n\n  this.log(\"emitting end\", all)\n\n  this.EOF = this.found = all\n  this.emitMatch(this.EOF)\n}\n\nfunction alphasorti (a, b) {\n  a = a.toLowerCase()\n  b = b.toLowerCase()\n  return alphasort(a, b)\n}\n\nfunction alphasort (a, b) {\n  return a > b ? 1 : a < b ? -1 : 0\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit(\"abort\")\n}\n\nGlob.prototype.pause = function () {\n  if (this.paused) return\n  if (this.sync)\n    this.emit(\"error\", new Error(\"Can't pause/resume sync glob\"))\n  this.paused = true\n  this.emit(\"pause\")\n}\n\nGlob.prototype.resume = function () {\n  if (!this.paused) return\n  if (this.sync)\n    this.emit(\"error\", new Error(\"Can't pause/resume sync glob\"))\n  this.paused = false\n  this.emit(\"resume\")\n  this._processEmitQueue()\n  //process.nextTick(this.emit.bind(this, \"resume\"))\n}\n\nGlob.prototype.emitMatch = function (m) {\n  if (!this.stat || this.statCache[m] || m === this.EOF) {\n    this._emitQueue.push(m)\n    this._processEmitQueue()\n  } else {\n    this._stat(m, function(exists, isDir) {\n      if (exists) {\n        this._emitQueue.push(m)\n        this._processEmitQueue()\n      }\n    })\n  }\n}\n\nGlob.prototype._processEmitQueue = function (m) {\n  while (!this._processingEmitQueue &&\n         !this.paused) {\n    this._processingEmitQueue = true\n    var m = this._emitQueue.shift()\n    if (!m) {\n      this._processingEmitQueue = false\n      break\n    }\n\n    this.log('emit!', m === this.EOF ? \"end\" : \"match\")\n\n    this.emit(m === this.EOF ? \"end\" : \"match\", m)\n    this._processingEmitQueue = false\n  }\n}\n\nGlob.prototype._process = function (pattern, depth, index, cb_) {\n  assert(this instanceof Glob)\n\n  var cb = function cb (er, res) {\n    assert(this instanceof Glob)\n    if (this.paused) {\n      if (!this._processQueue) {\n        this._processQueue = []\n        this.once(\"resume\", function () {\n          var q = this._processQueue\n          this._processQueue = null\n          q.forEach(function (cb) { cb() })\n        })\n      }\n      this._processQueue.push(cb_.bind(this, er, res))\n    } else {\n      cb_.call(this, er, res)\n    }\n  }.bind(this)\n\n  if (this.aborted) return cb()\n\n  if (depth > this.maxDepth) return cb()\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === \"string\") {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      prefix = pattern.join(\"/\")\n      this._stat(prefix, function (exists, isDir) {\n        // either it's there, or it isn't.\n        // nothing more to do, either way.\n        if (exists) {\n          if (prefix && isAbsolute(prefix) && !this.nomount) {\n            if (prefix.charAt(0) === \"/\") {\n              prefix = path.join(this.root, prefix)\n            } else {\n              prefix = path.resolve(this.root, prefix)\n            }\n          }\n\n          if (process.platform === \"win32\")\n            prefix = prefix.replace(/\\\\/g, \"/\")\n\n          this.matches[index] = this.matches[index] || {}\n          this.matches[index][prefix] = true\n          this.emitMatch(prefix)\n        }\n        return cb()\n      })\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's \"absolute\" like /foo/bar,\n      // or \"relative\" like \"../baz\"\n      prefix = pattern.slice(0, n)\n      prefix = prefix.join(\"/\")\n      break\n  }\n\n  // get the list of entries.\n  var read\n  if (prefix === null) read = \".\"\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join(\"/\"))) {\n    if (!prefix || !isAbsolute(prefix)) {\n      prefix = path.join(\"/\", prefix)\n    }\n    read = prefix = path.resolve(prefix)\n\n    // if (process.platform === \"win32\")\n    //   read = prefix = prefix.replace(/^[a-zA-Z]:|\\\\/g, \"/\")\n\n    this.log('absolute: ', prefix, this.root, pattern, read)\n  } else {\n    read = prefix\n  }\n\n  this.log('readdir(%j)', read, this.cwd, this.root)\n\n  return this._readdir(read, function (er, entries) {\n    if (er) {\n      // not a directory!\n      // this means that, whatever else comes after this, it can never match\n      return cb()\n    }\n\n    // globstar is special\n    if (pattern[n] === minimatch.GLOBSTAR) {\n      // test without the globstar, and with every child both below\n      // and replacing the globstar.\n      var s = [ pattern.slice(0, n).concat(pattern.slice(n + 1)) ]\n      entries.forEach(function (e) {\n        if (e.charAt(0) === \".\" && !this.dot) return\n        // instead of the globstar\n        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1)))\n        // below the globstar\n        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n)))\n      }, this)\n\n      s = s.filter(function (pattern) {\n        var key = gsKey(pattern)\n        var seen = !this._globstars[key]\n        this._globstars[key] = true\n        return seen\n      }, this)\n\n      if (!s.length)\n        return cb()\n\n      // now asyncForEach over this\n      var l = s.length\n      , errState = null\n      s.forEach(function (gsPattern) {\n        this._process(gsPattern, depth + 1, index, function (er) {\n          if (errState) return\n          if (er) return cb(errState = er)\n          if (--l <= 0) return cb()\n        })\n      }, this)\n\n      return\n    }\n\n    // not a globstar\n    // It will only match dot entries if it starts with a dot, or if\n    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n    var pn = pattern[n]\n    var rawGlob = pattern[n]._glob\n    , dotOk = this.dot || rawGlob.charAt(0) === \".\"\n\n    entries = entries.filter(function (e) {\n      return (e.charAt(0) !== \".\" || dotOk) &&\n             e.match(pattern[n])\n    })\n\n    // If n === pattern.length - 1, then there's no need for the extra stat\n    // *unless* the user has specified \"mark\" or \"stat\" explicitly.\n    // We know that they exist, since the readdir returned them.\n    if (n === pattern.length - 1 &&\n        !this.mark &&\n        !this.stat) {\n      entries.forEach(function (e) {\n        if (prefix) {\n          if (prefix !== \"/\") e = prefix + \"/\" + e\n          else e = prefix + e\n        }\n        if (e.charAt(0) === \"/\" && !this.nomount) {\n          e = path.join(this.root, e)\n        }\n\n        if (process.platform === \"win32\")\n          e = e.replace(/\\\\/g, \"/\")\n\n        this.matches[index] = this.matches[index] || {}\n        this.matches[index][e] = true\n        this.emitMatch(e)\n      }, this)\n      return cb.call(this)\n    }\n\n\n    // now test all the remaining entries as stand-ins for that part\n    // of the pattern.\n    var l = entries.length\n    , errState = null\n    if (l === 0) return cb() // no matches possible\n    entries.forEach(function (e) {\n      var p = pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1))\n      this._process(p, depth + 1, index, function (er) {\n        if (errState) return\n        if (er) return cb(errState = er)\n        if (--l === 0) return cb.call(this)\n      })\n    }, this)\n  })\n\n}\n\nfunction gsKey (pattern) {\n  return '**' + pattern.map(function (p) {\n    return (p === minimatch.GLOBSTAR) ? '**' : (''+p)\n  }).join('/')\n}\n\nGlob.prototype._stat = function (f, cb) {\n  assert(this instanceof Glob)\n  var abs = f\n  if (f.charAt(0) === \"/\") {\n    abs = path.join(this.root, f)\n  } else if (this.changedCwd) {\n    abs = path.resolve(this.cwd, f)\n  }\n\n  if (f.length > this.maxLength) {\n    var er = new Error(\"Path name too long\")\n    er.code = \"ENAMETOOLONG\"\n    er.path = f\n    return this._afterStat(f, abs, cb, er)\n  }\n\n  this.log('stat', [this.cwd, f, '=', abs])\n\n  if (!this.stat && this.cache.hasOwnProperty(f)) {\n    var exists = this.cache[f]\n    , isDir = exists && (Array.isArray(exists) || exists === 2)\n    if (this.sync) return cb.call(this, !!exists, isDir)\n    return process.nextTick(cb.bind(this, !!exists, isDir))\n  }\n\n  var stat = this.statCache[abs]\n  if (this.sync || stat) {\n    var er\n    try {\n      stat = fs.statSync(abs)\n    } catch (e) {\n      er = e\n    }\n    this._afterStat(f, abs, cb, er, stat)\n  } else {\n    fs.stat(abs, this._afterStat.bind(this, f, abs, cb))\n  }\n}\n\nGlob.prototype._afterStat = function (f, abs, cb, er, stat) {\n  var exists\n  assert(this instanceof Glob)\n\n  if (abs.slice(-1) === \"/\" && stat && !stat.isDirectory()) {\n    this.log(\"should be ENOTDIR, fake it\")\n\n    er = new Error(\"ENOTDIR, not a directory '\" + abs + \"'\")\n    er.path = abs\n    er.code = \"ENOTDIR\"\n    stat = null\n  }\n\n  var emit = !this.statCache[abs]\n  this.statCache[abs] = stat\n\n  if (er || !stat) {\n    exists = false\n  } else {\n    exists = stat.isDirectory() ? 2 : 1\n    if (emit)\n      this.emit('stat', f, stat)\n  }\n  this.cache[f] = this.cache[f] || exists\n  cb.call(this, !!exists, exists === 2)\n}\n\nGlob.prototype._readdir = function (f, cb) {\n  assert(this instanceof Glob)\n  var abs = f\n  if (f.charAt(0) === \"/\") {\n    abs = path.join(this.root, f)\n  } else if (isAbsolute(f)) {\n    abs = f\n  } else if (this.changedCwd) {\n    abs = path.resolve(this.cwd, f)\n  }\n\n  if (f.length > this.maxLength) {\n    var er = new Error(\"Path name too long\")\n    er.code = \"ENAMETOOLONG\"\n    er.path = f\n    return this._afterReaddir(f, abs, cb, er)\n  }\n\n  this.log('readdir', [this.cwd, f, abs])\n  if (this.cache.hasOwnProperty(f)) {\n    var c = this.cache[f]\n    if (Array.isArray(c)) {\n      if (this.sync) return cb.call(this, null, c)\n      return process.nextTick(cb.bind(this, null, c))\n    }\n\n    if (!c || c === 1) {\n      // either ENOENT or ENOTDIR\n      var code = c ? \"ENOTDIR\" : \"ENOENT\"\n      , er = new Error((c ? \"Not a directory\" : \"Not found\") + \": \" + f)\n      er.path = f\n      er.code = code\n      this.log(f, er)\n      if (this.sync) return cb.call(this, er)\n      return process.nextTick(cb.bind(this, er))\n    }\n\n    // at this point, c === 2, meaning it's a dir, but we haven't\n    // had to read it yet, or c === true, meaning it's *something*\n    // but we don't have any idea what.  Need to read it, either way.\n  }\n\n  if (this.sync) {\n    var er, entries\n    try {\n      entries = fs.readdirSync(abs)\n    } catch (e) {\n      er = e\n    }\n    return this._afterReaddir(f, abs, cb, er, entries)\n  }\n\n  fs.readdir(abs, this._afterReaddir.bind(this, f, abs, cb))\n}\n\nGlob.prototype._afterReaddir = function (f, abs, cb, er, entries) {\n  assert(this instanceof Glob)\n  if (entries && !er) {\n    this.cache[f] = entries\n    // if we haven't asked to stat everything for suresies, then just\n    // assume that everything in there exists, so we can avoid\n    // having to stat it a second time.  This also gets us one step\n    // further into ELOOP territory.\n    if (!this.mark && !this.stat) {\n      entries.forEach(function (e) {\n        if (f === \"/\") e = f + e\n        else e = f + \"/\" + e\n        this.cache[e] = true\n      }, this)\n    }\n\n    return cb.call(this, er, entries)\n  }\n\n  // now handle errors, and cache the information\n  if (er) switch (er.code) {\n    case \"ENOTDIR\": // totally normal. means it *does* exist.\n      this.cache[f] = 1\n      return cb.call(this, er)\n    case \"ENOENT\": // not terribly unusual\n    case \"ELOOP\":\n    case \"ENAMETOOLONG\":\n    case \"UNKNOWN\":\n      this.cache[f] = false\n      return cb.call(this, er)\n    default: // some unusual error.  Treat as failure.\n      this.cache[f] = false\n      if (this.strict) this.emit(\"error\", er)\n      if (!this.silent) console.error(\"glob error\", er)\n      return cb.call(this, er)\n  }\n}\n\nvar isAbsolute = process.platform === \"win32\" ? absWin : absUnix\n\nfunction absWin (p) {\n  if (absUnix(p)) return true\n  // pull off the device/UNC bit from a windows path.\n  // from node's lib/path.js\n  var splitDeviceRe =\n      /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/\n    , result = splitDeviceRe.exec(p)\n    , device = result[1] || ''\n    , isUnc = device && device.charAt(1) !== ':'\n    , isAbsolute = !!result[2] || isUnc // UNC paths are always absolute\n\n  return isAbsolute\n}\n\nfunction absUnix (p) {\n  return p.charAt(0) === \"/\" || p === \"\"\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/graceful-fs/graceful-fs.js": "// Monkey-patching the fs module.\n// It's ugly, but there is simply no other way to do this.\nvar fs = module.exports = require('fs')\n\nvar assert = require('assert')\n\n// fix up some busted stuff, mostly on windows and old nodes\nrequire('./polyfills.js')\n\n// The EMFILE enqueuing stuff\n\nvar util = require('util')\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs')\nelse if (/\\bgfs\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS: ' + m.split(/\\n/).join('\\nGFS: ')\n    console.error(m)\n  }\n\nif (/\\bgfs\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug('fds', fds)\n    debug(queue)\n    assert.equal(queue.length, 0)\n  })\n}\n\n\nvar originalOpen = fs.open\nfs.open = open\n\nfunction open(path, flags, mode, cb) {\n  if (typeof mode === \"function\") cb = mode, mode = null\n  if (typeof cb !== \"function\") cb = noop\n  new OpenReq(path, flags, mode, cb)\n}\n\nfunction OpenReq(path, flags, mode, cb) {\n  this.path = path\n  this.flags = flags\n  this.mode = mode\n  this.cb = cb\n  Req.call(this)\n}\n\nutil.inherits(OpenReq, Req)\n\nOpenReq.prototype.process = function() {\n  originalOpen.call(fs, this.path, this.flags, this.mode, this.done)\n}\n\nvar fds = {}\nOpenReq.prototype.done = function(er, fd) {\n  debug('open done', er, fd)\n  if (fd)\n    fds['fd' + fd] = this.path\n  Req.prototype.done.call(this, er, fd)\n}\n\n\nvar originalReaddir = fs.readdir\nfs.readdir = readdir\n\nfunction readdir(path, cb) {\n  if (typeof cb !== \"function\") cb = noop\n  new ReaddirReq(path, cb)\n}\n\nfunction ReaddirReq(path, cb) {\n  this.path = path\n  this.cb = cb\n  Req.call(this)\n}\n\nutil.inherits(ReaddirReq, Req)\n\nReaddirReq.prototype.process = function() {\n  originalReaddir.call(fs, this.path, this.done)\n}\n\nReaddirReq.prototype.done = function(er, files) {\n  if (files && files.sort)\n    files = files.sort()\n  Req.prototype.done.call(this, er, files)\n  onclose()\n}\n\n\nvar originalClose = fs.close\nfs.close = close\n\nfunction close (fd, cb) {\n  debug('close', fd)\n  if (typeof cb !== \"function\") cb = noop\n  delete fds['fd' + fd]\n  originalClose.call(fs, fd, function(er) {\n    onclose()\n    cb(er)\n  })\n}\n\n\nvar originalCloseSync = fs.closeSync\nfs.closeSync = closeSync\n\nfunction closeSync (fd) {\n  try {\n    return originalCloseSync(fd)\n  } finally {\n    onclose()\n  }\n}\n\n\n// Req class\nfunction Req () {\n  // start processing\n  this.done = this.done.bind(this)\n  this.failures = 0\n  this.process()\n}\n\nReq.prototype.done = function (er, result) {\n  var tryAgain = false\n  if (er) {\n    var code = er.code\n    var tryAgain = code === \"EMFILE\"\n    if (process.platform === \"win32\")\n      tryAgain = tryAgain || code === \"OK\"\n  }\n\n  if (tryAgain) {\n    this.failures ++\n    enqueue(this)\n  } else {\n    var cb = this.cb\n    cb(er, result)\n  }\n}\n\nvar queue = []\n\nfunction enqueue(req) {\n  queue.push(req)\n  debug('enqueue %d %s', queue.length, req.constructor.name, req)\n}\n\nfunction onclose() {\n  var req = queue.shift()\n  if (req) {\n    debug('process', req.constructor.name, req)\n    req.process()\n  }\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/graceful-fs/package.json": "{\n  \"author\": {\n    \"name\": \"Isaac Z. Schlueter\",\n    \"email\": \"i@izs.me\",\n    \"url\": \"http://blog.izs.me\"\n  },\n  \"name\": \"graceful-fs\",\n  \"description\": \"A drop-in replacement for fs, making various improvements.\",\n  \"version\": \"2.0.3\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/isaacs/node-graceful-fs.git\"\n  },\n  \"main\": \"graceful-fs.js\",\n  \"engines\": {\n    \"node\": \">=0.4.0\"\n  },\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"test\": \"tap test/*.js\"\n  },\n  \"keywords\": [\n    \"fs\",\n    \"module\",\n    \"reading\",\n    \"retry\",\n    \"retries\",\n    \"queue\",\n    \"error\",\n    \"errors\",\n    \"handling\",\n    \"EMFILE\",\n    \"EAGAIN\",\n    \"EINVAL\",\n    \"EPERM\",\n    \"EACCESS\"\n  ],\n  \"license\": \"BSD\",\n  \"bugs\": {\n    \"url\": \"https://github.com/isaacs/node-graceful-fs/issues\"\n  },\n  \"homepage\": \"https://github.com/isaacs/node-graceful-fs\",\n  \"_id\": \"graceful-fs@2.0.3\",\n  \"dist\": {\n    \"shasum\": \"7cd2cdb228a4a3f36e95efa6cc142de7d1a136d0\",\n    \"tarball\": \"http://registry.npmjs.org/graceful-fs/-/graceful-fs-2.0.3.tgz\"\n  },\n  \"_from\": \"graceful-fs@>=2.0.0 <2.1.0\",\n  \"_npmVersion\": \"1.4.6\",\n  \"_npmUser\": {\n    \"name\": \"isaacs\",\n    \"email\": \"i@izs.me\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"isaacs\",\n      \"email\": \"i@izs.me\"\n    }\n  ],\n  \"_shasum\": \"7cd2cdb228a4a3f36e95efa6cc142de7d1a136d0\",\n  \"_resolved\": \"https://registry.npmjs.org/graceful-fs/-/graceful-fs-2.0.3.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/graceful-fs/polyfills.js": "var fs = require('fs')\nvar constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\n// (re-)implement some things that are known busted or missing.\n\n// lchmod, broken prior to 0.6.2\n// back-port the fix here.\nif (constants.hasOwnProperty('O_SYMLINK') &&\n    process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n  fs.lchmod = function (path, mode, callback) {\n    callback = callback || noop\n    fs.open( path\n           , constants.O_WRONLY | constants.O_SYMLINK\n           , mode\n           , function (err, fd) {\n      if (err) {\n        callback(err)\n        return\n      }\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      fs.fchmod(fd, mode, function (err) {\n        fs.close(fd, function(err2) {\n          callback(err || err2)\n        })\n      })\n    })\n  }\n\n  fs.lchmodSync = function (path, mode) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n    // prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    var err, err2\n    try {\n      var ret = fs.fchmodSync(fd, mode)\n    } catch (er) {\n      err = er\n    }\n    try {\n      fs.closeSync(fd)\n    } catch (er) {\n      err2 = er\n    }\n    if (err || err2) throw (err || err2)\n    return ret\n  }\n}\n\n\n// lutimes implementation, or no-op\nif (!fs.lutimes) {\n  if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n    fs.lutimes = function (path, at, mt, cb) {\n      fs.open(path, constants.O_SYMLINK, function (er, fd) {\n        cb = cb || noop\n        if (er) return cb(er)\n        fs.futimes(fd, at, mt, function (er) {\n          fs.close(fd, function (er2) {\n            return cb(er || er2)\n          })\n        })\n      })\n    }\n\n    fs.lutimesSync = function (path, at, mt) {\n      var fd = fs.openSync(path, constants.O_SYMLINK)\n        , err\n        , err2\n        , ret\n\n      try {\n        var ret = fs.futimesSync(fd, at, mt)\n      } catch (er) {\n        err = er\n      }\n      try {\n        fs.closeSync(fd)\n      } catch (er) {\n        err2 = er\n      }\n      if (err || err2) throw (err || err2)\n      return ret\n    }\n\n  } else if (fs.utimensat && constants.hasOwnProperty(\"AT_SYMLINK_NOFOLLOW\")) {\n    // maybe utimensat will be bound soonish?\n    fs.lutimes = function (path, at, mt, cb) {\n      fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)\n    }\n\n    fs.lutimesSync = function (path, at, mt) {\n      return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)\n    }\n\n  } else {\n    fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }\n    fs.lutimesSync = function () {}\n  }\n}\n\n\n// https://github.com/isaacs/node-graceful-fs/issues/4\n// Chown should not fail on einval or eperm if non-root.\n\nfs.chown = chownFix(fs.chown)\nfs.fchown = chownFix(fs.fchown)\nfs.lchown = chownFix(fs.lchown)\n\nfs.chownSync = chownFixSync(fs.chownSync)\nfs.fchownSync = chownFixSync(fs.fchownSync)\nfs.lchownSync = chownFixSync(fs.lchownSync)\n\nfunction chownFix (orig) {\n  if (!orig) return orig\n  return function (target, uid, gid, cb) {\n    return orig.call(fs, target, uid, gid, function (er, res) {\n      if (chownErOk(er)) er = null\n      cb(er, res)\n    })\n  }\n}\n\nfunction chownFixSync (orig) {\n  if (!orig) return orig\n  return function (target, uid, gid) {\n    try {\n      return orig.call(fs, target, uid, gid)\n    } catch (er) {\n      if (!chownErOk(er)) throw er\n    }\n  }\n}\n\nfunction chownErOk (er) {\n  // if there's no getuid, or if getuid() is something other than 0,\n  // and the error is EINVAL or EPERM, then just ignore it.\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  // When running as root, or if other types of errors are encountered,\n  // then it's strict.\n  if (!er || (!process.getuid || process.getuid() !== 0)\n      && (er.code === \"EINVAL\" || er.code === \"EPERM\")) return true\n}\n\n\n// if lchmod/lchown do not exist, then make them no-ops\nif (!fs.lchmod) {\n  fs.lchmod = function (path, mode, cb) {\n    process.nextTick(cb)\n  }\n  fs.lchmodSync = function () {}\n}\nif (!fs.lchown) {\n  fs.lchown = function (path, uid, gid, cb) {\n    process.nextTick(cb)\n  }\n  fs.lchownSync = function () {}\n}\n\n\n\n// on Windows, A/V software can lock the directory, causing this\n// to fail with an EACCES or EPERM if the directory contains newly\n// created files.  Try again on failure, for up to 1 second.\nif (process.platform === \"win32\") {\n  var rename_ = fs.rename\n  fs.rename = function rename (from, to, cb) {\n    var start = Date.now()\n    rename_(from, to, function CB (er) {\n      if (er\n          && (er.code === \"EACCES\" || er.code === \"EPERM\")\n          && Date.now() - start < 1000) {\n        return rename_(from, to, CB)\n      }\n      cb(er)\n    })\n  }\n}\n\n\n// if read() returns EAGAIN, then just try it again.\nvar read = fs.read\nfs.read = function (fd, buffer, offset, length, position, callback_) {\n  var callback\n  if (callback_ && typeof callback_ === 'function') {\n    var eagCounter = 0\n    callback = function (er, _, __) {\n      if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n        eagCounter ++\n        return read.call(fs, fd, buffer, offset, length, position, callback)\n      }\n      callback_.apply(this, arguments)\n    }\n  }\n  return read.call(fs, fd, buffer, offset, length, position, callback)\n}\n\nvar readSync = fs.readSync\nfs.readSync = function (fd, buffer, offset, length, position) {\n  var eagCounter = 0\n  while (true) {\n    try {\n      return readSync.call(fs, fd, buffer, offset, length, position)\n    } catch (er) {\n      if (er.code === 'EAGAIN' && eagCounter < 10) {\n        eagCounter ++\n        continue\n      }\n      throw er\n    }\n  }\n}\n\n",
  "node_modules/mocha/node_modules/glob/node_modules/graceful-fs/test/open.js": "var test = require('tap').test\nvar fs = require('../graceful-fs.js')\n\ntest('graceful fs is monkeypatched fs', function (t) {\n  t.equal(fs, require('fs'))\n  t.end()\n})\n\ntest('open an existing file works', function (t) {\n  var fd = fs.openSync(__filename, 'r')\n  fs.closeSync(fd)\n  fs.open(__filename, 'r', function (er, fd) {\n    if (er) throw er\n    fs.close(fd, function (er) {\n      if (er) throw er\n      t.pass('works')\n      t.end()\n    })\n  })\n})\n\ntest('open a non-existing file throws', function (t) {\n  var er\n  try {\n    var fd = fs.openSync('this file does not exist', 'r')\n  } catch (x) {\n    er = x\n  }\n  t.ok(er, 'should throw')\n  t.notOk(fd, 'should not get an fd')\n  t.equal(er.code, 'ENOENT')\n\n  fs.open('neither does this file', 'r', function (er, fd) {\n    t.ok(er, 'should throw')\n    t.notOk(fd, 'should not get an fd')\n    t.equal(er.code, 'ENOENT')\n    t.end()\n  })\n})\n",
  "node_modules/mocha/node_modules/glob/node_modules/graceful-fs/test/readdir-sort.js": "var test = require(\"tap\").test\nvar fs = require(\"fs\")\n\nvar readdir = fs.readdir\nfs.readdir = function(path, cb) {\n  process.nextTick(function() {\n    cb(null, [\"b\", \"z\", \"a\"])\n  })\n}\n\nvar g = require(\"../\")\n\ntest(\"readdir reorder\", function (t) {\n  g.readdir(\"whatevers\", function (er, files) {\n    if (er)\n      throw er\n    console.error(files)\n    t.same(files, [ \"a\", \"b\", \"z\" ])\n    t.end()\n  })\n})\n",
  "node_modules/mocha/node_modules/glob/node_modules/inherits/inherits_browser.js": "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/inherits/inherits.js": "module.exports = require('util').inherits\n",
  "node_modules/mocha/node_modules/glob/node_modules/inherits/package.json": "{\n  \"name\": \"inherits\",\n  \"description\": \"Browser-friendly inheritance fully compatible with standard node.js inherits()\",\n  \"version\": \"2.0.1\",\n  \"keywords\": [\n    \"inheritance\",\n    \"class\",\n    \"klass\",\n    \"oop\",\n    \"object-oriented\",\n    \"inherits\",\n    \"browser\",\n    \"browserify\"\n  ],\n  \"main\": \"./inherits.js\",\n  \"browser\": \"./inherits_browser.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/isaacs/inherits.git\"\n  },\n  \"license\": \"ISC\",\n  \"scripts\": {\n    \"test\": \"node test\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/isaacs/inherits/issues\"\n  },\n  \"_id\": \"inherits@2.0.1\",\n  \"dist\": {\n    \"shasum\": \"b17d08d326b4423e568eff719f91b0b1cbdf69f1\",\n    \"tarball\": \"http://registry.npmjs.org/inherits/-/inherits-2.0.1.tgz\"\n  },\n  \"_from\": \"inherits@>=2.0.0 <3.0.0\",\n  \"_npmVersion\": \"1.3.8\",\n  \"_npmUser\": {\n    \"name\": \"isaacs\",\n    \"email\": \"i@izs.me\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"isaacs\",\n      \"email\": \"i@izs.me\"\n    }\n  ],\n  \"directories\": {},\n  \"_shasum\": \"b17d08d326b4423e568eff719f91b0b1cbdf69f1\",\n  \"_resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.1.tgz\",\n  \"readme\": \"ERROR: No README data found!\",\n  \"homepage\": \"https://github.com/isaacs/inherits#readme\"\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/inherits/test.js": "var inherits = require('./inherits.js')\nvar assert = require('assert')\n\nfunction test(c) {\n  assert(c.constructor === Child)\n  assert(c.constructor.super_ === Parent)\n  assert(Object.getPrototypeOf(c) === Child.prototype)\n  assert(Object.getPrototypeOf(Object.getPrototypeOf(c)) === Parent.prototype)\n  assert(c instanceof Child)\n  assert(c instanceof Parent)\n}\n\nfunction Child() {\n  Parent.call(this)\n  test(this)\n}\n\nfunction Parent() {}\n\ninherits(Child, Parent)\n\nvar c = new Child\ntest(c)\n\nconsole.log('ok')\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/minimatch.js": ";(function (require, exports, module, platform) {\n\nif (module) module.exports = minimatch\nelse exports.minimatch = minimatch\n\nif (!require) {\n  require = function (id) {\n    switch (id) {\n      case \"sigmund\": return function sigmund (obj) {\n        return JSON.stringify(obj)\n      }\n      case \"path\": return { basename: function (f) {\n        f = f.split(/[\\/\\\\]/)\n        var e = f.pop()\n        if (!e) e = f.pop()\n        return e\n      }}\n      case \"lru-cache\": return function LRUCache () {\n        // not quite an LRU, but still space-limited.\n        var cache = {}\n        var cnt = 0\n        this.set = function (k, v) {\n          cnt ++\n          if (cnt >= 100) cache = {}\n          cache[k] = v\n        }\n        this.get = function (k) { return cache[k] }\n      }\n    }\n  }\n}\n\nminimatch.Minimatch = Minimatch\n\nvar LRU = require(\"lru-cache\")\n  , cache = minimatch.cache = new LRU({max: 100})\n  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\n  , sigmund = require(\"sigmund\")\n\nvar path = require(\"path\")\n  // any single thing other than /\n  // don't need to escape / when using new RegExp()\n  , qmark = \"[^/]\"\n\n  // * => any number of characters\n  , star = qmark + \"*?\"\n\n  // ** when dots are allowed.  Anything goes, except .. and .\n  // not (^ or / followed by one or two dots followed by $ or /),\n  // followed by anything, any number of times.\n  , twoStarDot = \"(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?\"\n\n  // not a ^ or / followed by a dot,\n  // followed by anything, any number of times.\n  , twoStarNoDot = \"(?:(?!(?:\\\\\\/|^)\\\\.).)*?\"\n\n  // characters that need to be escaped in RegExp.\n  , reSpecials = charSet(\"().*{}+?[]^$\\\\!\")\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split(\"\").reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== \"string\") {\n    throw new TypeError(\"glob pattern string required\")\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === \"#\") {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === \"\") return p === \"\"\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options, cache)\n  }\n\n  if (typeof pattern !== \"string\") {\n    throw new TypeError(\"glob pattern string required\")\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows: need to use /, not \\\n  // On other platforms, \\ is a valid (albeit bad) filename char.\n  if (platform === \"win32\") {\n    pattern = pattern.split(\"\\\\\").join(\"/\")\n  }\n\n  // lru storage.\n  // these things aren't particularly big, but walking down the string\n  // and turning it into a regexp can get pretty costly.\n  var cacheKey = pattern + \"\\n\" + sigmund(options)\n  var cached = minimatch.cache.get(cacheKey)\n  if (cached) return cached\n  minimatch.cache.set(cacheKey, this)\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function() {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === \"#\") {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return -1 === s.indexOf(false)\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n    , negate = false\n    , options = this.options\n    , negateOffset = 0\n\n  if (options.nonegate) return\n\n  for ( var i = 0, l = pattern.length\n      ; i < l && pattern.charAt(i) === \"!\"\n      ; i ++) {\n    negate = !negate\n    negateOffset ++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return new Minimatch(pattern, options).braceExpand()\n}\n\nMinimatch.prototype.braceExpand = braceExpand\nfunction braceExpand (pattern, options) {\n  options = options || this.options\n  pattern = typeof pattern === \"undefined\"\n    ? this.pattern : pattern\n\n  if (typeof pattern === \"undefined\") {\n    throw new Error(\"undefined pattern\")\n  }\n\n  if (options.nobrace ||\n      !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  var escaping = false\n\n  // examples and comments refer to this crazy pattern:\n  // a{b,c{d,e},{f,g}h}x{y,z}\n  // expected:\n  // abxy\n  // abxz\n  // acdxy\n  // acdxz\n  // acexy\n  // acexz\n  // afhxy\n  // afhxz\n  // aghxy\n  // aghxz\n\n  // everything before the first \\{ is just a prefix.\n  // So, we pluck that off, and work with the rest,\n  // and then prepend it to everything we find.\n  if (pattern.charAt(0) !== \"{\") {\n    this.debug(pattern)\n    var prefix = null\n    for (var i = 0, l = pattern.length; i < l; i ++) {\n      var c = pattern.charAt(i)\n      this.debug(i, c)\n      if (c === \"\\\\\") {\n        escaping = !escaping\n      } else if (c === \"{\" && !escaping) {\n        prefix = pattern.substr(0, i)\n        break\n      }\n    }\n\n    // actually no sets, all { were escaped.\n    if (prefix === null) {\n      this.debug(\"no sets\")\n      return [pattern]\n    }\n\n   var tail = braceExpand.call(this, pattern.substr(i), options)\n    return tail.map(function (t) {\n      return prefix + t\n    })\n  }\n\n  // now we have something like:\n  // {b,c{d,e},{f,g}h}x{y,z}\n  // walk through the set, expanding each part, until\n  // the set ends.  then, we'll expand the suffix.\n  // If the set only has a single member, then'll put the {} back\n\n  // first, handle numeric sets, since they're easier\n  var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/)\n  if (numset) {\n    this.debug(\"numset\", numset[1], numset[2])\n    var suf = braceExpand.call(this, pattern.substr(numset[0].length), options)\n      , start = +numset[1]\n      , end = +numset[2]\n      , inc = start > end ? -1 : 1\n      , set = []\n    for (var i = start; i != (end + inc); i += inc) {\n      // append all the suffixes\n      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n        set.push(i + suf[ii])\n      }\n    }\n    return set\n  }\n\n  // ok, walk through the set\n  // We hope, somewhat optimistically, that there\n  // will be a } at the end.\n  // If the closing brace isn't found, then the pattern is\n  // interpreted as braceExpand(\"\\\\\" + pattern) so that\n  // the leading \\{ will be interpreted literally.\n  var i = 1 // skip the \\{\n    , depth = 1\n    , set = []\n    , member = \"\"\n    , sawEnd = false\n    , escaping = false\n\n  function addMember () {\n    set.push(member)\n    member = \"\"\n  }\n\n  this.debug(\"Entering for\")\n  FOR: for (i = 1, l = pattern.length; i < l; i ++) {\n    var c = pattern.charAt(i)\n    this.debug(\"\", i, c)\n\n    if (escaping) {\n      escaping = false\n      member += \"\\\\\" + c\n    } else {\n      switch (c) {\n        case \"\\\\\":\n          escaping = true\n          continue\n\n        case \"{\":\n          depth ++\n          member += \"{\"\n          continue\n\n        case \"}\":\n          depth --\n          // if this closes the actual set, then we're done\n          if (depth === 0) {\n            addMember()\n            // pluck off the close-brace\n            i ++\n            break FOR\n          } else {\n            member += c\n            continue\n          }\n\n        case \",\":\n          if (depth === 1) {\n            addMember()\n          } else {\n            member += c\n          }\n          continue\n\n        default:\n          member += c\n          continue\n      } // switch\n    } // else\n  } // for\n\n  // now we've either finished the set, and the suffix is\n  // pattern.substr(i), or we have *not* closed the set,\n  // and need to escape the leading brace\n  if (depth !== 0) {\n    this.debug(\"didn't close\", pattern)\n    return braceExpand.call(this, \"\\\\\" + pattern, options)\n  }\n\n  // x{y,z} -> [\"xy\", \"xz\"]\n  this.debug(\"set\", set)\n  this.debug(\"suffix\", pattern.substr(i))\n  var suf = braceExpand.call(this, pattern.substr(i), options)\n  // [\"b\", \"c{d,e}\",\"{f,g}h\"] ->\n  //   [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]]\n  var addBraces = set.length === 1\n  this.debug(\"set pre-expanded\", set)\n  set = set.map(function (p) {\n    return braceExpand.call(this, p, options)\n  }, this)\n  this.debug(\"set expanded\", set)\n\n\n  // [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]] ->\n  //   [\"b\", \"cd\", \"ce\", \"fh\", \"gh\"]\n  set = set.reduce(function (l, r) {\n    return l.concat(r)\n  })\n\n  if (addBraces) {\n    set = set.map(function (s) {\n      return \"{\" + s + \"}\"\n    })\n  }\n\n  // now attach the suffixes.\n  var ret = []\n  for (var i = 0, l = set.length; i < l; i ++) {\n    for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n      ret.push(set[i] + suf[ii])\n    }\n  }\n  return ret\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === \"**\") return GLOBSTAR\n  if (pattern === \"\") return \"\"\n\n  var re = \"\"\n    , hasMagic = !!options.nocase\n    , escaping = false\n    // ? => one single character\n    , patternListStack = []\n    , plType\n    , stateChar\n    , inClass = false\n    , reClassStart = -1\n    , classStart = -1\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n    , patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n      // not (start or / followed by . or .. followed by / or end)\n      : options.dot ? \"(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))\"\n      : \"(?!\\\\.)\"\n    , self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case \"*\":\n          re += star\n          hasMagic = true\n          break\n        case \"?\":\n          re += qmark\n          hasMagic = true\n          break\n        default:\n          re += \"\\\\\"+stateChar\n          break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for ( var i = 0, len = pattern.length, c\n      ; (i < len) && (c = pattern.charAt(i))\n      ; i ++ ) {\n\n    this.debug(\"%s\\t%s %s %j\", pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += \"\\\\\" + c\n      escaping = false\n      continue\n    }\n\n    SWITCH: switch (c) {\n      case \"/\":\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case \"\\\\\":\n        clearStateChar()\n        escaping = true\n        continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case \"?\":\n      case \"*\":\n      case \"+\":\n      case \"@\":\n      case \"!\":\n        this.debug(\"%s\\t%s %s %j <-- stateChar\", pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === \"!\" && i === classStart + 1) c = \"^\"\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n        continue\n\n      case \"(\":\n        if (inClass) {\n          re += \"(\"\n          continue\n        }\n\n        if (!stateChar) {\n          re += \"\\\\(\"\n          continue\n        }\n\n        plType = stateChar\n        patternListStack.push({ type: plType\n                              , start: i - 1\n                              , reStart: re.length })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === \"!\" ? \"(?:(?!\" : \"(?:\"\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n        continue\n\n      case \")\":\n        if (inClass || !patternListStack.length) {\n          re += \"\\\\)\"\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        re += \")\"\n        plType = patternListStack.pop().type\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        switch (plType) {\n          case \"!\":\n            re += \"[^/]*?)\"\n            break\n          case \"?\":\n          case \"+\":\n          case \"*\": re += plType\n          case \"@\": break // the default anyway\n        }\n        continue\n\n      case \"|\":\n        if (inClass || !patternListStack.length || escaping) {\n          re += \"\\\\|\"\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += \"|\"\n        continue\n\n      // these are mostly the same in regexp and glob\n      case \"[\":\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += \"\\\\\" + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n        continue\n\n      case \"]\":\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += \"\\\\\" + c\n          escaping = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n        continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n                   && !(c === \"^\" && inClass)) {\n          re += \"\\\\\"\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    var cs = pattern.substr(classStart + 1)\n      , sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  var pl\n  while (pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + 3)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = \"\\\\\"\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + \"|\"\n    })\n\n    this.debug(\"tail=%j\\n   %s\", tail, tail)\n    var t = pl.type === \"*\" ? star\n          : pl.type === \"?\" ? qmark\n          : \"\\\\\" + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart)\n       + t + \"\\\\(\"\n       + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += \"\\\\\\\\\"\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case \".\":\n    case \"[\":\n    case \"(\": addPatternStart = true\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== \"\" && hasMagic) re = \"(?=.)\" + re\n\n  if (addPatternStart) re = patternStart + re\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [ re, hasMagic ]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? \"i\" : \"\"\n    , regExp = new RegExp(\"^\" + re + \"$\", flags)\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) return this.regexp = false\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n      : options.dot ? twoStarDot\n      : twoStarNoDot\n    , flags = options.nocase ? \"i\" : \"\"\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n           : (typeof p === \"string\") ? regExpEscape(p)\n           : p._src\n    }).join(\"\\\\\\/\")\n  }).join(\"|\")\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = \"^(?:\" + re + \")$\"\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = \"^(?!\" + re + \").*$\"\n\n  try {\n    return this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    return this.regexp = false\n  }\n}\n\nminimatch.match = function (list, pattern, options) {\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug(\"match\", f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === \"\"\n\n  if (f === \"/\" && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  // On other platforms, \\ is a valid (albeit bad) filename char.\n  if (platform === \"win32\") {\n    f = f.split(\"\\\\\").join(\"/\")\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, \"split\", f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, \"set\", set)\n\n  var splitFile = path.basename(f.join(\"/\")).split(\"/\")\n\n  for (var i = 0, l = set.length; i < l; i ++) {\n    var pattern = set[i], file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = splitFile\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug(\"matchOne\",\n              { \"this\": this\n              , file: file\n              , pattern: pattern })\n\n  this.debug(\"matchOne\", file.length, pattern.length)\n\n  for ( var fi = 0\n          , pi = 0\n          , fl = file.length\n          , pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi ++, pi ++ ) {\n\n    this.debug(\"matchOne loop\")\n    var p = pattern[pi]\n      , f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n        , pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for ( ; fi < fl; fi ++) {\n          if (file[fi] === \".\" || file[fi] === \"..\" ||\n              (!options.dot && file[fi].charAt(0) === \".\")) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      WHILE: while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while',\n                    file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === \".\" || swallowee === \"..\" ||\n              (!options.dot && swallowee.charAt(0) === \".\")) {\n            this.debug(\"dot detected!\", file, fr, pattern, pr)\n            break WHILE\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr ++\n        }\n      }\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then \n      if (partial) {\n        // ran out of file\n        this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === \"string\") {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug(\"string match\", p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug(\"pattern match\", p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === \"\")\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error(\"wtf?\")\n}\n\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, \"$1\")\n}\n\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")\n}\n\n})( typeof require === \"function\" ? require : null,\n    this,\n    typeof module === \"object\" ? module : null,\n    typeof process === \"object\" ? process.platform : \"win32\"\n  )\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/lib/lru-cache.js": ";(function () { // closure for web browsers\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = LRUCache\n} else {\n  // just set the global for non-node platforms.\n  this.LRUCache = LRUCache\n}\n\nfunction hOP (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nfunction naiveLength () { return 1 }\n\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache))\n    return new LRUCache(options)\n\n  if (typeof options === 'number')\n    options = { max: options }\n\n  if (!options)\n    options = {}\n\n  this._max = options.max\n  // Kind of weird to have a default max of Infinity, but oh well.\n  if (!this._max || !(typeof this._max === \"number\") || this._max <= 0 )\n    this._max = Infinity\n\n  this._lengthCalculator = options.length || naiveLength\n  if (typeof this._lengthCalculator !== \"function\")\n    this._lengthCalculator = naiveLength\n\n  this._allowStale = options.stale || false\n  this._maxAge = options.maxAge || null\n  this._dispose = options.dispose\n  this.reset()\n}\n\n// resize the cache when the max changes.\nObject.defineProperty(LRUCache.prototype, \"max\",\n  { set : function (mL) {\n      if (!mL || !(typeof mL === \"number\") || mL <= 0 ) mL = Infinity\n      this._max = mL\n      if (this._length > this._max) trim(this)\n    }\n  , get : function () { return this._max }\n  , enumerable : true\n  })\n\n// resize the cache when the lengthCalculator changes.\nObject.defineProperty(LRUCache.prototype, \"lengthCalculator\",\n  { set : function (lC) {\n      if (typeof lC !== \"function\") {\n        this._lengthCalculator = naiveLength\n        this._length = this._itemCount\n        for (var key in this._cache) {\n          this._cache[key].length = 1\n        }\n      } else {\n        this._lengthCalculator = lC\n        this._length = 0\n        for (var key in this._cache) {\n          this._cache[key].length = this._lengthCalculator(this._cache[key].value)\n          this._length += this._cache[key].length\n        }\n      }\n\n      if (this._length > this._max) trim(this)\n    }\n  , get : function () { return this._lengthCalculator }\n  , enumerable : true\n  })\n\nObject.defineProperty(LRUCache.prototype, \"length\",\n  { get : function () { return this._length }\n  , enumerable : true\n  })\n\n\nObject.defineProperty(LRUCache.prototype, \"itemCount\",\n  { get : function () { return this._itemCount }\n  , enumerable : true\n  })\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  var i = 0\n  var itemCount = this._itemCount\n\n  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {\n    i++\n    var hit = this._lruList[k]\n    if (isStale(this, hit)) {\n      del(this, hit)\n      if (!this._allowStale) hit = undefined\n    }\n    if (hit) {\n      fn.call(thisp, hit.value, hit.key, this)\n    }\n  }\n}\n\nLRUCache.prototype.keys = function () {\n  var keys = new Array(this._itemCount)\n  var i = 0\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    keys[i++] = hit.key\n  }\n  return keys\n}\n\nLRUCache.prototype.values = function () {\n  var values = new Array(this._itemCount)\n  var i = 0\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    values[i++] = hit.value\n  }\n  return values\n}\n\nLRUCache.prototype.reset = function () {\n  if (this._dispose && this._cache) {\n    for (var k in this._cache) {\n      this._dispose(k, this._cache[k].value)\n    }\n  }\n\n  this._cache = Object.create(null) // hash of items by key\n  this._lruList = Object.create(null) // list of items in order of use recency\n  this._mru = 0 // most recently used\n  this._lru = 0 // least recently used\n  this._length = 0 // number of items in the list\n  this._itemCount = 0\n}\n\n// Provided for debugging/dev purposes only. No promises whatsoever that\n// this API stays stable.\nLRUCache.prototype.dump = function () {\n  return this._cache\n}\n\nLRUCache.prototype.dumpLru = function () {\n  return this._lruList\n}\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this._maxAge\n  var now = maxAge ? Date.now() : 0\n\n  if (hOP(this._cache, key)) {\n    // dispose of the old one before overwriting\n    if (this._dispose)\n      this._dispose(key, this._cache[key].value)\n\n    this._cache[key].now = now\n    this._cache[key].maxAge = maxAge\n    this._cache[key].value = value\n    this.get(key)\n    return true\n  }\n\n  var len = this._lengthCalculator(value)\n  var hit = new Entry(key, value, this._mru++, len, now, maxAge)\n\n  // oversized objects fall out of cache automatically.\n  if (hit.length > this._max) {\n    if (this._dispose) this._dispose(key, value)\n    return false\n  }\n\n  this._length += hit.length\n  this._lruList[hit.lu] = this._cache[key] = hit\n  this._itemCount ++\n\n  if (this._length > this._max)\n    trim(this)\n\n  return true\n}\n\nLRUCache.prototype.has = function (key) {\n  if (!hOP(this._cache, key)) return false\n  var hit = this._cache[key]\n  if (isStale(this, hit)) {\n    return false\n  }\n  return true\n}\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true)\n}\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false)\n}\n\nLRUCache.prototype.pop = function () {\n  var hit = this._lruList[this._lru]\n  del(this, hit)\n  return hit || null\n}\n\nLRUCache.prototype.del = function (key) {\n  del(this, this._cache[key])\n}\n\nfunction get (self, key, doUse) {\n  var hit = self._cache[key]\n  if (hit) {\n    if (isStale(self, hit)) {\n      del(self, hit)\n      if (!self._allowStale) hit = undefined\n    } else {\n      if (doUse) use(self, hit)\n    }\n    if (hit) hit = hit.value\n  }\n  return hit\n}\n\nfunction isStale(self, hit) {\n  if (!hit || (!hit.maxAge && !self._maxAge)) return false\n  var stale = false;\n  var diff = Date.now() - hit.now\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge\n  } else {\n    stale = self._maxAge && (diff > self._maxAge)\n  }\n  return stale;\n}\n\nfunction use (self, hit) {\n  shiftLU(self, hit)\n  hit.lu = self._mru ++\n  self._lruList[hit.lu] = hit\n}\n\nfunction trim (self) {\n  while (self._lru < self._mru && self._length > self._max)\n    del(self, self._lruList[self._lru])\n}\n\nfunction shiftLU (self, hit) {\n  delete self._lruList[ hit.lu ]\n  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++\n}\n\nfunction del (self, hit) {\n  if (hit) {\n    if (self._dispose) self._dispose(hit.key, hit.value)\n    self._length -= hit.length\n    self._itemCount --\n    delete self._cache[ hit.key ]\n    shiftLU(self, hit)\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, lu, length, now, maxAge) {\n  this.key = key\n  this.value = value\n  this.lu = lu\n  this.length = length\n  this.now = now\n  if (maxAge) this.maxAge = maxAge\n}\n\n})()\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/package.json": "{\n  \"name\": \"lru-cache\",\n  \"description\": \"A cache object that deletes the least-recently-used items.\",\n  \"version\": \"2.6.4\",\n  \"author\": {\n    \"name\": \"Isaac Z. Schlueter\",\n    \"email\": \"i@izs.me\"\n  },\n  \"keywords\": [\n    \"mru\",\n    \"lru\",\n    \"cache\"\n  ],\n  \"scripts\": {\n    \"test\": \"tap test --gc\"\n  },\n  \"main\": \"lib/lru-cache.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/isaacs/node-lru-cache.git\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"^0.7.1\",\n    \"weak\": \"\"\n  },\n  \"license\": \"ISC\",\n  \"gitHead\": \"aea58fc0a12714c6e1422963e7ebea66460ec39e\",\n  \"bugs\": {\n    \"url\": \"https://github.com/isaacs/node-lru-cache/issues\"\n  },\n  \"homepage\": \"https://github.com/isaacs/node-lru-cache#readme\",\n  \"_id\": \"lru-cache@2.6.4\",\n  \"_shasum\": \"2675190ccd1b0701ec2f652a4d0d3d400d76c0dd\",\n  \"_from\": \"lru-cache@>=2.0.0 <3.0.0\",\n  \"_npmVersion\": \"2.10.0\",\n  \"_nodeVersion\": \"2.0.1\",\n  \"_npmUser\": {\n    \"name\": \"isaacs\",\n    \"email\": \"isaacs@npmjs.com\"\n  },\n  \"dist\": {\n    \"shasum\": \"2675190ccd1b0701ec2f652a4d0d3d400d76c0dd\",\n    \"tarball\": \"http://registry.npmjs.org/lru-cache/-/lru-cache-2.6.4.tgz\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"isaacs\",\n      \"email\": \"isaacs@npmjs.com\"\n    },\n    {\n      \"name\": \"othiym23\",\n      \"email\": \"ogd@aoaioxxysz.net\"\n    }\n  ],\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/lru-cache/-/lru-cache-2.6.4.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/test/basic.js": "var test = require(\"tap\").test\n  , LRU = require(\"../\")\n\ntest(\"basic\", function (t) {\n  var cache = new LRU({max: 10})\n  cache.set(\"key\", \"value\")\n  t.equal(cache.get(\"key\"), \"value\")\n  t.equal(cache.get(\"nada\"), undefined)\n  t.equal(cache.length, 1)\n  t.equal(cache.max, 10)\n  t.end()\n})\n\ntest(\"least recently set\", function (t) {\n  var cache = new LRU(2)\n  cache.set(\"a\", \"A\")\n  cache.set(\"b\", \"B\")\n  cache.set(\"c\", \"C\")\n  t.equal(cache.get(\"c\"), \"C\")\n  t.equal(cache.get(\"b\"), \"B\")\n  t.equal(cache.get(\"a\"), undefined)\n  t.end()\n})\n\ntest(\"lru recently gotten\", function (t) {\n  var cache = new LRU(2)\n  cache.set(\"a\", \"A\")\n  cache.set(\"b\", \"B\")\n  cache.get(\"a\")\n  cache.set(\"c\", \"C\")\n  t.equal(cache.get(\"c\"), \"C\")\n  t.equal(cache.get(\"b\"), undefined)\n  t.equal(cache.get(\"a\"), \"A\")\n  t.end()\n})\n\ntest(\"del\", function (t) {\n  var cache = new LRU(2)\n  cache.set(\"a\", \"A\")\n  cache.del(\"a\")\n  t.equal(cache.get(\"a\"), undefined)\n  t.end()\n})\n\ntest(\"max\", function (t) {\n  var cache = new LRU(3)\n\n  // test changing the max, verify that the LRU items get dropped.\n  cache.max = 100\n  for (var i = 0; i < 100; i ++) cache.set(i, i)\n  t.equal(cache.length, 100)\n  for (var i = 0; i < 100; i ++) {\n    t.equal(cache.get(i), i)\n  }\n  cache.max = 3\n  t.equal(cache.length, 3)\n  for (var i = 0; i < 97; i ++) {\n    t.equal(cache.get(i), undefined)\n  }\n  for (var i = 98; i < 100; i ++) {\n    t.equal(cache.get(i), i)\n  }\n\n  // now remove the max restriction, and try again.\n  cache.max = \"hello\"\n  for (var i = 0; i < 100; i ++) cache.set(i, i)\n  t.equal(cache.length, 100)\n  for (var i = 0; i < 100; i ++) {\n    t.equal(cache.get(i), i)\n  }\n  // should trigger an immediate resize\n  cache.max = 3\n  t.equal(cache.length, 3)\n  for (var i = 0; i < 97; i ++) {\n    t.equal(cache.get(i), undefined)\n  }\n  for (var i = 98; i < 100; i ++) {\n    t.equal(cache.get(i), i)\n  }\n  t.end()\n})\n\ntest(\"reset\", function (t) {\n  var cache = new LRU(10)\n  cache.set(\"a\", \"A\")\n  cache.set(\"b\", \"B\")\n  cache.reset()\n  t.equal(cache.length, 0)\n  t.equal(cache.max, 10)\n  t.equal(cache.get(\"a\"), undefined)\n  t.equal(cache.get(\"b\"), undefined)\n  t.end()\n})\n\n\n// Note: `<cache>.dump()` is a debugging tool only. No guarantees are made\n// about the format/layout of the response.\ntest(\"dump\", function (t) {\n  var cache = new LRU(10)\n  var d = cache.dump();\n  t.equal(Object.keys(d).length, 0, \"nothing in dump for empty cache\")\n  cache.set(\"a\", \"A\")\n  var d = cache.dump()  // { a: { key: \"a\", value: \"A\", lu: 0 } }\n  t.ok(d.a)\n  t.equal(d.a.key, \"a\")\n  t.equal(d.a.value, \"A\")\n  t.equal(d.a.lu, 0)\n\n  cache.set(\"b\", \"B\")\n  cache.get(\"b\")\n  d = cache.dump()\n  t.ok(d.b)\n  t.equal(d.b.key, \"b\")\n  t.equal(d.b.value, \"B\")\n  t.equal(d.b.lu, 2)\n\n  t.end()\n})\n\n\ntest(\"basic with weighed length\", function (t) {\n  var cache = new LRU({\n    max: 100,\n    length: function (item) { return item.size }\n  })\n  cache.set(\"key\", {val: \"value\", size: 50})\n  t.equal(cache.get(\"key\").val, \"value\")\n  t.equal(cache.get(\"nada\"), undefined)\n  t.equal(cache.lengthCalculator(cache.get(\"key\")), 50)\n  t.equal(cache.length, 50)\n  t.equal(cache.max, 100)\n  t.end()\n})\n\n\ntest(\"weighed length item too large\", function (t) {\n  var cache = new LRU({\n    max: 10,\n    length: function (item) { return item.size }\n  })\n  t.equal(cache.max, 10)\n\n  // should fall out immediately\n  cache.set(\"key\", {val: \"value\", size: 50})\n\n  t.equal(cache.length, 0)\n  t.equal(cache.get(\"key\"), undefined)\n  t.end()\n})\n\ntest(\"least recently set with weighed length\", function (t) {\n  var cache = new LRU({\n    max:8,\n    length: function (item) { return item.length }\n  })\n  cache.set(\"a\", \"A\")\n  cache.set(\"b\", \"BB\")\n  cache.set(\"c\", \"CCC\")\n  cache.set(\"d\", \"DDDD\")\n  t.equal(cache.get(\"d\"), \"DDDD\")\n  t.equal(cache.get(\"c\"), \"CCC\")\n  t.equal(cache.get(\"b\"), undefined)\n  t.equal(cache.get(\"a\"), undefined)\n  t.end()\n})\n\ntest(\"lru recently gotten with weighed length\", function (t) {\n  var cache = new LRU({\n    max: 8,\n    length: function (item) { return item.length }\n  })\n  cache.set(\"a\", \"A\")\n  cache.set(\"b\", \"BB\")\n  cache.set(\"c\", \"CCC\")\n  cache.get(\"a\")\n  cache.get(\"b\")\n  cache.set(\"d\", \"DDDD\")\n  t.equal(cache.get(\"c\"), undefined)\n  t.equal(cache.get(\"d\"), \"DDDD\")\n  t.equal(cache.get(\"b\"), \"BB\")\n  t.equal(cache.get(\"a\"), \"A\")\n  t.end()\n})\n\ntest(\"set returns proper booleans\", function(t) {\n  var cache = new LRU({\n    max: 5,\n    length: function (item) { return item.length }\n  })\n\n  t.equal(cache.set(\"a\", \"A\"), true)\n\n  // should return false for max exceeded\n  t.equal(cache.set(\"b\", \"donuts\"), false)\n\n  t.equal(cache.set(\"b\", \"B\"), true)\n  t.equal(cache.set(\"c\", \"CCCC\"), true)\n  t.end()\n})\n\ntest(\"drop the old items\", function(t) {\n  var cache = new LRU({\n    max: 5,\n    maxAge: 50\n  })\n\n  cache.set(\"a\", \"A\")\n\n  setTimeout(function () {\n    cache.set(\"b\", \"b\")\n    t.equal(cache.get(\"a\"), \"A\")\n  }, 25)\n\n  setTimeout(function () {\n    cache.set(\"c\", \"C\")\n    // timed out\n    t.notOk(cache.get(\"a\"))\n  }, 60 + 25)\n\n  setTimeout(function () {\n    t.notOk(cache.get(\"b\"))\n    t.equal(cache.get(\"c\"), \"C\")\n  }, 90)\n\n  setTimeout(function () {\n    t.notOk(cache.get(\"c\"))\n    t.end()\n  }, 155)\n})\n\ntest(\"individual item can have it's own maxAge\", function(t) {\n  var cache = new LRU({\n    max: 5,\n    maxAge: 50\n  })\n\n  cache.set(\"a\", \"A\", 20)\n  setTimeout(function () {\n    t.notOk(cache.get(\"a\"))\n    t.end()\n  }, 25)\n})\n\ntest(\"individual item can have it's own maxAge > cache's\", function(t) {\n  var cache = new LRU({\n    max: 5,\n    maxAge: 20\n  })\n\n  cache.set(\"a\", \"A\", 50)\n  setTimeout(function () {\n    t.equal(cache.get(\"a\"), \"A\")\n    t.end()\n  }, 25)\n})\n\ntest(\"disposal function\", function(t) {\n  var disposed = false\n  var cache = new LRU({\n    max: 1,\n    dispose: function (k, n) {\n      disposed = n\n    }\n  })\n\n  cache.set(1, 1)\n  cache.set(2, 2)\n  t.equal(disposed, 1)\n  cache.set(3, 3)\n  t.equal(disposed, 2)\n  cache.reset()\n  t.equal(disposed, 3)\n  t.end()\n})\n\ntest(\"disposal function on too big of item\", function(t) {\n  var disposed = false\n  var cache = new LRU({\n    max: 1,\n    length: function (k) {\n      return k.length\n    },\n    dispose: function (k, n) {\n      disposed = n\n    }\n  })\n  var obj = [ 1, 2 ]\n\n  t.equal(disposed, false)\n  cache.set(\"obj\", obj)\n  t.equal(disposed, obj)\n  t.end()\n})\n\ntest(\"has()\", function(t) {\n  var cache = new LRU({\n    max: 1,\n    maxAge: 10\n  })\n\n  cache.set('foo', 'bar')\n  t.equal(cache.has('foo'), true)\n  cache.set('blu', 'baz')\n  t.equal(cache.has('foo'), false)\n  t.equal(cache.has('blu'), true)\n  setTimeout(function() {\n    t.equal(cache.has('blu'), false)\n    t.end()\n  }, 15)\n})\n\ntest(\"stale\", function(t) {\n  var cache = new LRU({\n    maxAge: 10,\n    stale: true\n  })\n\n  cache.set('foo', 'bar')\n  t.equal(cache.get('foo'), 'bar')\n  t.equal(cache.has('foo'), true)\n  setTimeout(function() {\n    t.equal(cache.has('foo'), false)\n    t.equal(cache.get('foo'), 'bar')\n    t.equal(cache.get('foo'), undefined)\n    t.end()\n  }, 15)\n})\n\ntest(\"lru update via set\", function(t) {\n  var cache = LRU({ max: 2 });\n\n  cache.set('foo', 1);\n  cache.set('bar', 2);\n  cache.del('bar');\n  cache.set('baz', 3);\n  cache.set('qux', 4);\n\n  t.equal(cache.get('foo'), undefined)\n  t.equal(cache.get('bar'), undefined)\n  t.equal(cache.get('baz'), 3)\n  t.equal(cache.get('qux'), 4)\n  t.end()\n})\n\ntest(\"least recently set w/ peek\", function (t) {\n  var cache = new LRU(2)\n  cache.set(\"a\", \"A\")\n  cache.set(\"b\", \"B\")\n  t.equal(cache.peek(\"a\"), \"A\")\n  cache.set(\"c\", \"C\")\n  t.equal(cache.get(\"c\"), \"C\")\n  t.equal(cache.get(\"b\"), \"B\")\n  t.equal(cache.get(\"a\"), undefined)\n  t.end()\n})\n\ntest(\"pop the least used item\", function (t) {\n  var cache = new LRU(3)\n  , last\n\n  cache.set(\"a\", \"A\")\n  cache.set(\"b\", \"B\")\n  cache.set(\"c\", \"C\")\n\n  t.equal(cache.length, 3)\n  t.equal(cache.max, 3)\n\n  // Ensure we pop a, c, b\n  cache.get(\"b\", \"B\")\n\n  last = cache.pop()\n  t.equal(last.key, \"a\")\n  t.equal(last.value, \"A\")\n  t.equal(cache.length, 2)\n  t.equal(cache.max, 3)\n\n  last = cache.pop()\n  t.equal(last.key, \"c\")\n  t.equal(last.value, \"C\")\n  t.equal(cache.length, 1)\n  t.equal(cache.max, 3)\n\n  last = cache.pop()\n  t.equal(last.key, \"b\")\n  t.equal(last.value, \"B\")\n  t.equal(cache.length, 0)\n  t.equal(cache.max, 3)\n\n  last = cache.pop()\n  t.equal(last, null)\n  t.equal(cache.length, 0)\n  t.equal(cache.max, 3)\n\n  t.end()\n})\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/test/foreach.js": "var test = require('tap').test\nvar LRU = require('../')\n\ntest('forEach', function (t) {\n  var l = new LRU(5)\n  for (var i = 0; i < 10; i ++) {\n    l.set(i.toString(), i.toString(2))\n  }\n\n  var i = 9\n  l.forEach(function (val, key, cache) {\n    t.equal(cache, l)\n    t.equal(key, i.toString())\n    t.equal(val, i.toString(2))\n    i -= 1\n  })\n\n  // get in order of most recently used\n  l.get(6)\n  l.get(8)\n\n  var order = [ 8, 6, 9, 7, 5 ]\n  var i = 0\n\n  l.forEach(function (val, key, cache) {\n    var j = order[i ++]\n    t.equal(cache, l)\n    t.equal(key, j.toString())\n    t.equal(val, j.toString(2))\n  })\n  t.equal(i, order.length);\n\n  t.end()\n})\n\ntest('keys() and values()', function (t) {\n  var l = new LRU(5)\n  for (var i = 0; i < 10; i ++) {\n    l.set(i.toString(), i.toString(2))\n  }\n\n  t.similar(l.keys(), ['9', '8', '7', '6', '5'])\n  t.similar(l.values(), ['1001', '1000', '111', '110', '101'])\n\n  // get in order of most recently used\n  l.get(6)\n  l.get(8)\n\n  t.similar(l.keys(), ['8', '6', '9', '7', '5'])\n  t.similar(l.values(), ['1000', '110', '1001', '111', '101'])\n\n  t.end()\n})\n\ntest('all entries are iterated over', function(t) {\n  var l = new LRU(5)\n  for (var i = 0; i < 10; i ++) {\n    l.set(i.toString(), i.toString(2))\n  }\n\n  var i = 0\n  l.forEach(function (val, key, cache) {\n    if (i > 0) {\n      cache.del(key)\n    }\n    i += 1\n  })\n\n  t.equal(i, 5)\n  t.equal(l.keys().length, 1)\n\n  t.end()\n})\n\ntest('all stale entries are removed', function(t) {\n  var l = new LRU({ max: 5, maxAge: -5, stale: true })\n  for (var i = 0; i < 10; i ++) {\n    l.set(i.toString(), i.toString(2))\n  }\n\n  var i = 0\n  l.forEach(function () {\n    i += 1\n  })\n\n  t.equal(i, 5)\n  t.equal(l.keys().length, 0)\n\n  t.end()\n})\n\ntest('expires', function (t) {\n  var l = new LRU({\n    max: 10,\n    maxAge: 50\n  })\n  for (var i = 0; i < 10; i++) {\n    l.set(i.toString(), i.toString(2), ((i % 2) ? 25 : undefined))\n  }\n\n  var i = 0\n  var order = [ 8, 6, 4, 2, 0 ]\n  setTimeout(function () {\n    l.forEach(function (val, key, cache) {\n      var j = order[i++]\n      t.equal(cache, l)\n      t.equal(key, j.toString())\n      t.equal(val, j.toString(2))\n    })\n    t.equal(i, order.length);\n    t.end()\n\n    setTimeout(function () {\n      var count = 0;\n      l.forEach(function (val, key, cache) { count++; })\n      t.equal(0, count);\n      t.end()\n    }, 25)\n\n  }, 26)\n})\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/test/memory-leak.js": "#!/usr/bin/env node --expose_gc\n\nvar weak = require('weak');\nvar test = require('tap').test\nvar LRU = require('../')\nvar l = new LRU({ max: 10 })\nvar refs = 0\nfunction X() {\n  refs ++\n  weak(this, deref)\n}\n\nfunction deref() {\n  refs --\n}\n\ntest('no leaks', function (t) {\n  // fill up the cache\n  for (var i = 0; i < 100; i++) {\n    l.set(i, new X);\n    // throw some gets in there, too.\n    if (i % 2 === 0)\n      l.get(i / 2)\n  }\n\n  gc()\n\n  var start = process.memoryUsage()\n\n  // capture the memory\n  var startRefs = refs\n\n  // do it again, but more\n  for (var i = 0; i < 10000; i++) {\n    l.set(i, new X);\n    // throw some gets in there, too.\n    if (i % 2 === 0)\n      l.get(i / 2)\n  }\n\n  gc()\n\n  var end = process.memoryUsage()\n  t.equal(refs, startRefs, 'no leaky refs')\n\n  console.error('start: %j\\n' +\n                'end:   %j', start, end);\n  t.pass();\n  t.end();\n})\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/node_modules/sigmund/bench.js": "// different ways to id objects\n// use a req/res pair, since it's crazy deep and cyclical\n\n// sparseFE10 and sigmund are usually pretty close, which is to be expected,\n// since they are essentially the same algorithm, except that sigmund handles\n// regular expression objects properly.\n\n\nvar http = require('http')\nvar util = require('util')\nvar sigmund = require('./sigmund.js')\nvar sreq, sres, creq, cres, test\n\nhttp.createServer(function (q, s) {\n  sreq = q\n  sres = s\n  sres.end('ok')\n  this.close(function () { setTimeout(function () {\n    start()\n  }, 200) })\n}).listen(1337, function () {\n  creq = http.get({ port: 1337 })\n  creq.on('response', function (s) { cres = s })\n})\n\nfunction start () {\n  test = [sreq, sres, creq, cres]\n  // test = sreq\n  // sreq.sres = sres\n  // sreq.creq = creq\n  // sreq.cres = cres\n\n  for (var i in exports.compare) {\n    console.log(i)\n    var hash = exports.compare[i]()\n    console.log(hash)\n    console.log(hash.length)\n    console.log('')\n  }\n\n  require('bench').runMain()\n}\n\nfunction customWs (obj, md, d) {\n  d = d || 0\n  var to = typeof obj\n  if (to === 'undefined' || to === 'function' || to === null) return ''\n  if (d > md || !obj || to !== 'object') return ('' + obj).replace(/[\\n ]+/g, '')\n\n  if (Array.isArray(obj)) {\n    return obj.map(function (i, _, __) {\n      return customWs(i, md, d + 1)\n    }).reduce(function (a, b) { return a + b }, '')\n  }\n\n  var keys = Object.keys(obj)\n  return keys.map(function (k, _, __) {\n    return k + ':' + customWs(obj[k], md, d + 1)\n  }).reduce(function (a, b) { return a + b }, '')\n}\n\nfunction custom (obj, md, d) {\n  d = d || 0\n  var to = typeof obj\n  if (to === 'undefined' || to === 'function' || to === null) return ''\n  if (d > md || !obj || to !== 'object') return '' + obj\n\n  if (Array.isArray(obj)) {\n    return obj.map(function (i, _, __) {\n      return custom(i, md, d + 1)\n    }).reduce(function (a, b) { return a + b }, '')\n  }\n\n  var keys = Object.keys(obj)\n  return keys.map(function (k, _, __) {\n    return k + ':' + custom(obj[k], md, d + 1)\n  }).reduce(function (a, b) { return a + b }, '')\n}\n\nfunction sparseFE2 (obj, maxDepth) {\n  var seen = []\n  var soFar = ''\n  function ch (v, depth) {\n    if (depth > maxDepth) return\n    if (typeof v === 'function' || typeof v === 'undefined') return\n    if (typeof v !== 'object' || !v) {\n      soFar += v\n      return\n    }\n    if (seen.indexOf(v) !== -1 || depth === maxDepth) return\n    seen.push(v)\n    soFar += '{'\n    Object.keys(v).forEach(function (k, _, __) {\n      // pseudo-private values.  skip those.\n      if (k.charAt(0) === '_') return\n      var to = typeof v[k]\n      if (to === 'function' || to === 'undefined') return\n      soFar += k + ':'\n      ch(v[k], depth + 1)\n    })\n    soFar += '}'\n  }\n  ch(obj, 0)\n  return soFar\n}\n\nfunction sparseFE (obj, maxDepth) {\n  var seen = []\n  var soFar = ''\n  function ch (v, depth) {\n    if (depth > maxDepth) return\n    if (typeof v === 'function' || typeof v === 'undefined') return\n    if (typeof v !== 'object' || !v) {\n      soFar += v\n      return\n    }\n    if (seen.indexOf(v) !== -1 || depth === maxDepth) return\n    seen.push(v)\n    soFar += '{'\n    Object.keys(v).forEach(function (k, _, __) {\n      // pseudo-private values.  skip those.\n      if (k.charAt(0) === '_') return\n      var to = typeof v[k]\n      if (to === 'function' || to === 'undefined') return\n      soFar += k\n      ch(v[k], depth + 1)\n    })\n  }\n  ch(obj, 0)\n  return soFar\n}\n\nfunction sparse (obj, maxDepth) {\n  var seen = []\n  var soFar = ''\n  function ch (v, depth) {\n    if (depth > maxDepth) return\n    if (typeof v === 'function' || typeof v === 'undefined') return\n    if (typeof v !== 'object' || !v) {\n      soFar += v\n      return\n    }\n    if (seen.indexOf(v) !== -1 || depth === maxDepth) return\n    seen.push(v)\n    soFar += '{'\n    for (var k in v) {\n      // pseudo-private values.  skip those.\n      if (k.charAt(0) === '_') continue\n      var to = typeof v[k]\n      if (to === 'function' || to === 'undefined') continue\n      soFar += k\n      ch(v[k], depth + 1)\n    }\n  }\n  ch(obj, 0)\n  return soFar\n}\n\nfunction noCommas (obj, maxDepth) {\n  var seen = []\n  var soFar = ''\n  function ch (v, depth) {\n    if (depth > maxDepth) return\n    if (typeof v === 'function' || typeof v === 'undefined') return\n    if (typeof v !== 'object' || !v) {\n      soFar += v\n      return\n    }\n    if (seen.indexOf(v) !== -1 || depth === maxDepth) return\n    seen.push(v)\n    soFar += '{'\n    for (var k in v) {\n      // pseudo-private values.  skip those.\n      if (k.charAt(0) === '_') continue\n      var to = typeof v[k]\n      if (to === 'function' || to === 'undefined') continue\n      soFar += k + ':'\n      ch(v[k], depth + 1)\n    }\n    soFar += '}'\n  }\n  ch(obj, 0)\n  return soFar\n}\n\n\nfunction flatten (obj, maxDepth) {\n  var seen = []\n  var soFar = ''\n  function ch (v, depth) {\n    if (depth > maxDepth) return\n    if (typeof v === 'function' || typeof v === 'undefined') return\n    if (typeof v !== 'object' || !v) {\n      soFar += v\n      return\n    }\n    if (seen.indexOf(v) !== -1 || depth === maxDepth) return\n    seen.push(v)\n    soFar += '{'\n    for (var k in v) {\n      // pseudo-private values.  skip those.\n      if (k.charAt(0) === '_') continue\n      var to = typeof v[k]\n      if (to === 'function' || to === 'undefined') continue\n      soFar += k + ':'\n      ch(v[k], depth + 1)\n      soFar += ','\n    }\n    soFar += '}'\n  }\n  ch(obj, 0)\n  return soFar\n}\n\nexports.compare =\n{\n  // 'custom 2': function () {\n  //   return custom(test, 2, 0)\n  // },\n  // 'customWs 2': function () {\n  //   return customWs(test, 2, 0)\n  // },\n  'JSON.stringify (guarded)': function () {\n    var seen = []\n    return JSON.stringify(test, function (k, v) {\n      if (typeof v !== 'object' || !v) return v\n      if (seen.indexOf(v) !== -1) return undefined\n      seen.push(v)\n      return v\n    })\n  },\n\n  'flatten 10': function () {\n    return flatten(test, 10)\n  },\n\n  // 'flattenFE 10': function () {\n  //   return flattenFE(test, 10)\n  // },\n\n  'noCommas 10': function () {\n    return noCommas(test, 10)\n  },\n\n  'sparse 10': function () {\n    return sparse(test, 10)\n  },\n\n  'sparseFE 10': function () {\n    return sparseFE(test, 10)\n  },\n\n  'sparseFE2 10': function () {\n    return sparseFE2(test, 10)\n  },\n\n  sigmund: function() {\n    return sigmund(test, 10)\n  },\n\n\n  // 'util.inspect 1': function () {\n  //   return util.inspect(test, false, 1, false)\n  // },\n  // 'util.inspect undefined': function () {\n  //   util.inspect(test)\n  // },\n  // 'util.inspect 2': function () {\n  //   util.inspect(test, false, 2, false)\n  // },\n  // 'util.inspect 3': function () {\n  //   util.inspect(test, false, 3, false)\n  // },\n  // 'util.inspect 4': function () {\n  //   util.inspect(test, false, 4, false)\n  // },\n  // 'util.inspect Infinity': function () {\n  //   util.inspect(test, false, Infinity, false)\n  // }\n}\n\n/** results\n**/\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/node_modules/sigmund/package.json": "{\n  \"name\": \"sigmund\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Quick and dirty signatures for Objects.\",\n  \"main\": \"sigmund.js\",\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"tap\": \"~0.3.0\"\n  },\n  \"scripts\": {\n    \"test\": \"tap test/*.js\",\n    \"bench\": \"node bench.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/isaacs/sigmund.git\"\n  },\n  \"keywords\": [\n    \"object\",\n    \"signature\",\n    \"key\",\n    \"data\",\n    \"psychoanalysis\"\n  ],\n  \"author\": {\n    \"name\": \"Isaac Z. Schlueter\",\n    \"email\": \"i@izs.me\",\n    \"url\": \"http://blog.izs.me/\"\n  },\n  \"license\": \"ISC\",\n  \"gitHead\": \"527f97aa5bb253d927348698c0cd3bb267d098c6\",\n  \"bugs\": {\n    \"url\": \"https://github.com/isaacs/sigmund/issues\"\n  },\n  \"homepage\": \"https://github.com/isaacs/sigmund#readme\",\n  \"_id\": \"sigmund@1.0.1\",\n  \"_shasum\": \"3ff21f198cad2175f9f3b781853fd94d0d19b590\",\n  \"_from\": \"sigmund@>=1.0.0 <1.1.0\",\n  \"_npmVersion\": \"2.10.0\",\n  \"_nodeVersion\": \"2.0.1\",\n  \"_npmUser\": {\n    \"name\": \"isaacs\",\n    \"email\": \"isaacs@npmjs.com\"\n  },\n  \"dist\": {\n    \"shasum\": \"3ff21f198cad2175f9f3b781853fd94d0d19b590\",\n    \"tarball\": \"http://registry.npmjs.org/sigmund/-/sigmund-1.0.1.tgz\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"isaacs\",\n      \"email\": \"i@izs.me\"\n    }\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/sigmund/-/sigmund-1.0.1.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/node_modules/sigmund/sigmund.js": "module.exports = sigmund\nfunction sigmund (subject, maxSessions) {\n    maxSessions = maxSessions || 10;\n    var notes = [];\n    var analysis = '';\n    var RE = RegExp;\n\n    function psychoAnalyze (subject, session) {\n        if (session > maxSessions) return;\n\n        if (typeof subject === 'function' ||\n            typeof subject === 'undefined') {\n            return;\n        }\n\n        if (typeof subject !== 'object' || !subject ||\n            (subject instanceof RE)) {\n            analysis += subject;\n            return;\n        }\n\n        if (notes.indexOf(subject) !== -1 || session === maxSessions) return;\n\n        notes.push(subject);\n        analysis += '{';\n        Object.keys(subject).forEach(function (issue, _, __) {\n            // pseudo-private values.  skip those.\n            if (issue.charAt(0) === '_') return;\n            var to = typeof subject[issue];\n            if (to === 'function' || to === 'undefined') return;\n            analysis += issue;\n            psychoAnalyze(subject[issue], session + 1);\n        });\n    }\n    psychoAnalyze(subject, 0);\n    return analysis;\n}\n\n// vim: set softtabstop=4 shiftwidth=4:\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/node_modules/sigmund/test/basic.js": "var test = require('tap').test\nvar sigmund = require('../sigmund.js')\n\n\n// occasionally there are duplicates\n// that's an acceptable edge-case.  JSON.stringify and util.inspect\n// have some collision potential as well, though less, and collision\n// detection is expensive.\nvar hash = '{abc/def/g{0h1i2{jkl'\nvar obj1 = {a:'b',c:/def/,g:['h','i',{j:'',k:'l'}]}\nvar obj2 = {a:'b',c:'/def/',g:['h','i','{jkl']}\n\nvar obj3 = JSON.parse(JSON.stringify(obj1))\nobj3.c = /def/\nobj3.g[2].cycle = obj3\nvar cycleHash = '{abc/def/g{0h1i2{jklcycle'\n\ntest('basic', function (t) {\n    t.equal(sigmund(obj1), hash)\n    t.equal(sigmund(obj2), hash)\n    t.equal(sigmund(obj3), cycleHash)\n    t.end()\n})\n\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/package.json": "{\n  \"author\": {\n    \"name\": \"Isaac Z. Schlueter\",\n    \"email\": \"i@izs.me\",\n    \"url\": \"http://blog.izs.me\"\n  },\n  \"name\": \"minimatch\",\n  \"description\": \"a glob matcher in javascript\",\n  \"version\": \"0.2.14\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/isaacs/minimatch.git\"\n  },\n  \"main\": \"minimatch.js\",\n  \"scripts\": {\n    \"test\": \"tap test/*.js\"\n  },\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"dependencies\": {\n    \"lru-cache\": \"2\",\n    \"sigmund\": \"~1.0.0\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"\"\n  },\n  \"license\": {\n    \"type\": \"MIT\",\n    \"url\": \"http://github.com/isaacs/minimatch/raw/master/LICENSE\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/isaacs/minimatch/issues\"\n  },\n  \"homepage\": \"https://github.com/isaacs/minimatch\",\n  \"_id\": \"minimatch@0.2.14\",\n  \"dist\": {\n    \"shasum\": \"c74e780574f63c6f9a090e90efbe6ef53a6a756a\",\n    \"tarball\": \"http://registry.npmjs.org/minimatch/-/minimatch-0.2.14.tgz\"\n  },\n  \"_from\": \"minimatch@>=0.2.11 <0.3.0\",\n  \"_npmVersion\": \"1.3.17\",\n  \"_npmUser\": {\n    \"name\": \"isaacs\",\n    \"email\": \"i@izs.me\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"isaacs\",\n      \"email\": \"i@izs.me\"\n    }\n  ],\n  \"directories\": {},\n  \"_shasum\": \"c74e780574f63c6f9a090e90efbe6ef53a6a756a\",\n  \"_resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-0.2.14.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/test/basic.js": "// http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test\n//\n// TODO: Some of these tests do very bad things with backslashes, and will\n// most likely fail badly on windows.  They should probably be skipped.\n\nvar tap = require(\"tap\")\n  , globalBefore = Object.keys(global)\n  , mm = require(\"../\")\n  , files = [ \"a\", \"b\", \"c\", \"d\", \"abc\"\n            , \"abd\", \"abe\", \"bb\", \"bcd\"\n            , \"ca\", \"cb\", \"dd\", \"de\"\n            , \"bdir/\", \"bdir/cfile\"]\n  , next = files.concat([ \"a-b\", \"aXb\"\n                        , \".x\", \".y\" ])\n\n\nvar patterns =\n  [ \"http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test\"\n  , [\"a*\", [\"a\", \"abc\", \"abd\", \"abe\"]]\n  , [\"X*\", [\"X*\"], {nonull: true}]\n\n  // allow null glob expansion\n  , [\"X*\", []]\n\n  // isaacs: Slightly different than bash/sh/ksh\n  // \\\\* is not un-escaped to literal \"*\" in a failed match,\n  // but it does make it get treated as a literal star\n  , [\"\\\\*\", [\"\\\\*\"], {nonull: true}]\n  , [\"\\\\**\", [\"\\\\**\"], {nonull: true}]\n  , [\"\\\\*\\\\*\", [\"\\\\*\\\\*\"], {nonull: true}]\n\n  , [\"b*/\", [\"bdir/\"]]\n  , [\"c*\", [\"c\", \"ca\", \"cb\"]]\n  , [\"**\", files]\n\n  , [\"\\\\.\\\\./*/\", [\"\\\\.\\\\./*/\"], {nonull: true}]\n  , [\"s/\\\\..*//\", [\"s/\\\\..*//\"], {nonull: true}]\n\n  , \"legendary larry crashes bashes\"\n  , [\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\\\1/\"\n    , [\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\\\1/\"], {nonull: true}]\n  , [\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\1/\"\n    , [\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\1/\"], {nonull: true}]\n\n  , \"character classes\"\n  , [\"[a-c]b*\", [\"abc\", \"abd\", \"abe\", \"bb\", \"cb\"]]\n  , [\"[a-y]*[^c]\", [\"abd\", \"abe\", \"bb\", \"bcd\",\n     \"bdir/\", \"ca\", \"cb\", \"dd\", \"de\"]]\n  , [\"a*[^c]\", [\"abd\", \"abe\"]]\n  , function () { files.push(\"a-b\", \"aXb\") }\n  , [\"a[X-]b\", [\"a-b\", \"aXb\"]]\n  , function () { files.push(\".x\", \".y\") }\n  , [\"[^a-c]*\", [\"d\", \"dd\", \"de\"]]\n  , function () { files.push(\"a*b/\", \"a*b/ooo\") }\n  , [\"a\\\\*b/*\", [\"a*b/ooo\"]]\n  , [\"a\\\\*?/*\", [\"a*b/ooo\"]]\n  , [\"*\\\\\\\\!*\", [], {null: true}, [\"echo !7\"]]\n  , [\"*\\\\!*\", [\"echo !7\"], null, [\"echo !7\"]]\n  , [\"*.\\\\*\", [\"r.*\"], null, [\"r.*\"]]\n  , [\"a[b]c\", [\"abc\"]]\n  , [\"a[\\\\b]c\", [\"abc\"]]\n  , [\"a?c\", [\"abc\"]]\n  , [\"a\\\\*c\", [], {null: true}, [\"abc\"]]\n  , [\"\", [\"\"], { null: true }, [\"\"]]\n\n  , \"http://www.opensource.apple.com/source/bash/bash-23/\" +\n    \"bash/tests/glob-test\"\n  , function () { files.push(\"man/\", \"man/man1/\", \"man/man1/bash.1\") }\n  , [\"*/man*/bash.*\", [\"man/man1/bash.1\"]]\n  , [\"man/man1/bash.1\", [\"man/man1/bash.1\"]]\n  , [\"a***c\", [\"abc\"], null, [\"abc\"]]\n  , [\"a*****?c\", [\"abc\"], null, [\"abc\"]]\n  , [\"?*****??\", [\"abc\"], null, [\"abc\"]]\n  , [\"*****??\", [\"abc\"], null, [\"abc\"]]\n  , [\"?*****?c\", [\"abc\"], null, [\"abc\"]]\n  , [\"?***?****c\", [\"abc\"], null, [\"abc\"]]\n  , [\"?***?****?\", [\"abc\"], null, [\"abc\"]]\n  , [\"?***?****\", [\"abc\"], null, [\"abc\"]]\n  , [\"*******c\", [\"abc\"], null, [\"abc\"]]\n  , [\"*******?\", [\"abc\"], null, [\"abc\"]]\n  , [\"a*cd**?**??k\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n  , [\"a**?**cd**?**??k\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n  , [\"a**?**cd**?**??k***\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n  , [\"a**?**cd**?**??***k\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n  , [\"a**?**cd**?**??***k**\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n  , [\"a****c**?**??*****\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n  , [\"[-abc]\", [\"-\"], null, [\"-\"]]\n  , [\"[abc-]\", [\"-\"], null, [\"-\"]]\n  , [\"\\\\\", [\"\\\\\"], null, [\"\\\\\"]]\n  , [\"[\\\\\\\\]\", [\"\\\\\"], null, [\"\\\\\"]]\n  , [\"[[]\", [\"[\"], null, [\"[\"]]\n  , [\"[\", [\"[\"], null, [\"[\"]]\n  , [\"[*\", [\"[abc\"], null, [\"[abc\"]]\n  , \"a right bracket shall lose its special meaning and\\n\" +\n    \"represent itself in a bracket expression if it occurs\\n\" +\n    \"first in the list.  -- POSIX.2 2.8.3.2\"\n  , [\"[]]\", [\"]\"], null, [\"]\"]]\n  , [\"[]-]\", [\"]\"], null, [\"]\"]]\n  , [\"[a-\\z]\", [\"p\"], null, [\"p\"]]\n  , [\"??**********?****?\", [], { null: true }, [\"abc\"]]\n  , [\"??**********?****c\", [], { null: true }, [\"abc\"]]\n  , [\"?************c****?****\", [], { null: true }, [\"abc\"]]\n  , [\"*c*?**\", [], { null: true }, [\"abc\"]]\n  , [\"a*****c*?**\", [], { null: true }, [\"abc\"]]\n  , [\"a********???*******\", [], { null: true }, [\"abc\"]]\n  , [\"[]\", [], { null: true }, [\"a\"]]\n  , [\"[abc\", [], { null: true }, [\"[\"]]\n\n  , \"nocase tests\"\n  , [\"XYZ\", [\"xYz\"], { nocase: true, null: true }\n    , [\"xYz\", \"ABC\", \"IjK\"]]\n  , [\"ab*\", [\"ABC\"], { nocase: true, null: true }\n    , [\"xYz\", \"ABC\", \"IjK\"]]\n  , [\"[ia]?[ck]\", [\"ABC\", \"IjK\"], { nocase: true, null: true }\n    , [\"xYz\", \"ABC\", \"IjK\"]]\n\n  // [ pattern, [matches], MM opts, files, TAP opts]\n  , \"onestar/twostar\"\n  , [\"{/*,*}\", [], {null: true}, [\"/asdf/asdf/asdf\"]]\n  , [\"{/?,*}\", [\"/a\", \"bb\"], {null: true}\n    , [\"/a\", \"/b/b\", \"/a/b/c\", \"bb\"]]\n\n  , \"dots should not match unless requested\"\n  , [\"**\", [\"a/b\"], {}, [\"a/b\", \"a/.d\", \".a/.d\"]]\n\n  // .. and . can only match patterns starting with .,\n  // even when options.dot is set.\n  , function () {\n      files = [\"a/./b\", \"a/../b\", \"a/c/b\", \"a/.d/b\"]\n    }\n  , [\"a/*/b\", [\"a/c/b\", \"a/.d/b\"], {dot: true}]\n  , [\"a/.*/b\", [\"a/./b\", \"a/../b\", \"a/.d/b\"], {dot: true}]\n  , [\"a/*/b\", [\"a/c/b\"], {dot:false}]\n  , [\"a/.*/b\", [\"a/./b\", \"a/../b\", \"a/.d/b\"], {dot: false}]\n\n\n  // this also tests that changing the options needs\n  // to change the cache key, even if the pattern is\n  // the same!\n  , [\"**\", [\"a/b\",\"a/.d\",\".a/.d\"], { dot: true }\n    , [ \".a/.d\", \"a/.d\", \"a/b\"]]\n\n  , \"paren sets cannot contain slashes\"\n  , [\"*(a/b)\", [\"*(a/b)\"], {nonull: true}, [\"a/b\"]]\n\n  // brace sets trump all else.\n  //\n  // invalid glob pattern.  fails on bash4 and bsdglob.\n  // however, in this implementation, it's easier just\n  // to do the intuitive thing, and let brace-expansion\n  // actually come before parsing any extglob patterns,\n  // like the documentation seems to say.\n  //\n  // XXX: if anyone complains about this, either fix it\n  // or tell them to grow up and stop complaining.\n  //\n  // bash/bsdglob says this:\n  // , [\"*(a|{b),c)}\", [\"*(a|{b),c)}\"], {}, [\"a\", \"ab\", \"ac\", \"ad\"]]\n  // but we do this instead:\n  , [\"*(a|{b),c)}\", [\"a\", \"ab\", \"ac\"], {}, [\"a\", \"ab\", \"ac\", \"ad\"]]\n\n  // test partial parsing in the presence of comment/negation chars\n  , [\"[!a*\", [\"[!ab\"], {}, [\"[!ab\", \"[ab\"]]\n  , [\"[#a*\", [\"[#ab\"], {}, [\"[#ab\", \"[ab\"]]\n\n  // like: {a,b|c\\\\,d\\\\\\|e} except it's unclosed, so it has to be escaped.\n  , [\"+(a|*\\\\|c\\\\\\\\|d\\\\\\\\\\\\|e\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\\\\\|g\"\n    , [\"+(a|b\\\\|c\\\\\\\\|d\\\\\\\\|e\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\|g\"]\n    , {}\n    , [\"+(a|b\\\\|c\\\\\\\\|d\\\\\\\\|e\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\|g\", \"a\", \"b\\\\c\"]]\n\n\n  // crazy nested {,,} and *(||) tests.\n  , function () {\n      files = [ \"a\", \"b\", \"c\", \"d\"\n              , \"ab\", \"ac\", \"ad\"\n              , \"bc\", \"cb\"\n              , \"bc,d\", \"c,db\", \"c,d\"\n              , \"d)\", \"(b|c\", \"*(b|c\"\n              , \"b|c\", \"b|cc\", \"cb|c\"\n              , \"x(a|b|c)\", \"x(a|c)\"\n              , \"(a|b|c)\", \"(a|c)\"]\n    }\n  , [\"*(a|{b,c})\", [\"a\", \"b\", \"c\", \"ab\", \"ac\"]]\n  , [\"{a,*(b|c,d)}\", [\"a\",\"(b|c\", \"*(b|c\", \"d)\"]]\n  // a\n  // *(b|c)\n  // *(b|d)\n  , [\"{a,*(b|{c,d})}\", [\"a\",\"b\", \"bc\", \"cb\", \"c\", \"d\"]]\n  , [\"*(a|{b|c,c})\", [\"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", \"cb\"]]\n\n\n  // test various flag settings.\n  , [ \"*(a|{b|c,c})\", [\"x(a|b|c)\", \"x(a|c)\", \"(a|b|c)\", \"(a|c)\"]\n    , { noext: true } ]\n  , [\"a?b\", [\"x/y/acb\", \"acb/\"], {matchBase: true}\n    , [\"x/y/acb\", \"acb/\", \"acb/d/e\", \"x/y/acb/d\"] ]\n  , [\"#*\", [\"#a\", \"#b\"], {nocomment: true}, [\"#a\", \"#b\", \"c#d\"]]\n\n\n  // begin channelling Boole and deMorgan...\n  , \"negation tests\"\n  , function () {\n      files = [\"d\", \"e\", \"!ab\", \"!abc\", \"a!b\", \"\\\\!a\"]\n    }\n\n  // anything that is NOT a* matches.\n  , [\"!a*\", [\"\\\\!a\", \"d\", \"e\", \"!ab\", \"!abc\"]]\n\n  // anything that IS !a* matches.\n  , [\"!a*\", [\"!ab\", \"!abc\"], {nonegate: true}]\n\n  // anything that IS a* matches\n  , [\"!!a*\", [\"a!b\"]]\n\n  // anything that is NOT !a* matches\n  , [\"!\\\\!a*\", [\"a!b\", \"d\", \"e\", \"\\\\!a\"]]\n\n  // negation nestled within a pattern\n  , function () {\n      files = [ \"foo.js\"\n              , \"foo.bar\"\n              // can't match this one without negative lookbehind.\n              , \"foo.js.js\"\n              , \"blar.js\"\n              , \"foo.\"\n              , \"boo.js.boo\" ]\n    }\n  , [\"*.!(js)\", [\"foo.bar\", \"foo.\", \"boo.js.boo\"] ]\n\n  // https://github.com/isaacs/minimatch/issues/5\n  , function () {\n      files = [ 'a/b/.x/c'\n              , 'a/b/.x/c/d'\n              , 'a/b/.x/c/d/e'\n              , 'a/b/.x'\n              , 'a/b/.x/'\n              , 'a/.x/b'\n              , '.x'\n              , '.x/'\n              , '.x/a'\n              , '.x/a/b'\n              , 'a/.x/b/.x/c'\n              , '.x/.x' ]\n  }\n  , [\"**/.x/**\", [ '.x/'\n                 , '.x/a'\n                 , '.x/a/b'\n                 , 'a/.x/b'\n                 , 'a/b/.x/'\n                 , 'a/b/.x/c'\n                 , 'a/b/.x/c/d'\n                 , 'a/b/.x/c/d/e' ] ]\n\n  ]\n\nvar regexps =\n  [ '/^(?:(?=.)a[^/]*?)$/',\n    '/^(?:(?=.)X[^/]*?)$/',\n    '/^(?:(?=.)X[^/]*?)$/',\n    '/^(?:\\\\*)$/',\n    '/^(?:(?=.)\\\\*[^/]*?)$/',\n    '/^(?:\\\\*\\\\*)$/',\n    '/^(?:(?=.)b[^/]*?\\\\/)$/',\n    '/^(?:(?=.)c[^/]*?)$/',\n    '/^(?:(?:(?!(?:\\\\/|^)\\\\.).)*?)$/',\n    '/^(?:\\\\.\\\\.\\\\/(?!\\\\.)(?=.)[^/]*?\\\\/)$/',\n    '/^(?:s\\\\/(?=.)\\\\.\\\\.[^/]*?\\\\/)$/',\n    '/^(?:\\\\/\\\\^root:\\\\/\\\\{s\\\\/(?=.)\\\\^[^:][^/]*?:[^:][^/]*?:\\\\([^:]\\\\)[^/]*?\\\\.[^/]*?\\\\$\\\\/1\\\\/)$/',\n    '/^(?:\\\\/\\\\^root:\\\\/\\\\{s\\\\/(?=.)\\\\^[^:][^/]*?:[^:][^/]*?:\\\\([^:]\\\\)[^/]*?\\\\.[^/]*?\\\\$\\\\/\\u0001\\\\/)$/',\n    '/^(?:(?!\\\\.)(?=.)[a-c]b[^/]*?)$/',\n    '/^(?:(?!\\\\.)(?=.)[a-y][^/]*?[^c])$/',\n    '/^(?:(?=.)a[^/]*?[^c])$/',\n    '/^(?:(?=.)a[X-]b)$/',\n    '/^(?:(?!\\\\.)(?=.)[^a-c][^/]*?)$/',\n    '/^(?:a\\\\*b\\\\/(?!\\\\.)(?=.)[^/]*?)$/',\n    '/^(?:(?=.)a\\\\*[^/]\\\\/(?!\\\\.)(?=.)[^/]*?)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?\\\\\\\\\\\\![^/]*?)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?\\\\![^/]*?)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?\\\\.\\\\*)$/',\n    '/^(?:(?=.)a[b]c)$/',\n    '/^(?:(?=.)a[b]c)$/',\n    '/^(?:(?=.)a[^/]c)$/',\n    '/^(?:a\\\\*c)$/',\n    'false',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?\\\\/(?=.)man[^/]*?\\\\/(?=.)bash\\\\.[^/]*?)$/',\n    '/^(?:man\\\\/man1\\\\/bash\\\\.1)$/',\n    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?c)$/',\n    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]c)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/])$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/])$/',\n    '/^(?:(?!\\\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]c)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?c)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',\n    '/^(?:(?!\\\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',\n    '/^(?:(?=.)a[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k)$/',\n    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k)$/',\n    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k[^/]*?[^/]*?[^/]*?)$/',\n    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?k)$/',\n    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?k[^/]*?[^/]*?)$/',\n    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?)$/',\n    '/^(?:(?!\\\\.)(?=.)[-abc])$/',\n    '/^(?:(?!\\\\.)(?=.)[abc-])$/',\n    '/^(?:\\\\\\\\)$/',\n    '/^(?:(?!\\\\.)(?=.)[\\\\\\\\])$/',\n    '/^(?:(?!\\\\.)(?=.)[\\\\[])$/',\n    '/^(?:\\\\[)$/',\n    '/^(?:(?=.)\\\\[(?!\\\\.)(?=.)[^/]*?)$/',\n    '/^(?:(?!\\\\.)(?=.)[\\\\]])$/',\n    '/^(?:(?!\\\\.)(?=.)[\\\\]-])$/',\n    '/^(?:(?!\\\\.)(?=.)[a-z])$/',\n    '/^(?:(?!\\\\.)(?=.)[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',\n    '/^(?:(?!\\\\.)(?=.)[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?c)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?c[^/]*?[^/][^/]*?[^/]*?)$/',\n    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/][^/]*?[^/]*?)$/',\n    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?)$/',\n    '/^(?:\\\\[\\\\])$/',\n    '/^(?:\\\\[abc)$/',\n    '/^(?:(?=.)XYZ)$/i',\n    '/^(?:(?=.)ab[^/]*?)$/i',\n    '/^(?:(?!\\\\.)(?=.)[ia][^/][ck])$/i',\n    '/^(?:\\\\/(?!\\\\.)(?=.)[^/]*?|(?!\\\\.)(?=.)[^/]*?)$/',\n    '/^(?:\\\\/(?!\\\\.)(?=.)[^/]|(?!\\\\.)(?=.)[^/]*?)$/',\n    '/^(?:(?:(?!(?:\\\\/|^)\\\\.).)*?)$/',\n    '/^(?:a\\\\/(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))(?=.)[^/]*?\\\\/b)$/',\n    '/^(?:a\\\\/(?=.)\\\\.[^/]*?\\\\/b)$/',\n    '/^(?:a\\\\/(?!\\\\.)(?=.)[^/]*?\\\\/b)$/',\n    '/^(?:a\\\\/(?=.)\\\\.[^/]*?\\\\/b)$/',\n    '/^(?:(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?\\\\(a\\\\/b\\\\))$/',\n    '/^(?:(?!\\\\.)(?=.)(?:a|b)*|(?!\\\\.)(?=.)(?:a|c)*)$/',\n    '/^(?:(?=.)\\\\[(?=.)\\\\!a[^/]*?)$/',\n    '/^(?:(?=.)\\\\[(?=.)#a[^/]*?)$/',\n    '/^(?:(?=.)\\\\+\\\\(a\\\\|[^/]*?\\\\|c\\\\\\\\\\\\\\\\\\\\|d\\\\\\\\\\\\\\\\\\\\|e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|g)$/',\n    '/^(?:(?!\\\\.)(?=.)(?:a|b)*|(?!\\\\.)(?=.)(?:a|c)*)$/',\n    '/^(?:a|(?!\\\\.)(?=.)[^/]*?\\\\(b\\\\|c|d\\\\))$/',\n    '/^(?:a|(?!\\\\.)(?=.)(?:b|c)*|(?!\\\\.)(?=.)(?:b|d)*)$/',\n    '/^(?:(?!\\\\.)(?=.)(?:a|b|c)*|(?!\\\\.)(?=.)(?:a|c)*)$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?\\\\(a\\\\|b\\\\|c\\\\)|(?!\\\\.)(?=.)[^/]*?\\\\(a\\\\|c\\\\))$/',\n    '/^(?:(?=.)a[^/]b)$/',\n    '/^(?:(?=.)#[^/]*?)$/',\n    '/^(?!^(?:(?=.)a[^/]*?)$).*$/',\n    '/^(?:(?=.)\\\\!a[^/]*?)$/',\n    '/^(?:(?=.)a[^/]*?)$/',\n    '/^(?!^(?:(?=.)\\\\!a[^/]*?)$).*$/',\n    '/^(?:(?!\\\\.)(?=.)[^/]*?\\\\.(?:(?!js)[^/]*?))$/',\n    '/^(?:(?:(?!(?:\\\\/|^)\\\\.).)*?\\\\/\\\\.x\\\\/(?:(?!(?:\\\\/|^)\\\\.).)*?)$/' ]\nvar re = 0;\n\ntap.test(\"basic tests\", function (t) {\n  var start = Date.now()\n\n  // [ pattern, [matches], MM opts, files, TAP opts]\n  patterns.forEach(function (c) {\n    if (typeof c === \"function\") return c()\n    if (typeof c === \"string\") return t.comment(c)\n\n    var pattern = c[0]\n      , expect = c[1].sort(alpha)\n      , options = c[2] || {}\n      , f = c[3] || files\n      , tapOpts = c[4] || {}\n\n    // options.debug = true\n    var m = new mm.Minimatch(pattern, options)\n    var r = m.makeRe()\n    var expectRe = regexps[re++]\n    tapOpts.re = String(r) || JSON.stringify(r)\n    tapOpts.files = JSON.stringify(f)\n    tapOpts.pattern = pattern\n    tapOpts.set = m.set\n    tapOpts.negated = m.negate\n\n    var actual = mm.match(f, pattern, options)\n    actual.sort(alpha)\n\n    t.equivalent( actual, expect\n                , JSON.stringify(pattern) + \" \" + JSON.stringify(expect)\n                , tapOpts )\n\n    t.equal(tapOpts.re, expectRe, tapOpts)\n  })\n\n  t.comment(\"time=\" + (Date.now() - start) + \"ms\")\n  t.end()\n})\n\ntap.test(\"global leak test\", function (t) {\n  var globalAfter = Object.keys(global)\n  t.equivalent(globalAfter, globalBefore, \"no new globals, please\")\n  t.end()\n})\n\nfunction alpha (a, b) {\n  return a > b ? 1 : -1\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/test/brace-expand.js": "var tap = require(\"tap\")\n  , minimatch = require(\"../\")\n\ntap.test(\"brace expansion\", function (t) {\n  // [ pattern, [expanded] ]\n  ; [ [ \"a{b,c{d,e},{f,g}h}x{y,z}\"\n      , [ \"abxy\"\n        , \"abxz\"\n        , \"acdxy\"\n        , \"acdxz\"\n        , \"acexy\"\n        , \"acexz\"\n        , \"afhxy\"\n        , \"afhxz\"\n        , \"aghxy\"\n        , \"aghxz\" ] ]\n    , [ \"a{1..5}b\"\n      , [ \"a1b\"\n        , \"a2b\"\n        , \"a3b\"\n        , \"a4b\"\n        , \"a5b\" ] ]\n    , [ \"a{b}c\", [\"a{b}c\"] ]\n  ].forEach(function (tc) {\n    var p = tc[0]\n      , expect = tc[1]\n    t.equivalent(minimatch.braceExpand(p), expect, p)\n  })\n  console.error(\"ending\")\n  t.end()\n})\n\n\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/test/caching.js": "var Minimatch = require(\"../minimatch.js\").Minimatch\nvar tap = require(\"tap\")\ntap.test(\"cache test\", function (t) {\n  var mm1 = new Minimatch(\"a?b\")\n  var mm2 = new Minimatch(\"a?b\")\n  t.equal(mm1, mm2, \"should get the same object\")\n  // the lru should drop it after 100 entries\n  for (var i = 0; i < 100; i ++) {\n    new Minimatch(\"a\"+i)\n  }\n  mm2 = new Minimatch(\"a?b\")\n  t.notEqual(mm1, mm2, \"cache should have dropped\")\n  t.end()\n})\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/test/defaults.js": "// http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test\n//\n// TODO: Some of these tests do very bad things with backslashes, and will\n// most likely fail badly on windows.  They should probably be skipped.\n\nvar tap = require(\"tap\")\n  , globalBefore = Object.keys(global)\n  , mm = require(\"../\")\n  , files = [ \"a\", \"b\", \"c\", \"d\", \"abc\"\n            , \"abd\", \"abe\", \"bb\", \"bcd\"\n            , \"ca\", \"cb\", \"dd\", \"de\"\n            , \"bdir/\", \"bdir/cfile\"]\n  , next = files.concat([ \"a-b\", \"aXb\"\n                        , \".x\", \".y\" ])\n\ntap.test(\"basic tests\", function (t) {\n  var start = Date.now()\n\n  // [ pattern, [matches], MM opts, files, TAP opts]\n  ; [ \"http://www.bashcookbook.com/bashinfo\" +\n      \"/source/bash-1.14.7/tests/glob-test\"\n    , [\"a*\", [\"a\", \"abc\", \"abd\", \"abe\"]]\n    , [\"X*\", [\"X*\"], {nonull: true}]\n\n    // allow null glob expansion\n    , [\"X*\", []]\n\n    // isaacs: Slightly different than bash/sh/ksh\n    // \\\\* is not un-escaped to literal \"*\" in a failed match,\n    // but it does make it get treated as a literal star\n    , [\"\\\\*\", [\"\\\\*\"], {nonull: true}]\n    , [\"\\\\**\", [\"\\\\**\"], {nonull: true}]\n    , [\"\\\\*\\\\*\", [\"\\\\*\\\\*\"], {nonull: true}]\n\n    , [\"b*/\", [\"bdir/\"]]\n    , [\"c*\", [\"c\", \"ca\", \"cb\"]]\n    , [\"**\", files]\n\n    , [\"\\\\.\\\\./*/\", [\"\\\\.\\\\./*/\"], {nonull: true}]\n    , [\"s/\\\\..*//\", [\"s/\\\\..*//\"], {nonull: true}]\n\n    , \"legendary larry crashes bashes\"\n    , [\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\\\1/\"\n      , [\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\\\1/\"], {nonull: true}]\n    , [\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\1/\"\n      , [\"/^root:/{s/^[^:]*:[^:]*:\\([^:]*\\).*$/\\1/\"], {nonull: true}]\n\n    , \"character classes\"\n    , [\"[a-c]b*\", [\"abc\", \"abd\", \"abe\", \"bb\", \"cb\"]]\n    , [\"[a-y]*[^c]\", [\"abd\", \"abe\", \"bb\", \"bcd\",\n       \"bdir/\", \"ca\", \"cb\", \"dd\", \"de\"]]\n    , [\"a*[^c]\", [\"abd\", \"abe\"]]\n    , function () { files.push(\"a-b\", \"aXb\") }\n    , [\"a[X-]b\", [\"a-b\", \"aXb\"]]\n    , function () { files.push(\".x\", \".y\") }\n    , [\"[^a-c]*\", [\"d\", \"dd\", \"de\"]]\n    , function () { files.push(\"a*b/\", \"a*b/ooo\") }\n    , [\"a\\\\*b/*\", [\"a*b/ooo\"]]\n    , [\"a\\\\*?/*\", [\"a*b/ooo\"]]\n    , [\"*\\\\\\\\!*\", [], {null: true}, [\"echo !7\"]]\n    , [\"*\\\\!*\", [\"echo !7\"], null, [\"echo !7\"]]\n    , [\"*.\\\\*\", [\"r.*\"], null, [\"r.*\"]]\n    , [\"a[b]c\", [\"abc\"]]\n    , [\"a[\\\\b]c\", [\"abc\"]]\n    , [\"a?c\", [\"abc\"]]\n    , [\"a\\\\*c\", [], {null: true}, [\"abc\"]]\n    , [\"\", [\"\"], { null: true }, [\"\"]]\n\n    , \"http://www.opensource.apple.com/source/bash/bash-23/\" +\n      \"bash/tests/glob-test\"\n    , function () { files.push(\"man/\", \"man/man1/\", \"man/man1/bash.1\") }\n    , [\"*/man*/bash.*\", [\"man/man1/bash.1\"]]\n    , [\"man/man1/bash.1\", [\"man/man1/bash.1\"]]\n    , [\"a***c\", [\"abc\"], null, [\"abc\"]]\n    , [\"a*****?c\", [\"abc\"], null, [\"abc\"]]\n    , [\"?*****??\", [\"abc\"], null, [\"abc\"]]\n    , [\"*****??\", [\"abc\"], null, [\"abc\"]]\n    , [\"?*****?c\", [\"abc\"], null, [\"abc\"]]\n    , [\"?***?****c\", [\"abc\"], null, [\"abc\"]]\n    , [\"?***?****?\", [\"abc\"], null, [\"abc\"]]\n    , [\"?***?****\", [\"abc\"], null, [\"abc\"]]\n    , [\"*******c\", [\"abc\"], null, [\"abc\"]]\n    , [\"*******?\", [\"abc\"], null, [\"abc\"]]\n    , [\"a*cd**?**??k\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n    , [\"a**?**cd**?**??k\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n    , [\"a**?**cd**?**??k***\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n    , [\"a**?**cd**?**??***k\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n    , [\"a**?**cd**?**??***k**\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n    , [\"a****c**?**??*****\", [\"abcdecdhjk\"], null, [\"abcdecdhjk\"]]\n    , [\"[-abc]\", [\"-\"], null, [\"-\"]]\n    , [\"[abc-]\", [\"-\"], null, [\"-\"]]\n    , [\"\\\\\", [\"\\\\\"], null, [\"\\\\\"]]\n    , [\"[\\\\\\\\]\", [\"\\\\\"], null, [\"\\\\\"]]\n    , [\"[[]\", [\"[\"], null, [\"[\"]]\n    , [\"[\", [\"[\"], null, [\"[\"]]\n    , [\"[*\", [\"[abc\"], null, [\"[abc\"]]\n    , \"a right bracket shall lose its special meaning and\\n\" +\n      \"represent itself in a bracket expression if it occurs\\n\" +\n      \"first in the list.  -- POSIX.2 2.8.3.2\"\n    , [\"[]]\", [\"]\"], null, [\"]\"]]\n    , [\"[]-]\", [\"]\"], null, [\"]\"]]\n    , [\"[a-\\z]\", [\"p\"], null, [\"p\"]]\n    , [\"??**********?****?\", [], { null: true }, [\"abc\"]]\n    , [\"??**********?****c\", [], { null: true }, [\"abc\"]]\n    , [\"?************c****?****\", [], { null: true }, [\"abc\"]]\n    , [\"*c*?**\", [], { null: true }, [\"abc\"]]\n    , [\"a*****c*?**\", [], { null: true }, [\"abc\"]]\n    , [\"a********???*******\", [], { null: true }, [\"abc\"]]\n    , [\"[]\", [], { null: true }, [\"a\"]]\n    , [\"[abc\", [], { null: true }, [\"[\"]]\n\n    , \"nocase tests\"\n    , [\"XYZ\", [\"xYz\"], { nocase: true, null: true }\n      , [\"xYz\", \"ABC\", \"IjK\"]]\n    , [\"ab*\", [\"ABC\"], { nocase: true, null: true }\n      , [\"xYz\", \"ABC\", \"IjK\"]]\n    , [\"[ia]?[ck]\", [\"ABC\", \"IjK\"], { nocase: true, null: true }\n      , [\"xYz\", \"ABC\", \"IjK\"]]\n\n    // [ pattern, [matches], MM opts, files, TAP opts]\n    , \"onestar/twostar\"\n    , [\"{/*,*}\", [], {null: true}, [\"/asdf/asdf/asdf\"]]\n    , [\"{/?,*}\", [\"/a\", \"bb\"], {null: true}\n      , [\"/a\", \"/b/b\", \"/a/b/c\", \"bb\"]]\n\n    , \"dots should not match unless requested\"\n    , [\"**\", [\"a/b\"], {}, [\"a/b\", \"a/.d\", \".a/.d\"]]\n\n    // .. and . can only match patterns starting with .,\n    // even when options.dot is set.\n    , function () {\n        files = [\"a/./b\", \"a/../b\", \"a/c/b\", \"a/.d/b\"]\n      }\n    , [\"a/*/b\", [\"a/c/b\", \"a/.d/b\"], {dot: true}]\n    , [\"a/.*/b\", [\"a/./b\", \"a/../b\", \"a/.d/b\"], {dot: true}]\n    , [\"a/*/b\", [\"a/c/b\"], {dot:false}]\n    , [\"a/.*/b\", [\"a/./b\", \"a/../b\", \"a/.d/b\"], {dot: false}]\n\n\n    // this also tests that changing the options needs\n    // to change the cache key, even if the pattern is\n    // the same!\n    , [\"**\", [\"a/b\",\"a/.d\",\".a/.d\"], { dot: true }\n      , [ \".a/.d\", \"a/.d\", \"a/b\"]]\n\n    , \"paren sets cannot contain slashes\"\n    , [\"*(a/b)\", [\"*(a/b)\"], {nonull: true}, [\"a/b\"]]\n\n    // brace sets trump all else.\n    //\n    // invalid glob pattern.  fails on bash4 and bsdglob.\n    // however, in this implementation, it's easier just\n    // to do the intuitive thing, and let brace-expansion\n    // actually come before parsing any extglob patterns,\n    // like the documentation seems to say.\n    //\n    // XXX: if anyone complains about this, either fix it\n    // or tell them to grow up and stop complaining.\n    //\n    // bash/bsdglob says this:\n    // , [\"*(a|{b),c)}\", [\"*(a|{b),c)}\"], {}, [\"a\", \"ab\", \"ac\", \"ad\"]]\n    // but we do this instead:\n    , [\"*(a|{b),c)}\", [\"a\", \"ab\", \"ac\"], {}, [\"a\", \"ab\", \"ac\", \"ad\"]]\n\n    // test partial parsing in the presence of comment/negation chars\n    , [\"[!a*\", [\"[!ab\"], {}, [\"[!ab\", \"[ab\"]]\n    , [\"[#a*\", [\"[#ab\"], {}, [\"[#ab\", \"[ab\"]]\n\n    // like: {a,b|c\\\\,d\\\\\\|e} except it's unclosed, so it has to be escaped.\n    , [\"+(a|*\\\\|c\\\\\\\\|d\\\\\\\\\\\\|e\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\\\\\|g\"\n      , [\"+(a|b\\\\|c\\\\\\\\|d\\\\\\\\|e\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\|g\"]\n      , {}\n      , [\"+(a|b\\\\|c\\\\\\\\|d\\\\\\\\|e\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\|g\", \"a\", \"b\\\\c\"]]\n\n\n    // crazy nested {,,} and *(||) tests.\n    , function () {\n        files = [ \"a\", \"b\", \"c\", \"d\"\n                , \"ab\", \"ac\", \"ad\"\n                , \"bc\", \"cb\"\n                , \"bc,d\", \"c,db\", \"c,d\"\n                , \"d)\", \"(b|c\", \"*(b|c\"\n                , \"b|c\", \"b|cc\", \"cb|c\"\n                , \"x(a|b|c)\", \"x(a|c)\"\n                , \"(a|b|c)\", \"(a|c)\"]\n      }\n    , [\"*(a|{b,c})\", [\"a\", \"b\", \"c\", \"ab\", \"ac\"]]\n    , [\"{a,*(b|c,d)}\", [\"a\",\"(b|c\", \"*(b|c\", \"d)\"]]\n    // a\n    // *(b|c)\n    // *(b|d)\n    , [\"{a,*(b|{c,d})}\", [\"a\",\"b\", \"bc\", \"cb\", \"c\", \"d\"]]\n    , [\"*(a|{b|c,c})\", [\"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", \"cb\"]]\n\n\n    // test various flag settings.\n    , [ \"*(a|{b|c,c})\", [\"x(a|b|c)\", \"x(a|c)\", \"(a|b|c)\", \"(a|c)\"]\n      , { noext: true } ]\n    , [\"a?b\", [\"x/y/acb\", \"acb/\"], {matchBase: true}\n      , [\"x/y/acb\", \"acb/\", \"acb/d/e\", \"x/y/acb/d\"] ]\n    , [\"#*\", [\"#a\", \"#b\"], {nocomment: true}, [\"#a\", \"#b\", \"c#d\"]]\n\n\n    // begin channelling Boole and deMorgan...\n    , \"negation tests\"\n    , function () {\n        files = [\"d\", \"e\", \"!ab\", \"!abc\", \"a!b\", \"\\\\!a\"]\n      }\n\n    // anything that is NOT a* matches.\n    , [\"!a*\", [\"\\\\!a\", \"d\", \"e\", \"!ab\", \"!abc\"]]\n\n    // anything that IS !a* matches.\n    , [\"!a*\", [\"!ab\", \"!abc\"], {nonegate: true}]\n\n    // anything that IS a* matches\n    , [\"!!a*\", [\"a!b\"]]\n\n    // anything that is NOT !a* matches\n    , [\"!\\\\!a*\", [\"a!b\", \"d\", \"e\", \"\\\\!a\"]]\n\n    // negation nestled within a pattern\n    , function () {\n        files = [ \"foo.js\"\n                , \"foo.bar\"\n                // can't match this one without negative lookbehind.\n                , \"foo.js.js\"\n                , \"blar.js\"\n                , \"foo.\"\n                , \"boo.js.boo\" ]\n      }\n    , [\"*.!(js)\", [\"foo.bar\", \"foo.\", \"boo.js.boo\"] ]\n\n    ].forEach(function (c) {\n      if (typeof c === \"function\") return c()\n      if (typeof c === \"string\") return t.comment(c)\n\n      var pattern = c[0]\n        , expect = c[1].sort(alpha)\n        , options = c[2] || {}\n        , f = c[3] || files\n        , tapOpts = c[4] || {}\n\n      // options.debug = true\n      var Class = mm.defaults(options).Minimatch\n      var m = new Class(pattern, {})\n      var r = m.makeRe()\n      tapOpts.re = String(r) || JSON.stringify(r)\n      tapOpts.files = JSON.stringify(f)\n      tapOpts.pattern = pattern\n      tapOpts.set = m.set\n      tapOpts.negated = m.negate\n\n      var actual = mm.match(f, pattern, options)\n      actual.sort(alpha)\n\n      t.equivalent( actual, expect\n                  , JSON.stringify(pattern) + \" \" + JSON.stringify(expect)\n                  , tapOpts )\n    })\n\n  t.comment(\"time=\" + (Date.now() - start) + \"ms\")\n  t.end()\n})\n\ntap.test(\"global leak test\", function (t) {\n  var globalAfter = Object.keys(global)\n  t.equivalent(globalAfter, globalBefore, \"no new globals, please\")\n  t.end()\n})\n\nfunction alpha (a, b) {\n  return a > b ? 1 : -1\n}\n",
  "node_modules/mocha/node_modules/glob/node_modules/minimatch/test/extglob-ending-with-state-char.js": "var test = require('tap').test\nvar minimatch = require('../')\n\ntest('extglob ending with statechar', function(t) {\n  t.notOk(minimatch('ax', 'a?(b*)'))\n  t.ok(minimatch('ax', '?(a*|b)'))\n  t.end()\n})\n",
  "node_modules/mocha/node_modules/glob/package.json": "{\n  \"author\": {\n    \"name\": \"Isaac Z. Schlueter\",\n    \"email\": \"i@izs.me\",\n    \"url\": \"http://blog.izs.me/\"\n  },\n  \"name\": \"glob\",\n  \"description\": \"a little globber\",\n  \"version\": \"3.2.3\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/isaacs/node-glob.git\"\n  },\n  \"main\": \"glob.js\",\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"dependencies\": {\n    \"minimatch\": \"~0.2.11\",\n    \"graceful-fs\": \"~2.0.0\",\n    \"inherits\": \"2\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"~0.4.0\",\n    \"mkdirp\": \"0\",\n    \"rimraf\": \"1\"\n  },\n  \"scripts\": {\n    \"test\": \"tap test/*.js\"\n  },\n  \"license\": \"BSD\",\n  \"bugs\": {\n    \"url\": \"https://github.com/isaacs/node-glob/issues\"\n  },\n  \"_id\": \"glob@3.2.3\",\n  \"dist\": {\n    \"shasum\": \"e313eeb249c7affaa5c475286b0e115b59839467\",\n    \"tarball\": \"http://registry.npmjs.org/glob/-/glob-3.2.3.tgz\"\n  },\n  \"_from\": \"glob@3.2.3\",\n  \"_npmVersion\": \"1.3.2\",\n  \"_npmUser\": {\n    \"name\": \"isaacs\",\n    \"email\": \"i@izs.me\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"isaacs\",\n      \"email\": \"i@izs.me\"\n    }\n  ],\n  \"directories\": {},\n  \"_shasum\": \"e313eeb249c7affaa5c475286b0e115b59839467\",\n  \"_resolved\": \"https://registry.npmjs.org/glob/-/glob-3.2.3.tgz\",\n  \"readme\": \"ERROR: No README data found!\",\n  \"homepage\": \"https://github.com/isaacs/node-glob#readme\"\n}\n",
  "node_modules/mocha/node_modules/glob/test/00-setup.js": "// just a little pre-run script to set up the fixtures.\n// zz-finish cleans it up\n\nvar mkdirp = require(\"mkdirp\")\nvar path = require(\"path\")\nvar i = 0\nvar tap = require(\"tap\")\nvar fs = require(\"fs\")\nvar rimraf = require(\"rimraf\")\n\nvar files =\n[ \"a/.abcdef/x/y/z/a\"\n, \"a/abcdef/g/h\"\n, \"a/abcfed/g/h\"\n, \"a/b/c/d\"\n, \"a/bc/e/f\"\n, \"a/c/d/c/b\"\n, \"a/cb/e/f\"\n]\n\nvar symlinkTo = path.resolve(__dirname, \"a/symlink/a/b/c\")\nvar symlinkFrom = \"../..\"\n\nfiles = files.map(function (f) {\n  return path.resolve(__dirname, f)\n})\n\ntap.test(\"remove fixtures\", function (t) {\n  rimraf(path.resolve(__dirname, \"a\"), function (er) {\n    t.ifError(er, \"remove fixtures\")\n    t.end()\n  })\n})\n\nfiles.forEach(function (f) {\n  tap.test(f, function (t) {\n    var d = path.dirname(f)\n    mkdirp(d, 0755, function (er) {\n      if (er) {\n        t.fail(er)\n        return t.bailout()\n      }\n      fs.writeFile(f, \"i like tests\", function (er) {\n        t.ifError(er, \"make file\")\n        t.end()\n      })\n    })\n  })\n})\n\nif (process.platform !== \"win32\") {\n  tap.test(\"symlinky\", function (t) {\n    var d = path.dirname(symlinkTo)\n    console.error(\"mkdirp\", d)\n    mkdirp(d, 0755, function (er) {\n      t.ifError(er)\n      fs.symlink(symlinkFrom, symlinkTo, \"dir\", function (er) {\n        t.ifError(er, \"make symlink\")\n        t.end()\n      })\n    })\n  })\n}\n\n;[\"foo\",\"bar\",\"baz\",\"asdf\",\"quux\",\"qwer\",\"rewq\"].forEach(function (w) {\n  w = \"/tmp/glob-test/\" + w\n  tap.test(\"create \" + w, function (t) {\n    mkdirp(w, function (er) {\n      if (er)\n        throw er\n      t.pass(w)\n      t.end()\n    })\n  })\n})\n\n\n// generate the bash pattern test-fixtures if possible\nif (process.platform === \"win32\" || !process.env.TEST_REGEN) {\n  console.error(\"Windows, or TEST_REGEN unset.  Using cached fixtures.\")\n  return\n}\n\nvar spawn = require(\"child_process\").spawn;\nvar globs =\n  // put more patterns here.\n  // anything that would be directly in / should be in /tmp/glob-test\n  [\"test/a/*/+(c|g)/./d\"\n  ,\"test/a/**/[cg]/../[cg]\"\n  ,\"test/a/{b,c,d,e,f}/**/g\"\n  ,\"test/a/b/**\"\n  ,\"test/**/g\"\n  ,\"test/a/abc{fed,def}/g/h\"\n  ,\"test/a/abc{fed/g,def}/**/\"\n  ,\"test/a/abc{fed/g,def}/**///**/\"\n  ,\"test/**/a/**/\"\n  ,\"test/+(a|b|c)/a{/,bc*}/**\"\n  ,\"test/*/*/*/f\"\n  ,\"test/**/f\"\n  ,\"test/a/symlink/a/b/c/a/b/c/a/b/c//a/b/c////a/b/c/**/b/c/**\"\n  ,\"{./*/*,/tmp/glob-test/*}\"\n  ,\"{/tmp/glob-test/*,*}\" // evil owl face!  how you taunt me!\n  ,\"test/a/!(symlink)/**\"\n  ]\nvar bashOutput = {}\nvar fs = require(\"fs\")\n\nglobs.forEach(function (pattern) {\n  tap.test(\"generate fixture \" + pattern, function (t) {\n    var cmd = \"shopt -s globstar && \" +\n              \"shopt -s extglob && \" +\n              \"shopt -s nullglob && \" +\n              // \"shopt >&2; \" +\n              \"eval \\'for i in \" + pattern + \"; do echo $i; done\\'\"\n    var cp = spawn(\"bash\", [\"-c\", cmd], { cwd: path.dirname(__dirname) })\n    var out = []\n    cp.stdout.on(\"data\", function (c) {\n      out.push(c)\n    })\n    cp.stderr.pipe(process.stderr)\n    cp.on(\"close\", function (code) {\n      out = flatten(out)\n      if (!out)\n        out = []\n      else\n        out = cleanResults(out.split(/\\r*\\n/))\n\n      bashOutput[pattern] = out\n      t.notOk(code, \"bash test should finish nicely\")\n      t.end()\n    })\n  })\n})\n\ntap.test(\"save fixtures\", function (t) {\n  var fname = path.resolve(__dirname, \"bash-results.json\")\n  var data = JSON.stringify(bashOutput, null, 2) + \"\\n\"\n  fs.writeFile(fname, data, function (er) {\n    t.ifError(er)\n    t.end()\n  })\n})\n\nfunction cleanResults (m) {\n  // normalize discrepancies in ordering, duplication,\n  // and ending slashes.\n  return m.map(function (m) {\n    return m.replace(/\\/+/g, \"/\").replace(/\\/$/, \"\")\n  }).sort(alphasort).reduce(function (set, f) {\n    if (f !== set[set.length - 1]) set.push(f)\n    return set\n  }, []).sort(alphasort).map(function (f) {\n    // de-windows\n    return (process.platform !== 'win32') ? f\n           : f.replace(/^[a-zA-Z]:\\\\\\\\/, '/').replace(/\\\\/g, '/')\n  })\n}\n\nfunction flatten (chunks) {\n  var s = 0\n  chunks.forEach(function (c) { s += c.length })\n  var out = new Buffer(s)\n  s = 0\n  chunks.forEach(function (c) {\n    c.copy(out, s)\n    s += c.length\n  })\n\n  return out.toString().trim()\n}\n\nfunction alphasort (a, b) {\n  a = a.toLowerCase()\n  b = b.toLowerCase()\n  return a > b ? 1 : a < b ? -1 : 0\n}\n",
  "node_modules/mocha/node_modules/glob/test/bash-comparison.js": "// basic test\n// show that it does the same thing by default as the shell.\nvar tap = require(\"tap\")\n, child_process = require(\"child_process\")\n, bashResults = require(\"./bash-results.json\")\n, globs = Object.keys(bashResults)\n, glob = require(\"../\")\n, path = require(\"path\")\n\n// run from the root of the project\n// this is usually where you're at anyway, but be sure.\nprocess.chdir(path.resolve(__dirname, \"..\"))\n\nfunction alphasort (a, b) {\n  a = a.toLowerCase()\n  b = b.toLowerCase()\n  return a > b ? 1 : a < b ? -1 : 0\n}\n\nglobs.forEach(function (pattern) {\n  var expect = bashResults[pattern]\n  // anything regarding the symlink thing will fail on windows, so just skip it\n  if (process.platform === \"win32\" &&\n      expect.some(function (m) {\n        return /\\/symlink\\//.test(m)\n      }))\n    return\n\n  tap.test(pattern, function (t) {\n    glob(pattern, function (er, matches) {\n      if (er)\n        throw er\n\n      // sort and unmark, just to match the shell results\n      matches = cleanResults(matches)\n\n      t.deepEqual(matches, expect, pattern)\n      t.end()\n    })\n  })\n\n  tap.test(pattern + \" sync\", function (t) {\n    var matches = cleanResults(glob.sync(pattern))\n\n    t.deepEqual(matches, expect, \"should match shell\")\n    t.end()\n  })\n})\n\nfunction cleanResults (m) {\n  // normalize discrepancies in ordering, duplication,\n  // and ending slashes.\n  return m.map(function (m) {\n    return m.replace(/\\/+/g, \"/\").replace(/\\/$/, \"\")\n  }).sort(alphasort).reduce(function (set, f) {\n    if (f !== set[set.length - 1]) set.push(f)\n    return set\n  }, []).sort(alphasort).map(function (f) {\n    // de-windows\n    return (process.platform !== 'win32') ? f\n           : f.replace(/^[a-zA-Z]:[\\/\\\\]+/, '/').replace(/[\\\\\\/]+/g, '/')\n  })\n}\n",
  "node_modules/mocha/node_modules/glob/test/bash-results.json": "{\n  \"test/a/*/+(c|g)/./d\": [\n    \"test/a/b/c/./d\"\n  ],\n  \"test/a/**/[cg]/../[cg]\": [\n    \"test/a/abcdef/g/../g\",\n    \"test/a/abcfed/g/../g\",\n    \"test/a/b/c/../c\",\n    \"test/a/c/../c\",\n    \"test/a/c/d/c/../c\",\n    \"test/a/symlink/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/../c\"\n  ],\n  \"test/a/{b,c,d,e,f}/**/g\": [],\n  \"test/a/b/**\": [\n    \"test/a/b\",\n    \"test/a/b/c\",\n    \"test/a/b/c/d\"\n  ],\n  \"test/**/g\": [\n    \"test/a/abcdef/g\",\n    \"test/a/abcfed/g\"\n  ],\n  \"test/a/abc{fed,def}/g/h\": [\n    \"test/a/abcdef/g/h\",\n    \"test/a/abcfed/g/h\"\n  ],\n  \"test/a/abc{fed/g,def}/**/\": [\n    \"test/a/abcdef\",\n    \"test/a/abcdef/g\",\n    \"test/a/abcfed/g\"\n  ],\n  \"test/a/abc{fed/g,def}/**///**/\": [\n    \"test/a/abcdef\",\n    \"test/a/abcdef/g\",\n    \"test/a/abcfed/g\"\n  ],\n  \"test/**/a/**/\": [\n    \"test/a\",\n    \"test/a/abcdef\",\n    \"test/a/abcdef/g\",\n    \"test/a/abcfed\",\n    \"test/a/abcfed/g\",\n    \"test/a/b\",\n    \"test/a/b/c\",\n    \"test/a/bc\",\n    \"test/a/bc/e\",\n    \"test/a/c\",\n    \"test/a/c/d\",\n    \"test/a/c/d/c\",\n    \"test/a/cb\",\n    \"test/a/cb/e\",\n    \"test/a/symlink\",\n    \"test/a/symlink/a\",\n    \"test/a/symlink/a/b\",\n    \"test/a/symlink/a/b/c\",\n    \"test/a/symlink/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\"\n  ],\n  \"test/+(a|b|c)/a{/,bc*}/**\": [\n    \"test/a/abcdef\",\n    \"test/a/abcdef/g\",\n    \"test/a/abcdef/g/h\",\n    \"test/a/abcfed\",\n    \"test/a/abcfed/g\",\n    \"test/a/abcfed/g/h\"\n  ],\n  \"test/*/*/*/f\": [\n    \"test/a/bc/e/f\",\n    \"test/a/cb/e/f\"\n  ],\n  \"test/**/f\": [\n    \"test/a/bc/e/f\",\n    \"test/a/cb/e/f\"\n  ],\n  \"test/a/symlink/a/b/c/a/b/c/a/b/c//a/b/c////a/b/c/**/b/c/**\": [\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b\",\n    \"test/a/symlink/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c/a/b/c\"\n  ],\n  \"{./*/*,/tmp/glob-test/*}\": [\n    \"./examples/g.js\",\n    \"./examples/usr-local.js\",\n    \"./node_modules/graceful-fs\",\n    \"./node_modules/inherits\",\n    \"./node_modules/minimatch\",\n    \"./node_modules/mkdirp\",\n    \"./node_modules/rimraf\",\n    \"./node_modules/tap\",\n    \"./test/00-setup.js\",\n    \"./test/a\",\n    \"./test/bash-comparison.js\",\n    \"./test/bash-results.json\",\n    \"./test/cwd-test.js\",\n    \"./test/globstar-match.js\",\n    \"./test/mark.js\",\n    \"./test/nocase-nomagic.js\",\n    \"./test/pause-resume.js\",\n    \"./test/root-nomount.js\",\n    \"./test/root.js\",\n    \"./test/stat.js\",\n    \"./test/zz-cleanup.js\",\n    \"/tmp/glob-test/asdf\",\n    \"/tmp/glob-test/bar\",\n    \"/tmp/glob-test/baz\",\n    \"/tmp/glob-test/foo\",\n    \"/tmp/glob-test/quux\",\n    \"/tmp/glob-test/qwer\",\n    \"/tmp/glob-test/rewq\"\n  ],\n  \"{/tmp/glob-test/*,*}\": [\n    \"/tmp/glob-test/asdf\",\n    \"/tmp/glob-test/bar\",\n    \"/tmp/glob-test/baz\",\n    \"/tmp/glob-test/foo\",\n    \"/tmp/glob-test/quux\",\n    \"/tmp/glob-test/qwer\",\n    \"/tmp/glob-test/rewq\",\n    \"examples\",\n    \"glob.js\",\n    \"LICENSE\",\n    \"node_modules\",\n    \"package.json\",\n    \"README.md\",\n    \"test\"\n  ],\n  \"test/a/!(symlink)/**\": [\n    \"test/a/abcdef\",\n    \"test/a/abcdef/g\",\n    \"test/a/abcdef/g/h\",\n    \"test/a/abcfed\",\n    \"test/a/abcfed/g\",\n    \"test/a/abcfed/g/h\",\n    \"test/a/b\",\n    \"test/a/b/c\",\n    \"test/a/b/c/d\",\n    \"test/a/bc\",\n    \"test/a/bc/e\",\n    \"test/a/bc/e/f\",\n    \"test/a/c\",\n    \"test/a/c/d\",\n    \"test/a/c/d/c\",\n    \"test/a/c/d/c/b\",\n    \"test/a/cb\",\n    \"test/a/cb/e\",\n    \"test/a/cb/e/f\"\n  ]\n}\n",
  "node_modules/mocha/node_modules/glob/test/cwd-test.js": "var tap = require(\"tap\")\n\nvar origCwd = process.cwd()\nprocess.chdir(__dirname)\n\ntap.test(\"changing cwd and searching for **/d\", function (t) {\n  var glob = require('../')\n  var path = require('path')\n  t.test('.', function (t) {\n    glob('**/d', function (er, matches) {\n      t.ifError(er)\n      t.like(matches, [ 'a/b/c/d', 'a/c/d' ])\n      t.end()\n    })\n  })\n\n  t.test('a', function (t) {\n    glob('**/d', {cwd:path.resolve('a')}, function (er, matches) {\n      t.ifError(er)\n      t.like(matches, [ 'b/c/d', 'c/d' ])\n      t.end()\n    })\n  })\n\n  t.test('a/b', function (t) {\n    glob('**/d', {cwd:path.resolve('a/b')}, function (er, matches) {\n      t.ifError(er)\n      t.like(matches, [ 'c/d' ])\n      t.end()\n    })\n  })\n\n  t.test('a/b/', function (t) {\n    glob('**/d', {cwd:path.resolve('a/b/')}, function (er, matches) {\n      t.ifError(er)\n      t.like(matches, [ 'c/d' ])\n      t.end()\n    })\n  })\n\n  t.test('.', function (t) {\n    glob('**/d', {cwd: process.cwd()}, function (er, matches) {\n      t.ifError(er)\n      t.like(matches, [ 'a/b/c/d', 'a/c/d' ])\n      t.end()\n    })\n  })\n\n  t.test('cd -', function (t) {\n    process.chdir(origCwd)\n    t.end()\n  })\n\n  t.end()\n})\n",
  "node_modules/mocha/node_modules/glob/test/globstar-match.js": "var Glob = require(\"../glob.js\").Glob\nvar test = require('tap').test\n\ntest('globstar should not have dupe matches', function(t) {\n  var pattern = 'a/**/[gh]'\n  var g = new Glob(pattern, { cwd: __dirname })\n  var matches = []\n  g.on('match', function(m) {\n    console.error('match %j', m)\n    matches.push(m)\n  })\n  g.on('end', function(set) {\n    console.error('set', set)\n    matches = matches.sort()\n    set = set.sort()\n    t.same(matches, set, 'should have same set of matches')\n    t.end()\n  })\n})\n",
  "node_modules/mocha/node_modules/glob/test/mark.js": "var test = require(\"tap\").test\nvar glob = require('../')\nprocess.chdir(__dirname)\n\ntest(\"mark, no / on pattern\", function (t) {\n  glob(\"a/*\", {mark: true}, function (er, results) {\n    if (er)\n      throw er\n    var expect = [ 'a/abcdef/',\n                   'a/abcfed/',\n                   'a/b/',\n                   'a/bc/',\n                   'a/c/',\n                   'a/cb/' ]\n\n    if (process.platform !== \"win32\")\n      expect.push('a/symlink/')\n\n    t.same(results, expect)\n    t.end()\n  })\n})\n\ntest(\"mark=false, no / on pattern\", function (t) {\n  glob(\"a/*\", function (er, results) {\n    if (er)\n      throw er\n    var expect = [ 'a/abcdef',\n                   'a/abcfed',\n                   'a/b',\n                   'a/bc',\n                   'a/c',\n                   'a/cb' ]\n\n    if (process.platform !== \"win32\")\n      expect.push('a/symlink')\n    t.same(results, expect)\n    t.end()\n  })\n})\n\ntest(\"mark=true, / on pattern\", function (t) {\n  glob(\"a/*/\", {mark: true}, function (er, results) {\n    if (er)\n      throw er\n    var expect = [ 'a/abcdef/',\n                    'a/abcfed/',\n                    'a/b/',\n                    'a/bc/',\n                    'a/c/',\n                    'a/cb/' ]\n    if (process.platform !== \"win32\")\n      expect.push('a/symlink/')\n    t.same(results, expect)\n    t.end()\n  })\n})\n\ntest(\"mark=false, / on pattern\", function (t) {\n  glob(\"a/*/\", function (er, results) {\n    if (er)\n      throw er\n    var expect = [ 'a/abcdef/',\n                   'a/abcfed/',\n                   'a/b/',\n                   'a/bc/',\n                   'a/c/',\n                   'a/cb/' ]\n    if (process.platform !== \"win32\")\n      expect.push('a/symlink/')\n    t.same(results, expect)\n    t.end()\n  })\n})\n",
  "node_modules/mocha/node_modules/glob/test/nocase-nomagic.js": "var fs = require('graceful-fs');\nvar test = require('tap').test;\nvar glob = require('../');\n\ntest('mock fs', function(t) {\n  var stat = fs.stat\n  var statSync = fs.statSync\n  var readdir = fs.readdir\n  var readdirSync = fs.readdirSync\n\n  function fakeStat(path) {\n    var ret\n    switch (path.toLowerCase()) {\n      case '/tmp': case '/tmp/':\n        ret = { isDirectory: function() { return true } }\n        break\n      case '/tmp/a':\n        ret = { isDirectory: function() { return false } }\n        break\n    }\n    return ret\n  }\n\n  fs.stat = function(path, cb) {\n    var f = fakeStat(path);\n    if (f) {\n      process.nextTick(function() {\n        cb(null, f)\n      })\n    } else {\n      stat.call(fs, path, cb)\n    }\n  }\n\n  fs.statSync = function(path) {\n    return fakeStat(path) || statSync.call(fs, path)\n  }\n\n  function fakeReaddir(path) {\n    var ret\n    switch (path.toLowerCase()) {\n      case '/tmp': case '/tmp/':\n        ret = [ 'a', 'A' ]\n        break\n      case '/':\n        ret = ['tmp', 'tMp', 'tMP', 'TMP']\n    }\n    return ret\n  }\n\n  fs.readdir = function(path, cb) {\n    var f = fakeReaddir(path)\n    if (f)\n      process.nextTick(function() {\n        cb(null, f)\n      })\n    else\n      readdir.call(fs, path, cb)\n  }\n\n  fs.readdirSync = function(path) {\n    return fakeReaddir(path) || readdirSync.call(fs, path)\n  }\n\n  t.pass('mocked')\n  t.end()\n})\n\ntest('nocase, nomagic', function(t) {\n  var n = 2\n  var want = [ '/TMP/A',\n               '/TMP/a',\n               '/tMP/A',\n               '/tMP/a',\n               '/tMp/A',\n               '/tMp/a',\n               '/tmp/A',\n               '/tmp/a' ]\n  glob('/tmp/a', { nocase: true }, function(er, res) {\n    if (er)\n      throw er\n    t.same(res.sort(), want)\n    if (--n === 0) t.end()\n  })\n  glob('/tmp/A', { nocase: true }, function(er, res) {\n    if (er)\n      throw er\n    t.same(res.sort(), want)\n    if (--n === 0) t.end()\n  })\n})\n\ntest('nocase, with some magic', function(t) {\n  t.plan(2)\n  var want = [ '/TMP/A',\n               '/TMP/a',\n               '/tMP/A',\n               '/tMP/a',\n               '/tMp/A',\n               '/tMp/a',\n               '/tmp/A',\n               '/tmp/a' ]\n  glob('/tmp/*', { nocase: true }, function(er, res) {\n    if (er)\n      throw er\n    t.same(res.sort(), want)\n  })\n  glob('/tmp/*', { nocase: true }, function(er, res) {\n    if (er)\n      throw er\n    t.same(res.sort(), want)\n  })\n})\n",
  "node_modules/mocha/node_modules/glob/test/pause-resume.js": "// show that no match events happen while paused.\nvar tap = require(\"tap\")\n, child_process = require(\"child_process\")\n// just some gnarly pattern with lots of matches\n, pattern = \"test/a/!(symlink)/**\"\n, bashResults = require(\"./bash-results.json\")\n, patterns = Object.keys(bashResults)\n, glob = require(\"../\")\n, Glob = glob.Glob\n, path = require(\"path\")\n\n// run from the root of the project\n// this is usually where you're at anyway, but be sure.\nprocess.chdir(path.resolve(__dirname, \"..\"))\n\nfunction alphasort (a, b) {\n  a = a.toLowerCase()\n  b = b.toLowerCase()\n  return a > b ? 1 : a < b ? -1 : 0\n}\n\nfunction cleanResults (m) {\n  // normalize discrepancies in ordering, duplication,\n  // and ending slashes.\n  return m.map(function (m) {\n    return m.replace(/\\/+/g, \"/\").replace(/\\/$/, \"\")\n  }).sort(alphasort).reduce(function (set, f) {\n    if (f !== set[set.length - 1]) set.push(f)\n    return set\n  }, []).sort(alphasort).map(function (f) {\n    // de-windows\n    return (process.platform !== 'win32') ? f\n           : f.replace(/^[a-zA-Z]:\\\\\\\\/, '/').replace(/\\\\/g, '/')\n  })\n}\n\nvar globResults = []\ntap.test(\"use a Glob object, and pause/resume it\", function (t) {\n  var g = new Glob(pattern)\n  , paused = false\n  , res = []\n  , expect = bashResults[pattern]\n\n  g.on(\"pause\", function () {\n    console.error(\"pause\")\n  })\n\n  g.on(\"resume\", function () {\n    console.error(\"resume\")\n  })\n\n  g.on(\"match\", function (m) {\n    t.notOk(g.paused, \"must not be paused\")\n    globResults.push(m)\n    g.pause()\n    t.ok(g.paused, \"must be paused\")\n    setTimeout(g.resume.bind(g), 10)\n  })\n\n  g.on(\"end\", function (matches) {\n    t.pass(\"reached glob end\")\n    globResults = cleanResults(globResults)\n    matches = cleanResults(matches)\n    t.deepEqual(matches, globResults,\n      \"end event matches should be the same as match events\")\n\n    t.deepEqual(matches, expect,\n      \"glob matches should be the same as bash results\")\n\n    t.end()\n  })\n})\n\n",
  "node_modules/mocha/node_modules/glob/test/root-nomount.js": "var tap = require(\"tap\")\n\nvar origCwd = process.cwd()\nprocess.chdir(__dirname)\n\ntap.test(\"changing root and searching for /b*/**\", function (t) {\n  var glob = require('../')\n  var path = require('path')\n  t.test('.', function (t) {\n    glob('/b*/**', { globDebug: true, root: '.', nomount: true }, function (er, matches) {\n      t.ifError(er)\n      t.like(matches, [])\n      t.end()\n    })\n  })\n\n  t.test('a', function (t) {\n    glob('/b*/**', { globDebug: true, root: path.resolve('a'), nomount: true }, function (er, matches) {\n      t.ifError(er)\n      t.like(matches, [ '/b', '/b/c', '/b/c/d', '/bc', '/bc/e', '/bc/e/f' ])\n      t.end()\n    })\n  })\n\n  t.test('root=a, cwd=a/b', function (t) {\n    glob('/b*/**', { globDebug: true, root: 'a', cwd: path.resolve('a/b'), nomount: true }, function (er, matches) {\n      t.ifError(er)\n      t.like(matches, [ '/b', '/b/c', '/b/c/d', '/bc', '/bc/e', '/bc/e/f' ])\n      t.end()\n    })\n  })\n\n  t.test('cd -', function (t) {\n    process.chdir(origCwd)\n    t.end()\n  })\n\n  t.end()\n})\n",
  "node_modules/mocha/node_modules/glob/test/root.js": "var t = require(\"tap\")\n\nvar origCwd = process.cwd()\nprocess.chdir(__dirname)\n\nvar glob = require('../')\nvar path = require('path')\n\nt.test('.', function (t) {\n  glob('/b*/**', { globDebug: true, root: '.' }, function (er, matches) {\n    t.ifError(er)\n    t.like(matches, [])\n    t.end()\n  })\n})\n\n\nt.test('a', function (t) {\n  console.error(\"root=\" + path.resolve('a'))\n  glob('/b*/**', { globDebug: true, root: path.resolve('a') }, function (er, matches) {\n    t.ifError(er)\n    var wanted = [\n        '/b', '/b/c', '/b/c/d', '/bc', '/bc/e', '/bc/e/f'\n      ].map(function (m) {\n        return path.join(path.resolve('a'), m).replace(/\\\\/g, '/')\n      })\n\n    t.like(matches, wanted)\n    t.end()\n  })\n})\n\nt.test('root=a, cwd=a/b', function (t) {\n  glob('/b*/**', { globDebug: true, root: 'a', cwd: path.resolve('a/b') }, function (er, matches) {\n    t.ifError(er)\n    t.like(matches, [ '/b', '/b/c', '/b/c/d', '/bc', '/bc/e', '/bc/e/f' ].map(function (m) {\n      return path.join(path.resolve('a'), m).replace(/\\\\/g, '/')\n    }))\n    t.end()\n  })\n})\n\nt.test('cd -', function (t) {\n  process.chdir(origCwd)\n  t.end()\n})\n",
  "node_modules/mocha/node_modules/glob/test/stat.js": "var glob = require('../')\nvar test = require('tap').test\nvar path = require('path')\n\ntest('stat all the things', function(t) {\n  var g = new glob.Glob('a/*abc*/**', { stat: true, cwd: __dirname })\n  var matches = []\n  g.on('match', function(m) {\n    matches.push(m)\n  })\n  var stats = []\n  g.on('stat', function(m) {\n    stats.push(m)\n  })\n  g.on('end', function(eof) {\n    stats = stats.sort()\n    matches = matches.sort()\n    eof = eof.sort()\n    t.same(stats, matches)\n    t.same(eof, matches)\n    var cache = Object.keys(this.statCache)\n    t.same(cache.map(function (f) {\n      return path.relative(__dirname, f)\n    }).sort(), matches)\n\n    cache.forEach(function(c) {\n      t.equal(typeof this.statCache[c], 'object')\n    }, this)\n\n    t.end()\n  })\n})\n",
  "node_modules/mocha/node_modules/glob/test/zz-cleanup.js": "// remove the fixtures\nvar tap = require(\"tap\")\n, rimraf = require(\"rimraf\")\n, path = require(\"path\")\n\ntap.test(\"cleanup fixtures\", function (t) {\n  rimraf(path.resolve(__dirname, \"a\"), function (er) {\n    t.ifError(er, \"removed\")\n    t.end()\n  })\n})\n",
  "node_modules/mocha/node_modules/growl/lib/growl.js": "// Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n/**\n * Module dependencies.\n */\n\nvar exec = require('child_process').exec\n  , fs = require('fs')\n  , path = require('path')\n  , exists = fs.existsSync || path.existsSync\n  , os = require('os')\n  , quote = JSON.stringify\n  , cmd;\n\nfunction which(name) {\n  var paths = process.env.PATH.split(':');\n  var loc;\n  \n  for (var i = 0, len = paths.length; i < len; ++i) {\n    loc = path.join(paths[i], name);\n    if (exists(loc)) return loc;\n  }\n}\n\nswitch(os.type()) {\n  case 'Darwin':\n    if (which('terminal-notifier')) {\n      cmd = {\n          type: \"Darwin-NotificationCenter\"\n        , pkg: \"terminal-notifier\"\n        , msg: '-message'\n        , title: '-title'\n        , subtitle: '-subtitle'\n        , priority: {\n              cmd: '-execute'\n            , range: []\n          }\n      };\n    } else {\n      cmd = {\n          type: \"Darwin-Growl\"\n        , pkg: \"growlnotify\"\n        , msg: '-m'\n        , sticky: '--sticky'\n        , priority: {\n              cmd: '--priority'\n            , range: [\n                -2\n              , -1\n              , 0\n              , 1\n              , 2\n              , \"Very Low\"\n              , \"Moderate\"\n              , \"Normal\"\n              , \"High\"\n              , \"Emergency\"\n            ]\n          }\n      };\n    }\n    break;\n  case 'Linux':\n    cmd = {\n        type: \"Linux\"\n      , pkg: \"notify-send\"\n      , msg: ''\n      , sticky: '-t 0'\n      , icon: '-i'\n      , priority: {\n          cmd: '-u'\n        , range: [\n            \"low\"\n          , \"normal\"\n          , \"critical\"\n        ]\n      }\n    };\n    break;\n  case 'Windows_NT':\n    cmd = {\n        type: \"Windows\"\n      , pkg: \"growlnotify\"\n      , msg: ''\n      , sticky: '/s:true'\n      , title: '/t:'\n      , icon: '/i:'\n      , priority: {\n            cmd: '/p:'\n          , range: [\n              -2\n            , -1\n            , 0\n            , 1\n            , 2\n          ]\n        }\n    };\n    break;\n}\n\n/**\n * Expose `growl`.\n */\n\nexports = module.exports = growl;\n\n/**\n * Node-growl version.\n */\n\nexports.version = '1.4.1'\n\n/**\n * Send growl notification _msg_ with _options_.\n *\n * Options:\n *\n *  - title   Notification title\n *  - sticky  Make the notification stick (defaults to false)\n *  - priority  Specify an int or named key (default is 0)\n *  - name    Application name (defaults to growlnotify)\n *  - image\n *    - path to an icon sets --iconpath\n *    - path to an image sets --image\n *    - capitalized word sets --appIcon\n *    - filename uses extname as --icon\n *    - otherwise treated as --icon\n *\n * Examples:\n *\n *   growl('New email')\n *   growl('5 new emails', { title: 'Thunderbird' })\n *   growl('Email sent', function(){\n *     // ... notification sent\n *   })\n *\n * @param {string} msg\n * @param {object} options\n * @param {function} fn\n * @api public\n */\n\nfunction growl(msg, options, fn) {\n  var image\n    , args\n    , options = options || {}\n    , fn = fn || function(){};\n\n  // noop\n  if (!cmd) return fn(new Error('growl not supported on this platform'));\n  args = [cmd.pkg];\n\n  // image\n  if (image = options.image) {\n    switch(cmd.type) {\n      case 'Darwin-Growl':\n        var flag, ext = path.extname(image).substr(1)\n        flag = flag || ext == 'icns' && 'iconpath'\n        flag = flag || /^[A-Z]/.test(image) && 'appIcon'\n        flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'\n        flag = flag || ext && (image = ext) && 'icon'\n        flag = flag || 'icon'\n        args.push('--' + flag, quote(image))\n        break;\n      case 'Linux':\n        args.push(cmd.icon, quote(image));\n        // libnotify defaults to sticky, set a hint for transient notifications\n        if (!options.sticky) args.push('--hint=int:transient:1');\n        break;\n      case 'Windows':\n        args.push(cmd.icon + quote(image));\n        break;\n    }\n  }\n\n  // sticky\n  if (options.sticky) args.push(cmd.sticky);\n\n  // priority\n  if (options.priority) {\n    var priority = options.priority + '';\n    var checkindexOf = cmd.priority.range.indexOf(priority);\n    if (~cmd.priority.range.indexOf(priority)) {\n      args.push(cmd.priority, options.priority);\n    }\n  }\n\n  // name\n  if (options.name && cmd.type === \"Darwin-Growl\") {\n    args.push('--name', options.name);\n  }\n\n  switch(cmd.type) {\n    case 'Darwin-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg));\n      if (options.title) args.push(quote(options.title));\n      break;\n    case 'Darwin-NotificationCenter':\n      args.push(cmd.msg);\n      args.push(quote(msg));\n      if (options.title) {\n        args.push(cmd.title);\n        args.push(quote(options.title));\n      }\n      if (options.subtitle) {\n        args.push(cmd.subtitle);\n        args.push(quote(options.subtitle));\n      }\n      break;\n    case 'Darwin-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg));\n      if (options.title) args.push(quote(options.title));\n      break;\n    case 'Linux':\n      if (options.title) {\n        args.push(quote(options.title));\n        args.push(cmd.msg);\n        args.push(quote(msg));\n      } else {\n        args.push(quote(msg));\n      }\n      break;\n    case 'Windows':\n      args.push(quote(msg));\n      if (options.title) args.push(cmd.title + quote(options.title));\n      break;\n  }\n\n  // execute\n  exec(args.join(' '), fn);\n};\n",
  "node_modules/mocha/node_modules/growl/package.json": "{\n  \"name\": \"growl\",\n  \"version\": \"1.8.1\",\n  \"description\": \"Growl unobtrusive notifications\",\n  \"author\": {\n    \"name\": \"TJ Holowaychuk\",\n    \"email\": \"tj@vision-media.ca\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"tjholowaychuk\",\n      \"email\": \"tj@vision-media.ca\"\n    },\n    {\n      \"name\": \"jbnicolai\",\n      \"email\": \"jappelman@xebia.com\"\n    }\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/visionmedia/node-growl.git\"\n  },\n  \"main\": \"./lib/growl.js\",\n  \"gitHead\": \"882ced3155a57f566887c884d5c6dccb7df435c1\",\n  \"bugs\": {\n    \"url\": \"https://github.com/visionmedia/node-growl/issues\"\n  },\n  \"homepage\": \"https://github.com/visionmedia/node-growl\",\n  \"_id\": \"growl@1.8.1\",\n  \"scripts\": {},\n  \"_shasum\": \"4b2dec8d907e93db336624dcec0183502f8c9428\",\n  \"_from\": \"growl@1.8.1\",\n  \"_npmVersion\": \"1.4.20\",\n  \"_npmUser\": {\n    \"name\": \"jbnicolai\",\n    \"email\": \"jappelman@xebia.com\"\n  },\n  \"dist\": {\n    \"shasum\": \"4b2dec8d907e93db336624dcec0183502f8c9428\",\n    \"tarball\": \"http://registry.npmjs.org/growl/-/growl-1.8.1.tgz\"\n  },\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/growl/-/growl-1.8.1.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/growl/test.js": "\nvar growl = require('./lib/growl')\n\ngrowl('You have mail!')\ngrowl('5 new messages', { sticky: true })\ngrowl('5 new emails', { title: 'Email Client', image: 'Safari', sticky: true })\ngrowl('Message with title', { title: 'Title'})\ngrowl('Set priority', { priority: 2 })\ngrowl('Show Safari icon', { image: 'Safari' })\ngrowl('Show icon', { image: 'path/to/icon.icns' })\ngrowl('Show image', { image: 'path/to/my.image.png' })\ngrowl('Show png filesystem icon', { image: 'png' })\ngrowl('Show pdf filesystem icon', { image: 'article.pdf' })\ngrowl('Show pdf filesystem icon', { image: 'article.pdf' }, function(){\n  console.log('callback');\n})\ngrowl('Show pdf filesystem icon', { title: 'Use show()', image: 'article.pdf' })\ngrowl('here \\' are \\n some \\\\ characters that \" need escaping', {}, function(error, stdout, stderr) {\n  if (error !== null) throw new Error('escaping failed:\\n' + stdout + stderr);\n})\n",
  "node_modules/mocha/node_modules/jade/index.js": "\nmodule.exports = process.env.JADE_COV\n  ? require('./lib-cov/jade')\n  : require('./lib/jade');",
  "node_modules/mocha/node_modules/jade/jade.js": "(function() {\n\n// CommonJS require()\n\nfunction require(p){\n    var path = require.resolve(p)\n      , mod = require.modules[path];\n    if (!mod) throw new Error('failed to require \"' + p + '\"');\n    if (!mod.exports) {\n      mod.exports = {};\n      mod.call(mod.exports, mod, mod.exports, require.relative(path));\n    }\n    return mod.exports;\n  }\n\nrequire.modules = {};\n\nrequire.resolve = function (path){\n    var orig = path\n      , reg = path + '.js'\n      , index = path + '/index.js';\n    return require.modules[reg] && reg\n      || require.modules[index] && index\n      || orig;\n  };\n\nrequire.register = function (path, fn){\n    require.modules[path] = fn;\n  };\n\nrequire.relative = function (parent) {\n    return function(p){\n      if ('.' != p.charAt(0)) return require(p);\n      \n      var path = parent.split('/')\n        , segs = p.split('/');\n      path.pop();\n      \n      for (var i = 0; i < segs.length; i++) {\n        var seg = segs[i];\n        if ('..' == seg) path.pop();\n        else if ('.' != seg) path.push(seg);\n      }\n\n      return require(path.join('/'));\n    };\n  };\n\n\nrequire.register(\"compiler.js\", function(module, exports, require){\n\n/*!\n * Jade - Compiler\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar nodes = require('./nodes')\n  , filters = require('./filters')\n  , doctypes = require('./doctypes')\n  , selfClosing = require('./self-closing')\n  , runtime = require('./runtime')\n  , utils = require('./utils');\n\n\n if (!Object.keys) {\n   Object.keys = function(obj){\n     var arr = [];\n     for (var key in obj) {\n       if (obj.hasOwnProperty(key)) {\n         arr.push(key);\n       }\n     }\n     return arr;\n   }\n }\n\n if (!String.prototype.trimLeft) {\n   String.prototype.trimLeft = function(){\n     return this.replace(/^\\s+/, '');\n   }\n }\n\n\n\n/**\n * Initialize `Compiler` with the given `node`.\n *\n * @param {Node} node\n * @param {Object} options\n * @api public\n */\n\nvar Compiler = module.exports = function Compiler(node, options) {\n  this.options = options = options || {};\n  this.node = node;\n  this.hasCompiledDoctype = false;\n  this.hasCompiledTag = false;\n  this.pp = options.pretty || false;\n  this.debug = false !== options.compileDebug;\n  this.indents = 0;\n  this.parentIndents = 0;\n  if (options.doctype) this.setDoctype(options.doctype);\n};\n\n/**\n * Compiler prototype.\n */\n\nCompiler.prototype = {\n\n  /**\n   * Compile parse tree to JavaScript.\n   *\n   * @api public\n   */\n\n  compile: function(){\n    this.buf = ['var interp;'];\n    if (this.pp) this.buf.push(\"var __indent = [];\");\n    this.lastBufferedIdx = -1;\n    this.visit(this.node);\n    return this.buf.join('\\n');\n  },\n\n  /**\n   * Sets the default doctype `name`. Sets terse mode to `true` when\n   * html 5 is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {string} name\n   * @api public\n   */\n\n  setDoctype: function(name){\n    var doctype = doctypes[(name || 'default').toLowerCase()];\n    doctype = doctype || '<!DOCTYPE ' + name + '>';\n    this.doctype = doctype;\n    this.terse = '5' == name || 'html' == name;\n    this.xml = 0 == this.doctype.indexOf('<?xml');\n  },\n\n  /**\n   * Buffer the given `str` optionally escaped.\n   *\n   * @param {String} str\n   * @param {Boolean} esc\n   * @api public\n   */\n\n  buffer: function(str, esc){\n    if (esc) str = utils.escape(str);\n\n    if (this.lastBufferedIdx == this.buf.length) {\n      this.lastBuffered += str;\n      this.buf[this.lastBufferedIdx - 1] = \"buf.push('\" + this.lastBuffered + \"');\"\n    } else {\n      this.buf.push(\"buf.push('\" + str + \"');\");\n      this.lastBuffered = str;\n      this.lastBufferedIdx = this.buf.length;\n    }\n  },\n\n  /**\n   * Buffer an indent based on the current `indent`\n   * property and an additional `offset`.\n   *\n   * @param {Number} offset\n   * @param {Boolean} newline\n   * @api public\n   */\n  \n  prettyIndent: function(offset, newline){\n    offset = offset || 0;\n    newline = newline ? '\\\\n' : '';\n    this.buffer(newline + Array(this.indents + offset).join('  '));\n    if (this.parentIndents)\n      this.buf.push(\"buf.push.apply(buf, __indent);\");\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n\n  visit: function(node){\n    var debug = this.debug;\n\n    if (debug) {\n      this.buf.push('__jade.unshift({ lineno: ' + node.line\n        + ', filename: ' + (node.filename\n          ? JSON.stringify(node.filename)\n          : '__jade[0].filename')\n        + ' });');\n    }\n\n    // Massive hack to fix our context\n    // stack for - else[ if] etc\n    if (false === node.debug && this.debug) {\n      this.buf.pop();\n      this.buf.pop();\n    }\n\n    this.visitNode(node);\n\n    if (debug) this.buf.push('__jade.shift();');\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n\n  visitNode: function(node){\n    var name = node.constructor.name\n      || node.constructor.toString().match(/function ([^(\\s]+)()/)[1];\n    return this['visit' + name](node);\n  },\n\n  /**\n   * Visit case `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitCase: function(node){\n    var _ = this.withinCase;\n    this.withinCase = true;\n    this.buf.push('switch (' + node.expr + '){');\n    this.visit(node.block);\n    this.buf.push('}');\n    this.withinCase = _;\n  },\n\n  /**\n   * Visit when `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitWhen: function(node){\n    if ('default' == node.expr) {\n      this.buf.push('default:');\n    } else {\n      this.buf.push('case ' + node.expr + ':');\n    }\n    this.visit(node.block);\n    this.buf.push('  break;');\n  },\n\n  /**\n   * Visit literal `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitLiteral: function(node){\n    var str = node.str.replace(/\\n/g, '\\\\\\\\n');\n    this.buffer(str);\n  },\n\n  /**\n   * Visit all nodes in `block`.\n   *\n   * @param {Block} block\n   * @api public\n   */\n\n  visitBlock: function(block){\n    var len = block.nodes.length\n      , escape = this.escape\n      , pp = this.pp\n    \n    // Block keyword has a special meaning in mixins\n    if (this.parentIndents && block.mode) {\n      if (pp) this.buf.push(\"__indent.push('\" + Array(this.indents + 1).join('  ') + \"');\")\n      this.buf.push('block && block();');\n      if (pp) this.buf.push(\"__indent.pop();\")\n      return;\n    }\n    \n    // Pretty print multi-line text\n    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)\n      this.prettyIndent(1, true);\n    \n    for (var i = 0; i < len; ++i) {\n      // Pretty print text\n      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)\n        this.prettyIndent(1, false);\n      \n      this.visit(block.nodes[i]);\n      // Multiple text nodes are separated by newlines\n      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)\n        this.buffer('\\\\n');\n    }\n  },\n\n  /**\n   * Visit `doctype`. Sets terse mode to `true` when html 5\n   * is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {Doctype} doctype\n   * @api public\n   */\n\n  visitDoctype: function(doctype){\n    if (doctype && (doctype.val || !this.doctype)) {\n      this.setDoctype(doctype.val || 'default');\n    }\n\n    if (this.doctype) this.buffer(this.doctype);\n    this.hasCompiledDoctype = true;\n  },\n\n  /**\n   * Visit `mixin`, generating a function that\n   * may be called within the template.\n   *\n   * @param {Mixin} mixin\n   * @api public\n   */\n\n  visitMixin: function(mixin){\n    var name = mixin.name.replace(/-/g, '_') + '_mixin'\n      , args = mixin.args || ''\n      , block = mixin.block\n      , attrs = mixin.attrs\n      , pp = this.pp;\n\n    if (mixin.call) {\n      if (pp) this.buf.push(\"__indent.push('\" + Array(this.indents + 1).join('  ') + \"');\")\n      if (block || attrs.length) {\n        \n        this.buf.push(name + '.call({');\n        \n        if (block) {\n          this.buf.push('block: function(){');\n          \n          // Render block with no indents, dynamically added when rendered\n          this.parentIndents++;\n          var _indents = this.indents;\n          this.indents = 0;\n          this.visit(mixin.block);\n          this.indents = _indents;\n          this.parentIndents--;\n          \n          if (attrs.length) {\n            this.buf.push('},');\n          } else {\n            this.buf.push('}');\n          }\n        }\n        \n        if (attrs.length) {\n          var val = this.attrs(attrs);\n          if (val.inherits) {\n            this.buf.push('attributes: merge({' + val.buf\n                + '}, attributes), escaped: merge(' + val.escaped + ', escaped, true)');\n          } else {\n            this.buf.push('attributes: {' + val.buf + '}, escaped: ' + val.escaped);\n          }\n        }\n        \n        if (args) {\n          this.buf.push('}, ' + args + ');');\n        } else {\n          this.buf.push('});');\n        }\n        \n      } else {\n        this.buf.push(name + '(' + args + ');');\n      }\n      if (pp) this.buf.push(\"__indent.pop();\")\n    } else {\n      this.buf.push('var ' + name + ' = function(' + args + '){');\n      this.buf.push('var block = this.block, attributes = this.attributes || {}, escaped = this.escaped || {};');\n      this.parentIndents++;\n      this.visit(block);\n      this.parentIndents--;\n      this.buf.push('};');\n    }\n  },\n\n  /**\n   * Visit `tag` buffering tag markup, generating\n   * attributes, visiting the `tag`'s code and block.\n   *\n   * @param {Tag} tag\n   * @api public\n   */\n\n  visitTag: function(tag){\n    this.indents++;\n    var name = tag.name\n      , pp = this.pp;\n\n    if (tag.buffer) name = \"' + (\" + name + \") + '\";\n\n    if (!this.hasCompiledTag) {\n      if (!this.hasCompiledDoctype && 'html' == name) {\n        this.visitDoctype();\n      }\n      this.hasCompiledTag = true;\n    }\n\n    // pretty print\n    if (pp && !tag.isInline())\n      this.prettyIndent(0, true);\n\n    if ((~selfClosing.indexOf(name) || tag.selfClosing) && !this.xml) {\n      this.buffer('<' + name);\n      this.visitAttributes(tag.attrs);\n      this.terse\n        ? this.buffer('>')\n        : this.buffer('/>');\n    } else {\n      // Optimize attributes buffering\n      if (tag.attrs.length) {\n        this.buffer('<' + name);\n        if (tag.attrs.length) this.visitAttributes(tag.attrs);\n        this.buffer('>');\n      } else {\n        this.buffer('<' + name + '>');\n      }\n      if (tag.code) this.visitCode(tag.code);\n      this.escape = 'pre' == tag.name;\n      this.visit(tag.block);\n\n      // pretty print\n      if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())\n        this.prettyIndent(0, true);\n\n      this.buffer('</' + name + '>');\n    }\n    this.indents--;\n  },\n\n  /**\n   * Visit `filter`, throwing when the filter does not exist.\n   *\n   * @param {Filter} filter\n   * @api public\n   */\n\n  visitFilter: function(filter){\n    var fn = filters[filter.name];\n\n    // unknown filter\n    if (!fn) {\n      if (filter.isASTFilter) {\n        throw new Error('unknown ast filter \"' + filter.name + ':\"');\n      } else {\n        throw new Error('unknown filter \":' + filter.name + '\"');\n      }\n    }\n\n    if (filter.isASTFilter) {\n      this.buf.push(fn(filter.block, this, filter.attrs));\n    } else {\n      var text = filter.block.nodes.map(function(node){ return node.val }).join('\\n');\n      filter.attrs = filter.attrs || {};\n      filter.attrs.filename = this.options.filename;\n      this.buffer(utils.text(fn(text, filter.attrs)));\n    }\n  },\n\n  /**\n   * Visit `text` node.\n   *\n   * @param {Text} text\n   * @api public\n   */\n\n  visitText: function(text){\n    text = utils.text(text.val.replace(/\\\\/g, '\\\\\\\\'));\n    if (this.escape) text = escape(text);\n    this.buffer(text);\n  },\n\n  /**\n   * Visit a `comment`, only buffering when the buffer flag is set.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n\n  visitComment: function(comment){\n    if (!comment.buffer) return;\n    if (this.pp) this.prettyIndent(1, true);\n    this.buffer('<!--' + utils.escape(comment.val) + '-->');\n  },\n\n  /**\n   * Visit a `BlockComment`.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n\n  visitBlockComment: function(comment){\n    if (!comment.buffer) return;\n    if (0 == comment.val.trim().indexOf('if')) {\n      this.buffer('<!--[' + comment.val.trim() + ']>');\n      this.visit(comment.block);\n      this.buffer('<![endif]-->');\n    } else {\n      this.buffer('<!--' + comment.val);\n      this.visit(comment.block);\n      this.buffer('-->');\n    }\n  },\n\n  /**\n   * Visit `code`, respecting buffer / escape flags.\n   * If the code is followed by a block, wrap it in\n   * a self-calling function.\n   *\n   * @param {Code} code\n   * @api public\n   */\n\n  visitCode: function(code){\n    // Wrap code blocks with {}.\n    // we only wrap unbuffered code blocks ATM\n    // since they are usually flow control\n\n    // Buffer code\n    if (code.buffer) {\n      var val = code.val.trimLeft();\n      this.buf.push('var __val__ = ' + val);\n      val = 'null == __val__ ? \"\" : __val__';\n      if (code.escape) val = 'escape(' + val + ')';\n      this.buf.push(\"buf.push(\" + val + \");\");\n    } else {\n      this.buf.push(code.val);\n    }\n\n    // Block support\n    if (code.block) {\n      if (!code.buffer) this.buf.push('{');\n      this.visit(code.block);\n      if (!code.buffer) this.buf.push('}');\n    }\n  },\n\n  /**\n   * Visit `each` block.\n   *\n   * @param {Each} each\n   * @api public\n   */\n\n  visitEach: function(each){\n    this.buf.push(''\n      + '// iterate ' + each.obj + '\\n'\n      + ';(function(){\\n'\n      + '  if (\\'number\\' == typeof ' + each.obj + '.length) {\\n'\n      + '    for (var ' + each.key + ' = 0, $$l = ' + each.obj + '.length; ' + each.key + ' < $$l; ' + each.key + '++) {\\n'\n      + '      var ' + each.val + ' = ' + each.obj + '[' + each.key + '];\\n');\n\n    this.visit(each.block);\n\n    this.buf.push(''\n      + '    }\\n'\n      + '  } else {\\n'\n      + '    for (var ' + each.key + ' in ' + each.obj + ') {\\n'\n       + '      if (' + each.obj + '.hasOwnProperty(' + each.key + ')){'\n      + '      var ' + each.val + ' = ' + each.obj + '[' + each.key + '];\\n');\n\n    this.visit(each.block);\n\n     this.buf.push('      }\\n');\n\n    this.buf.push('   }\\n  }\\n}).call(this);\\n');\n  },\n\n  /**\n   * Visit `attrs`.\n   *\n   * @param {Array} attrs\n   * @api public\n   */\n\n  visitAttributes: function(attrs){\n    var val = this.attrs(attrs);\n    if (val.inherits) {\n      this.buf.push(\"buf.push(attrs(merge({ \" + val.buf +\n          \" }, attributes), merge(\" + val.escaped + \", escaped, true)));\");\n    } else if (val.constant) {\n      eval('var buf={' + val.buf + '};');\n      this.buffer(runtime.attrs(buf, JSON.parse(val.escaped)), true);\n    } else {\n      this.buf.push(\"buf.push(attrs({ \" + val.buf + \" }, \" + val.escaped + \"));\");\n    }\n  },\n\n  /**\n   * Compile attributes.\n   */\n\n  attrs: function(attrs){\n    var buf = []\n      , classes = []\n      , escaped = {}\n      , constant = attrs.every(function(attr){ return isConstant(attr.val) })\n      , inherits = false;\n\n    if (this.terse) buf.push('terse: true');\n\n    attrs.forEach(function(attr){\n      if (attr.name == 'attributes') return inherits = true;\n      escaped[attr.name] = attr.escaped;\n      if (attr.name == 'class') {\n        classes.push('(' + attr.val + ')');\n      } else {\n        var pair = \"'\" + attr.name + \"':(\" + attr.val + ')';\n        buf.push(pair);\n      }\n    });\n\n    if (classes.length) {\n      classes = classes.join(\" + ' ' + \");\n      buf.push(\"class: \" + classes);\n    }\n\n    return {\n      buf: buf.join(', ').replace('class:', '\"class\":'),\n      escaped: JSON.stringify(escaped),\n      inherits: inherits,\n      constant: constant\n    };\n  }\n};\n\n/**\n * Check if expression can be evaluated to a constant\n *\n * @param {String} expression\n * @return {Boolean}\n * @api private\n */\n\nfunction isConstant(val){\n  // Check strings/literals\n  if (/^ *(\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"|'([^'\\\\]*(\\\\.[^'\\\\]*)*)'|true|false|null|undefined) *$/i.test(val))\n    return true;\n  \n  // Check numbers\n  if (!isNaN(Number(val)))\n    return true;\n  \n  // Check arrays\n  var matches;\n  if (matches = /^ *\\[(.*)\\] *$/.exec(val))\n    return matches[1].split(',').every(isConstant);\n  \n  return false;\n}\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nfunction escape(html){\n  return String(html)\n    .replace(/&(?!\\w+;)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n}\n}); // module: compiler.js\n\nrequire.register(\"doctypes.js\", function(module, exports, require){\n\n/*!\n * Jade - doctypes\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = {\n    '5': '<!DOCTYPE html>'\n  , 'default': '<!DOCTYPE html>'\n  , 'xml': '<?xml version=\"1.0\" encoding=\"utf-8\" ?>'\n  , 'transitional': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">'\n  , 'strict': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">'\n  , 'frameset': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">'\n  , '1.1': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">'\n  , 'basic': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">'\n  , 'mobile': '<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">'\n};\n}); // module: doctypes.js\n\nrequire.register(\"filters.js\", function(module, exports, require){\n\n/*!\n * Jade - filters\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = {\n  \n  /**\n   * Wrap text with CDATA block.\n   */\n  \n  cdata: function(str){\n    return '<![CDATA[\\\\n' + str + '\\\\n]]>';\n  },\n  \n  /**\n   * Transform sass to css, wrapped in style tags.\n   */\n  \n  sass: function(str){\n    str = str.replace(/\\\\n/g, '\\n');\n    var sass = require('sass').render(str).replace(/\\n/g, '\\\\n');\n    return '<style type=\"text/css\">' + sass + '</style>'; \n  },\n  \n  /**\n   * Transform stylus to css, wrapped in style tags.\n   */\n  \n  stylus: function(str, options){\n    var ret;\n    str = str.replace(/\\\\n/g, '\\n');\n    var stylus = require('stylus');\n    stylus(str, options).render(function(err, css){\n      if (err) throw err;\n      ret = css.replace(/\\n/g, '\\\\n');\n    });\n    return '<style type=\"text/css\">' + ret + '</style>'; \n  },\n  \n  /**\n   * Transform less to css, wrapped in style tags.\n   */\n  \n  less: function(str){\n    var ret;\n    str = str.replace(/\\\\n/g, '\\n');\n    require('less').render(str, function(err, css){\n      if (err) throw err;\n      ret = '<style type=\"text/css\">' + css.replace(/\\n/g, '\\\\n') + '</style>';  \n    });\n    return ret;\n  },\n  \n  /**\n   * Transform markdown to html.\n   */\n  \n  markdown: function(str){\n    var md;\n\n    // support markdown / discount\n    try {\n      md = require('markdown');\n    } catch (err){\n      try {\n        md = require('discount');\n      } catch (err) {\n        try {\n          md = require('markdown-js');\n        } catch (err) {\n          try {\n            md = require('marked');\n          } catch (err) {\n            throw new\n              Error('Cannot find markdown library, install markdown, discount, or marked.');\n          }\n        }\n      }\n    }\n\n    str = str.replace(/\\\\n/g, '\\n');\n    return md.parse(str).replace(/\\n/g, '\\\\n').replace(/'/g,'&#39;');\n  },\n  \n  /**\n   * Transform coffeescript to javascript.\n   */\n\n  coffeescript: function(str){\n    str = str.replace(/\\\\n/g, '\\n');\n    var js = require('coffee-script').compile(str).replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n');\n    return '<script type=\"text/javascript\">\\\\n' + js + '</script>';\n  }\n};\n\n}); // module: filters.js\n\nrequire.register(\"inline-tags.js\", function(module, exports, require){\n\n/*!\n * Jade - inline tags\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = [\n    'a'\n  , 'abbr'\n  , 'acronym'\n  , 'b'\n  , 'br'\n  , 'code'\n  , 'em'\n  , 'font'\n  , 'i'\n  , 'img'\n  , 'ins'\n  , 'kbd'\n  , 'map'\n  , 'samp'\n  , 'small'\n  , 'span'\n  , 'strong'\n  , 'sub'\n  , 'sup'\n];\n}); // module: inline-tags.js\n\nrequire.register(\"jade.js\", function(module, exports, require){\n/*!\n * Jade\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Parser = require('./parser')\n  , Lexer = require('./lexer')\n  , Compiler = require('./compiler')\n  , runtime = require('./runtime')\n\n/**\n * Library version.\n */\n\nexports.version = '0.26.1';\n\n/**\n * Expose self closing tags.\n */\n\nexports.selfClosing = require('./self-closing');\n\n/**\n * Default supported doctypes.\n */\n\nexports.doctypes = require('./doctypes');\n\n/**\n * Text filters.\n */\n\nexports.filters = require('./filters');\n\n/**\n * Utilities.\n */\n\nexports.utils = require('./utils');\n\n/**\n * Expose `Compiler`.\n */\n\nexports.Compiler = Compiler;\n\n/**\n * Expose `Parser`.\n */\n\nexports.Parser = Parser;\n\n/**\n * Expose `Lexer`.\n */\n\nexports.Lexer = Lexer;\n\n/**\n * Nodes.\n */\n\nexports.nodes = require('./nodes');\n\n/**\n * Jade runtime helpers.\n */\n\nexports.runtime = runtime;\n\n/**\n * Template function cache.\n */\n\nexports.cache = {};\n\n/**\n * Parse the given `str` of jade and return a function body.\n *\n * @param {String} str\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction parse(str, options){\n  try {\n    // Parse\n    var parser = new Parser(str, options.filename, options);\n\n    // Compile\n    var compiler = new (options.compiler || Compiler)(parser.parse(), options)\n      , js = compiler.compile();\n\n    // Debug compiler\n    if (options.debug) {\n      console.error('\\nCompiled Function:\\n\\n\\033[90m%s\\033[0m', js.replace(/^/gm, '  '));\n    }\n\n    return ''\n      + 'var buf = [];\\n'\n      + (options.self\n        ? 'var self = locals || {};\\n' + js\n        : 'with (locals || {}) {\\n' + js + '\\n}\\n')\n      + 'return buf.join(\"\");';\n  } catch (err) {\n    parser = parser.context();\n    runtime.rethrow(err, parser.filename, parser.lexer.lineno);\n  }\n}\n\n/**\n * Compile a `Function` representation of the given jade `str`.\n *\n * Options:\n *\n *   - `compileDebug` when `false` debugging code is stripped from the compiled template\n *   - `client` when `true` the helper functions `escape()` etc will reference `jade.escape()`\n *      for use with the Jade client-side runtime.js\n *\n * @param {String} str\n * @param {Options} options\n * @return {Function}\n * @api public\n */\n\nexports.compile = function(str, options){\n  var options = options || {}\n    , client = options.client\n    , filename = options.filename\n      ? JSON.stringify(options.filename)\n      : 'undefined'\n    , fn;\n\n  if (options.compileDebug !== false) {\n    fn = [\n        'var __jade = [{ lineno: 1, filename: ' + filename + ' }];'\n      , 'try {'\n      , parse(String(str), options)\n      , '} catch (err) {'\n      , '  rethrow(err, __jade[0].filename, __jade[0].lineno);'\n      , '}'\n    ].join('\\n');\n  } else {\n    fn = parse(String(str), options);\n  }\n\n  if (client) {\n    fn = 'attrs = attrs || jade.attrs; escape = escape || jade.escape; rethrow = rethrow || jade.rethrow; merge = merge || jade.merge;\\n' + fn;\n  }\n\n  fn = new Function('locals, attrs, escape, rethrow, merge', fn);\n\n  if (client) return fn;\n\n  return function(locals){\n    return fn(locals, runtime.attrs, runtime.escape, runtime.rethrow, runtime.merge);\n  };\n};\n\n/**\n * Render the given `str` of jade and invoke\n * the callback `fn(err, str)`.\n *\n * Options:\n *\n *   - `cache` enable template caching\n *   - `filename` filename required for `include` / `extends` and caching\n *\n * @param {String} str\n * @param {Object|Function} options or fn\n * @param {Function} fn\n * @api public\n */\n\nexports.render = function(str, options, fn){\n  // swap args\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  // cache requires .filename\n  if (options.cache && !options.filename) {\n    return fn(new Error('the \"filename\" option is required for caching'));\n  }\n\n  try {\n    var path = options.filename;\n    var tmpl = options.cache\n      ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))\n      : exports.compile(str, options);\n    fn(null, tmpl(options));\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Render a Jade file at the given `path` and callback `fn(err, str)`.\n *\n * @param {String} path\n * @param {Object|Function} options or callback\n * @param {Function} fn\n * @api public\n */\n\nexports.renderFile = function(path, options, fn){\n  var key = path + ':string';\n\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  try {\n    options.filename = path;\n    var str = options.cache\n      ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))\n      : fs.readFileSync(path, 'utf8');\n    exports.render(str, options, fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Express support.\n */\n\nexports.__express = exports.renderFile;\n\n}); // module: jade.js\n\nrequire.register(\"lexer.js\", function(module, exports, require){\n\n/*!\n * Jade - Lexer\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Initialize `Lexer` with the given `str`.\n *\n * Options:\n *\n *   - `colons` allow colons for attr delimiters\n *\n * @param {String} str\n * @param {Object} options\n * @api private\n */\n\nvar Lexer = module.exports = function Lexer(str, options) {\n  options = options || {};\n  this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n  this.colons = options.colons;\n  this.deferredTokens = [];\n  this.lastIndents = 0;\n  this.lineno = 1;\n  this.stash = [];\n  this.indentStack = [];\n  this.indentRe = null;\n  this.pipeless = false;\n};\n\n/**\n * Lexer prototype.\n */\n\nLexer.prototype = {\n  \n  /**\n   * Construct a token with the given `type` and `val`.\n   *\n   * @param {String} type\n   * @param {String} val\n   * @return {Object}\n   * @api private\n   */\n  \n  tok: function(type, val){\n    return {\n        type: type\n      , line: this.lineno\n      , val: val\n    }\n  },\n  \n  /**\n   * Consume the given `len` of input.\n   *\n   * @param {Number} len\n   * @api private\n   */\n  \n  consume: function(len){\n    this.input = this.input.substr(len);\n  },\n  \n  /**\n   * Scan for `type` with the given `regexp`.\n   *\n   * @param {String} type\n   * @param {RegExp} regexp\n   * @return {Object}\n   * @api private\n   */\n  \n  scan: function(regexp, type){\n    var captures;\n    if (captures = regexp.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok(type, captures[1]);\n    }\n  },\n  \n  /**\n   * Defer the given `tok`.\n   *\n   * @param {Object} tok\n   * @api private\n   */\n  \n  defer: function(tok){\n    this.deferredTokens.push(tok);\n  },\n  \n  /**\n   * Lookahead `n` tokens.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  \n  lookahead: function(n){\n    var fetch = n - this.stash.length;\n    while (fetch-- > 0) this.stash.push(this.next());\n    return this.stash[--n];\n  },\n  \n  /**\n   * Return the indexOf `start` / `end` delimiters.\n   *\n   * @param {String} start\n   * @param {String} end\n   * @return {Number}\n   * @api private\n   */\n  \n  indexOfDelimiters: function(start, end){\n    var str = this.input\n      , nstart = 0\n      , nend = 0\n      , pos = 0;\n    for (var i = 0, len = str.length; i < len; ++i) {\n      if (start == str.charAt(i)) {\n        ++nstart;\n      } else if (end == str.charAt(i)) {\n        if (++nend == nstart) {\n          pos = i;\n          break;\n        }\n      }\n    }\n    return pos;\n  },\n  \n  /**\n   * Stashed token.\n   */\n  \n  stashed: function() {\n    return this.stash.length\n      && this.stash.shift();\n  },\n  \n  /**\n   * Deferred token.\n   */\n  \n  deferred: function() {\n    return this.deferredTokens.length \n      && this.deferredTokens.shift();\n  },\n  \n  /**\n   * end-of-source.\n   */\n  \n  eos: function() {\n    if (this.input.length) return;\n    if (this.indentStack.length) {\n      this.indentStack.shift();\n      return this.tok('outdent');\n    } else {\n      return this.tok('eos');\n    }\n  },\n\n  /**\n   * Blank line.\n   */\n  \n  blank: function() {\n    var captures;\n    if (captures = /^\\n *\\n/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n      if (this.pipeless) return this.tok('text', '');\n      return this.next();\n    }\n  },\n\n  /**\n   * Comment.\n   */\n  \n  comment: function() {\n    var captures;\n    if (captures = /^ *\\/\\/(-)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('comment', captures[2]);\n      tok.buffer = '-' != captures[1];\n      return tok;\n    }\n  },\n\n  /**\n   * Interpolated tag.\n   */\n\n  interpolation: function() {\n    var captures;\n    if (captures = /^#\\{(.*?)\\}/.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok('interpolation', captures[1]);\n    }\n  },\n\n  /**\n   * Tag.\n   */\n  \n  tag: function() {\n    var captures;\n    if (captures = /^(\\w[-:\\w]*)(\\/?)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok, name = captures[1];\n      if (':' == name[name.length - 1]) {\n        name = name.slice(0, -1);\n        tok = this.tok('tag', name);\n        this.defer(this.tok(':'));\n        while (' ' == this.input[0]) this.input = this.input.substr(1);\n      } else {\n        tok = this.tok('tag', name);\n      }\n      tok.selfClosing = !! captures[2];\n      return tok;\n    }\n  },\n  \n  /**\n   * Filter.\n   */\n  \n  filter: function() {\n    return this.scan(/^:(\\w+)/, 'filter');\n  },\n  \n  /**\n   * Doctype.\n   */\n  \n  doctype: function() {\n    return this.scan(/^(?:!!!|doctype) *([^\\n]+)?/, 'doctype');\n  },\n\n  /**\n   * Id.\n   */\n  \n  id: function() {\n    return this.scan(/^#([\\w-]+)/, 'id');\n  },\n  \n  /**\n   * Class.\n   */\n  \n  className: function() {\n    return this.scan(/^\\.([\\w-]+)/, 'class');\n  },\n  \n  /**\n   * Text.\n   */\n  \n  text: function() {\n    return this.scan(/^(?:\\| ?| ?)?([^\\n]+)/, 'text');\n  },\n\n  /**\n   * Extends.\n   */\n  \n  \"extends\": function() {\n    return this.scan(/^extends? +([^\\n]+)/, 'extends');\n  },\n\n  /**\n   * Block prepend.\n   */\n  \n  prepend: function() {\n    var captures;\n    if (captures = /^prepend +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = 'prepend'\n        , name = captures[1]\n        , tok = this.tok('block', name);\n      tok.mode = mode;\n      return tok;\n    }\n  },\n  \n  /**\n   * Block append.\n   */\n  \n  append: function() {\n    var captures;\n    if (captures = /^append +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = 'append'\n        , name = captures[1]\n        , tok = this.tok('block', name);\n      tok.mode = mode;\n      return tok;\n    }\n  },\n\n  /**\n   * Block.\n   */\n  \n  block: function() {\n    var captures;\n    if (captures = /^block\\b *(?:(prepend|append) +)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = captures[1] || 'replace'\n        , name = captures[2]\n        , tok = this.tok('block', name);\n\n      tok.mode = mode;\n      return tok;\n    }\n  },\n\n  /**\n   * Yield.\n   */\n  \n  yield: function() {\n    return this.scan(/^yield */, 'yield');\n  },\n\n  /**\n   * Include.\n   */\n  \n  include: function() {\n    return this.scan(/^include +([^\\n]+)/, 'include');\n  },\n\n  /**\n   * Case.\n   */\n  \n  \"case\": function() {\n    return this.scan(/^case +([^\\n]+)/, 'case');\n  },\n\n  /**\n   * When.\n   */\n  \n  when: function() {\n    return this.scan(/^when +([^:\\n]+)/, 'when');\n  },\n\n  /**\n   * Default.\n   */\n  \n  \"default\": function() {\n    return this.scan(/^default */, 'default');\n  },\n\n  /**\n   * Assignment.\n   */\n  \n  assignment: function() {\n    var captures;\n    if (captures = /^(\\w+) += *([^;\\n]+)( *;? *)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var name = captures[1]\n        , val = captures[2];\n      return this.tok('code', 'var ' + name + ' = (' + val + ');');\n    }\n  },\n\n  /**\n   * Call mixin.\n   */\n  \n  call: function(){\n    var captures;\n    if (captures = /^\\+([-\\w]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('call', captures[1]);\n      \n      // Check for args (not attributes)\n      if (captures = /^ *\\((.*?)\\)/.exec(this.input)) {\n        if (!/^ *[-\\w]+ *=/.test(captures[1])) {\n          this.consume(captures[0].length);\n          tok.args = captures[1];\n        }\n      }\n      \n      return tok;\n    }\n  },\n\n  /**\n   * Mixin.\n   */\n\n  mixin: function(){\n    var captures;\n    if (captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))?/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('mixin', captures[1]);\n      tok.args = captures[2];\n      return tok;\n    }\n  },\n\n  /**\n   * Conditional.\n   */\n  \n  conditional: function() {\n    var captures;\n    if (captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var type = captures[1]\n        , js = captures[2];\n\n      switch (type) {\n        case 'if': js = 'if (' + js + ')'; break;\n        case 'unless': js = 'if (!(' + js + '))'; break;\n        case 'else if': js = 'else if (' + js + ')'; break;\n        case 'else': js = 'else'; break;\n      }\n\n      return this.tok('code', js);\n    }\n  },\n\n  /**\n   * While.\n   */\n  \n  \"while\": function() {\n    var captures;\n    if (captures = /^while +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok('code', 'while (' + captures[1] + ')');\n    }\n  },\n\n  /**\n   * Each.\n   */\n  \n  each: function() {\n    var captures;\n    if (captures = /^(?:- *)?(?:each|for) +(\\w+)(?: *, *(\\w+))? * in *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('each', captures[1]);\n      tok.key = captures[2] || '$index';\n      tok.code = captures[3];\n      return tok;\n    }\n  },\n  \n  /**\n   * Code.\n   */\n  \n  code: function() {\n    var captures;\n    if (captures = /^(!?=|-)([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var flags = captures[1];\n      captures[1] = captures[2];\n      var tok = this.tok('code', captures[1]);\n      tok.escape = flags[0] === '=';\n      tok.buffer = flags[0] === '=' || flags[1] === '=';\n      return tok;\n    }\n  },\n  \n  /**\n   * Attributes.\n   */\n  \n  attrs: function() {\n    if ('(' == this.input.charAt(0)) {\n      var index = this.indexOfDelimiters('(', ')')\n        , str = this.input.substr(1, index-1)\n        , tok = this.tok('attrs')\n        , len = str.length\n        , colons = this.colons\n        , states = ['key']\n        , escapedAttr\n        , key = ''\n        , val = ''\n        , quote\n        , c\n        , p;\n\n      function state(){\n        return states[states.length - 1];\n      }\n\n      function interpolate(attr) {\n        return attr.replace(/#\\{([^}]+)\\}/g, function(_, expr){\n          return quote + \" + (\" + expr + \") + \" + quote;\n        });\n      }\n\n      this.consume(index + 1);\n      tok.attrs = {};\n      tok.escaped = {};\n\n      function parse(c) {\n        var real = c;\n        // TODO: remove when people fix \":\"\n        if (colons && ':' == c) c = '=';\n        switch (c) {\n          case ',':\n          case '\\n':\n            switch (state()) {\n              case 'expr':\n              case 'array':\n              case 'string':\n              case 'object':\n                val += c;\n                break;\n              default:\n                states.push('key');\n                val = val.trim();\n                key = key.trim();\n                if ('' == key) return;\n                key = key.replace(/^['\"]|['\"]$/g, '').replace('!', '');\n                tok.escaped[key] = escapedAttr;\n                tok.attrs[key] = '' == val\n                  ? true\n                  : interpolate(val);\n                key = val = '';\n            }\n            break;\n          case '=':\n            switch (state()) {\n              case 'key char':\n                key += real;\n                break;\n              case 'val':\n              case 'expr':\n              case 'array':\n              case 'string':\n              case 'object':\n                val += real;\n                break;\n              default:\n                escapedAttr = '!' != p;\n                states.push('val');\n            }\n            break;\n          case '(':\n            if ('val' == state()\n              || 'expr' == state()) states.push('expr');\n            val += c;\n            break;\n          case ')':\n            if ('expr' == state()\n              || 'val' == state()) states.pop();\n            val += c;\n            break;\n          case '{':\n            if ('val' == state()) states.push('object');\n            val += c;\n            break;\n          case '}':\n            if ('object' == state()) states.pop();\n            val += c;\n            break;\n          case '[':\n            if ('val' == state()) states.push('array');\n            val += c;\n            break;\n          case ']':\n            if ('array' == state()) states.pop();\n            val += c;\n            break;\n          case '\"':\n          case \"'\":\n            switch (state()) {\n              case 'key':\n                states.push('key char');\n                break;\n              case 'key char':\n                states.pop();\n                break;\n              case 'string':\n                if (c == quote) states.pop();\n                val += c;\n                break;\n              default:\n                states.push('string');\n                val += c;\n                quote = c;\n            }\n            break;\n          case '':\n            break;\n          default:\n            switch (state()) {\n              case 'key':\n              case 'key char':\n                key += c;\n                break;\n              default:\n                val += c;\n            }\n        }\n        p = c;\n      }\n\n      for (var i = 0; i < len; ++i) {\n        parse(str.charAt(i));\n      }\n\n      parse(',');\n\n      if ('/' == this.input.charAt(0)) {\n        this.consume(1);\n        tok.selfClosing = true;\n      }\n\n      return tok;\n    }\n  },\n  \n  /**\n   * Indent | Outdent | Newline.\n   */\n  \n  indent: function() {\n    var captures, re;\n\n    // established regexp\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input);\n    // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input);\n\n      // spaces\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      }\n\n      // established\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    if (captures) {\n      var tok\n        , indents = captures[1].length;\n\n      ++this.lineno;\n      this.consume(indents + 1);\n\n      if (' ' == this.input[0] || '\\t' == this.input[0]) {\n        throw new Error('Invalid indentation, you can use tabs or spaces but not both');\n      }\n\n      // blank line\n      if ('\\n' == this.input[0]) return this.tok('newline');\n\n      // outdent\n      if (this.indentStack.length && indents < this.indentStack[0]) {\n        while (this.indentStack.length && this.indentStack[0] > indents) {\n          this.stash.push(this.tok('outdent'));\n          this.indentStack.shift();\n        }\n        tok = this.stash.pop();\n      // indent\n      } else if (indents && indents != this.indentStack[0]) {\n        this.indentStack.unshift(indents);\n        tok = this.tok('indent', indents);\n      // newline\n      } else {\n        tok = this.tok('newline');\n      }\n\n      return tok;\n    }\n  },\n\n  /**\n   * Pipe-less text consumed only when \n   * pipeless is true;\n   */\n\n  pipelessText: function() {\n    if (this.pipeless) {\n      if ('\\n' == this.input[0]) return;\n      var i = this.input.indexOf('\\n');\n      if (-1 == i) i = this.input.length;\n      var str = this.input.substr(0, i);\n      this.consume(str.length);\n      return this.tok('text', str);\n    }\n  },\n\n  /**\n   * ':'\n   */\n\n  colon: function() {\n    return this.scan(/^: */, ':');\n  },\n\n  /**\n   * Return the next token object, or those\n   * previously stashed by lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n  \n  advance: function(){\n    return this.stashed()\n      || this.next();\n  },\n  \n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n  \n  next: function() {\n    return this.deferred()\n      || this.blank()\n      || this.eos()\n      || this.pipelessText()\n      || this.yield()\n      || this.doctype()\n      || this.interpolation()\n      || this[\"case\"]()\n      || this.when()\n      || this[\"default\"]()\n      || this[\"extends\"]()\n      || this.append()\n      || this.prepend()\n      || this.block()\n      || this.include()\n      || this.mixin()\n      || this.call()\n      || this.conditional()\n      || this.each()\n      || this[\"while\"]()\n      || this.assignment()\n      || this.tag()\n      || this.filter()\n      || this.code()\n      || this.id()\n      || this.className()\n      || this.attrs()\n      || this.indent()\n      || this.comment()\n      || this.colon()\n      || this.text();\n  }\n};\n\n}); // module: lexer.js\n\nrequire.register(\"nodes/attrs.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Attrs\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node'),\n    Block = require('./block');\n\n/**\n * Initialize a `Attrs` node.\n *\n * @api public\n */\n\nvar Attrs = module.exports = function Attrs() {\n  this.attrs = [];\n};\n\n/**\n * Inherit from `Node`.\n */\n\nAttrs.prototype = new Node;\nAttrs.prototype.constructor = Attrs;\n\n\n/**\n * Set attribute `name` to `val`, keep in mind these become\n * part of a raw js object literal, so to quote a value you must\n * '\"quote me\"', otherwise or example 'user.name' is literal JavaScript.\n *\n * @param {String} name\n * @param {String} val\n * @param {Boolean} escaped\n * @return {Tag} for chaining\n * @api public\n */\n\nAttrs.prototype.setAttribute = function(name, val, escaped){\n  this.attrs.push({ name: name, val: val, escaped: escaped });\n  return this;\n};\n\n/**\n * Remove attribute `name` when present.\n *\n * @param {String} name\n * @api public\n */\n\nAttrs.prototype.removeAttribute = function(name){\n  for (var i = 0, len = this.attrs.length; i < len; ++i) {\n    if (this.attrs[i] && this.attrs[i].name == name) {\n      delete this.attrs[i];\n    }\n  }\n};\n\n/**\n * Get attribute value by `name`.\n *\n * @param {String} name\n * @return {String}\n * @api public\n */\n\nAttrs.prototype.getAttribute = function(name){\n  for (var i = 0, len = this.attrs.length; i < len; ++i) {\n    if (this.attrs[i] && this.attrs[i].name == name) {\n      return this.attrs[i].val;\n    }\n  }\n};\n\n}); // module: nodes/attrs.js\n\nrequire.register(\"nodes/block-comment.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - BlockComment\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `BlockComment` with the given `block`.\n *\n * @param {String} val\n * @param {Block} block\n * @param {Boolean} buffer\n * @api public\n */\n\nvar BlockComment = module.exports = function BlockComment(val, block, buffer) {\n  this.block = block;\n  this.val = val;\n  this.buffer = buffer;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nBlockComment.prototype = new Node;\nBlockComment.prototype.constructor = BlockComment;\n\n}); // module: nodes/block-comment.js\n\nrequire.register(\"nodes/block.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Block\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Block` with an optional `node`.\n *\n * @param {Node} node\n * @api public\n */\n\nvar Block = module.exports = function Block(node){\n  this.nodes = [];\n  if (node) this.push(node);\n};\n\n/**\n * Inherit from `Node`.\n */\n\nBlock.prototype = new Node;\nBlock.prototype.constructor = Block;\n\n\n/**\n * Block flag.\n */\n\nBlock.prototype.isBlock = true;\n\n/**\n * Replace the nodes in `other` with the nodes\n * in `this` block.\n *\n * @param {Block} other\n * @api private\n */\n\nBlock.prototype.replace = function(other){\n  other.nodes = this.nodes;\n};\n\n/**\n * Pust the given `node`.\n *\n * @param {Node} node\n * @return {Number}\n * @api public\n */\n\nBlock.prototype.push = function(node){\n  return this.nodes.push(node);\n};\n\n/**\n * Check if this block is empty.\n *\n * @return {Boolean}\n * @api public\n */\n\nBlock.prototype.isEmpty = function(){\n  return 0 == this.nodes.length;\n};\n\n/**\n * Unshift the given `node`.\n *\n * @param {Node} node\n * @return {Number}\n * @api public\n */\n\nBlock.prototype.unshift = function(node){\n  return this.nodes.unshift(node);\n};\n\n/**\n * Return the \"last\" block, or the first `yield` node.\n *\n * @return {Block}\n * @api private\n */\n\nBlock.prototype.includeBlock = function(){\n  var ret = this\n    , node;\n\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    node = this.nodes[i];\n    if (node.yield) return node;\n    else if (node.textOnly) continue;\n    else if (node.includeBlock) ret = node.includeBlock();\n    else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();\n  }\n\n  return ret;\n};\n\n/**\n * Return a clone of this block.\n *\n * @return {Block}\n * @api private\n */\n\nBlock.prototype.clone = function(){\n  var clone = new Block;\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    clone.push(this.nodes[i].clone());\n  }\n  return clone;\n};\n\n\n}); // module: nodes/block.js\n\nrequire.register(\"nodes/case.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Case\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Case` with `expr`.\n *\n * @param {String} expr\n * @api public\n */\n\nvar Case = exports = module.exports = function Case(expr, block){\n  this.expr = expr;\n  this.block = block;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nCase.prototype = new Node;\nCase.prototype.constructor = Case;\n\n\nvar When = exports.When = function When(expr, block){\n  this.expr = expr;\n  this.block = block;\n  this.debug = false;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nWhen.prototype = new Node;\nWhen.prototype.constructor = When;\n\n\n\n}); // module: nodes/case.js\n\nrequire.register(\"nodes/code.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Code\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Code` node with the given code `val`.\n * Code may also be optionally buffered and escaped.\n *\n * @param {String} val\n * @param {Boolean} buffer\n * @param {Boolean} escape\n * @api public\n */\n\nvar Code = module.exports = function Code(val, buffer, escape) {\n  this.val = val;\n  this.buffer = buffer;\n  this.escape = escape;\n  if (val.match(/^ *else/)) this.debug = false;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nCode.prototype = new Node;\nCode.prototype.constructor = Code;\n\n}); // module: nodes/code.js\n\nrequire.register(\"nodes/comment.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Comment\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Comment` with the given `val`, optionally `buffer`,\n * otherwise the comment may render in the output.\n *\n * @param {String} val\n * @param {Boolean} buffer\n * @api public\n */\n\nvar Comment = module.exports = function Comment(val, buffer) {\n  this.val = val;\n  this.buffer = buffer;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nComment.prototype = new Node;\nComment.prototype.constructor = Comment;\n\n}); // module: nodes/comment.js\n\nrequire.register(\"nodes/doctype.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Doctype\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Doctype` with the given `val`. \n *\n * @param {String} val\n * @api public\n */\n\nvar Doctype = module.exports = function Doctype(val) {\n  this.val = val;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nDoctype.prototype = new Node;\nDoctype.prototype.constructor = Doctype;\n\n}); // module: nodes/doctype.js\n\nrequire.register(\"nodes/each.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Each\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize an `Each` node, representing iteration\n *\n * @param {String} obj\n * @param {String} val\n * @param {String} key\n * @param {Block} block\n * @api public\n */\n\nvar Each = module.exports = function Each(obj, val, key, block) {\n  this.obj = obj;\n  this.val = val;\n  this.key = key;\n  this.block = block;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nEach.prototype = new Node;\nEach.prototype.constructor = Each;\n\n}); // module: nodes/each.js\n\nrequire.register(\"nodes/filter.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Filter\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , Block = require('./block');\n\n/**\n * Initialize a `Filter` node with the given \n * filter `name` and `block`.\n *\n * @param {String} name\n * @param {Block|Node} block\n * @api public\n */\n\nvar Filter = module.exports = function Filter(name, block, attrs) {\n  this.name = name;\n  this.block = block;\n  this.attrs = attrs;\n  this.isASTFilter = !block.nodes.every(function(node){ return node.isText });\n};\n\n/**\n * Inherit from `Node`.\n */\n\nFilter.prototype = new Node;\nFilter.prototype.constructor = Filter;\n\n}); // module: nodes/filter.js\n\nrequire.register(\"nodes/index.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nexports.Node = require('./node');\nexports.Tag = require('./tag');\nexports.Code = require('./code');\nexports.Each = require('./each');\nexports.Case = require('./case');\nexports.Text = require('./text');\nexports.Block = require('./block');\nexports.Mixin = require('./mixin');\nexports.Filter = require('./filter');\nexports.Comment = require('./comment');\nexports.Literal = require('./literal');\nexports.BlockComment = require('./block-comment');\nexports.Doctype = require('./doctype');\n\n}); // module: nodes/index.js\n\nrequire.register(\"nodes/literal.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Literal\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Literal` node with the given `str.\n *\n * @param {String} str\n * @api public\n */\n\nvar Literal = module.exports = function Literal(str) {\n  this.str = str\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\\n|\\r\\n/g, \"\\\\n\")\n    .replace(/'/g, \"\\\\'\");\n};\n\n/**\n * Inherit from `Node`.\n */\n\nLiteral.prototype = new Node;\nLiteral.prototype.constructor = Literal;\n\n\n}); // module: nodes/literal.js\n\nrequire.register(\"nodes/mixin.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Mixin\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Attrs = require('./attrs');\n\n/**\n * Initialize a new `Mixin` with `name` and `block`.\n *\n * @param {String} name\n * @param {String} args\n * @param {Block} block\n * @api public\n */\n\nvar Mixin = module.exports = function Mixin(name, args, block, call){\n  this.name = name;\n  this.args = args;\n  this.block = block;\n  this.attrs = [];\n  this.call = call;\n};\n\n/**\n * Inherit from `Attrs`.\n */\n\nMixin.prototype = new Attrs;\nMixin.prototype.constructor = Mixin;\n\n\n\n}); // module: nodes/mixin.js\n\nrequire.register(\"nodes/node.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Node\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Initialize a `Node`.\n *\n * @api public\n */\n\nvar Node = module.exports = function Node(){};\n\n/**\n * Clone this node (return itself)\n *\n * @return {Node}\n * @api private\n */\n\nNode.prototype.clone = function(){\n  return this;\n};\n\n}); // module: nodes/node.js\n\nrequire.register(\"nodes/tag.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Tag\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Attrs = require('./attrs'),\n    Block = require('./block'),\n    inlineTags = require('../inline-tags');\n\n/**\n * Initialize a `Tag` node with the given tag `name` and optional `block`.\n *\n * @param {String} name\n * @param {Block} block\n * @api public\n */\n\nvar Tag = module.exports = function Tag(name, block) {\n  this.name = name;\n  this.attrs = [];\n  this.block = block || new Block;\n};\n\n/**\n * Inherit from `Attrs`.\n */\n\nTag.prototype = new Attrs;\nTag.prototype.constructor = Tag;\n\n\n/**\n * Clone this tag.\n *\n * @return {Tag}\n * @api private\n */\n\nTag.prototype.clone = function(){\n  var clone = new Tag(this.name, this.block.clone());\n  clone.line = this.line;\n  clone.attrs = this.attrs;\n  clone.textOnly = this.textOnly;\n  return clone;\n};\n\n/**\n * Check if this tag is an inline tag.\n *\n * @return {Boolean}\n * @api private\n */\n\nTag.prototype.isInline = function(){\n  return ~inlineTags.indexOf(this.name);\n};\n\n/**\n * Check if this tag's contents can be inlined.  Used for pretty printing.\n *\n * @return {Boolean}\n * @api private\n */\n\nTag.prototype.canInline = function(){\n  var nodes = this.block.nodes;\n\n  function isInline(node){\n    // Recurse if the node is a block\n    if (node.isBlock) return node.nodes.every(isInline);\n    return node.isText || (node.isInline && node.isInline());\n  }\n  \n  // Empty tag\n  if (!nodes.length) return true;\n  \n  // Text-only or inline-only tag\n  if (1 == nodes.length) return isInline(nodes[0]);\n  \n  // Multi-line inline-only tag\n  if (this.block.nodes.every(isInline)) {\n    for (var i = 1, len = nodes.length; i < len; ++i) {\n      if (nodes[i-1].isText && nodes[i].isText)\n        return false;\n    }\n    return true;\n  }\n  \n  // Mixed tag\n  return false;\n};\n}); // module: nodes/tag.js\n\nrequire.register(\"nodes/text.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Text\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Text` node with optional `line`.\n *\n * @param {String} line\n * @api public\n */\n\nvar Text = module.exports = function Text(line) {\n  this.val = '';\n  if ('string' == typeof line) this.val = line;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nText.prototype = new Node;\nText.prototype.constructor = Text;\n\n\n/**\n * Flag as text.\n */\n\nText.prototype.isText = true;\n}); // module: nodes/text.js\n\nrequire.register(\"parser.js\", function(module, exports, require){\n\n/*!\n * Jade - Parser\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Lexer = require('./lexer')\n  , nodes = require('./nodes');\n\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\nvar Parser = exports = module.exports = function Parser(str, filename, options){\n  this.input = str;\n  this.lexer = new Lexer(str, options);\n  this.filename = filename;\n  this.blocks = {};\n  this.mixins = {};\n  this.options = options;\n  this.contexts = [this];\n};\n\n/**\n * Tags that may not contain tags.\n */\n\nvar textOnly = exports.textOnly = ['script', 'style'];\n\n/**\n * Parser prototype.\n */\n\nParser.prototype = {\n\n  /**\n   * Push `parser` onto the context stack,\n   * or pop and return a `Parser`.\n   */\n\n  context: function(parser){\n    if (parser) {\n      this.contexts.push(parser);\n    } else {\n      return this.contexts.pop();\n    }\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  advance: function(){\n    return this.lexer.advance();\n  },\n\n  /**\n   * Skip `n` tokens.\n   *\n   * @param {Number} n\n   * @api private\n   */\n\n  skip: function(n){\n    while (n--) this.advance();\n  },\n  \n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n  \n  peek: function() {\n    return this.lookahead(1);\n  },\n  \n  /**\n   * Return lexer lineno.\n   *\n   * @return {Number}\n   * @api private\n   */\n  \n  line: function() {\n    return this.lexer.lineno;\n  },\n  \n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  \n  lookahead: function(n){\n    return this.lexer.lookahead(n);\n  },\n  \n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n  \n  parse: function(){\n    var block = new nodes.Block, parser;\n    block.line = this.line();\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        block.push(this.parseExpr());\n      }\n    }\n\n    if (parser = this.extending) {\n      this.context(parser);\n      var ast = parser.parse();\n      this.context();\n      // hoist mixins\n      for (var name in this.mixins)\n        ast.unshift(this.mixins[name]);\n      return ast;\n    }\n\n    return block;\n  },\n  \n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n  \n  expect: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      throw new Error('expected \"' + type + '\", but got \"' + this.peek().type + '\"');\n    }\n  },\n  \n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n  \n  accept: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n  \n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n  \n  parseExpr: function(){\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n      case 'mixin':\n        return this.parseMixin();\n      case 'block':\n        return this.parseBlock();\n      case 'case':\n        return this.parseCase();\n      case 'when':\n        return this.parseWhen();\n      case 'default':\n        return this.parseDefault();\n      case 'extends':\n        return this.parseExtends();\n      case 'include':\n        return this.parseInclude();\n      case 'doctype':\n        return this.parseDoctype();\n      case 'filter':\n        return this.parseFilter();\n      case 'comment':\n        return this.parseComment();\n      case 'text':\n        return this.parseText();\n      case 'each':\n        return this.parseEach();\n      case 'code':\n        return this.parseCode();\n      case 'call':\n        return this.parseCall();\n      case 'interpolation':\n        return this.parseInterpolation();\n      case 'yield':\n        this.advance();\n        var block = new nodes.Block;\n        block.yield = true;\n        return block;\n      case 'id':\n      case 'class':\n        var tok = this.advance();\n        this.lexer.defer(this.lexer.tok('tag', 'div'));\n        this.lexer.defer(tok);\n        return this.parseExpr();\n      default:\n        throw new Error('unexpected token \"' + this.peek().type + '\"');\n    }\n  },\n  \n  /**\n   * Text\n   */\n  \n  parseText: function(){\n    var tok = this.expect('text')\n      , node = new nodes.Text(tok.val);\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n\n  parseBlockExpansion: function(){\n    if (':' == this.peek().type) {\n      this.advance();\n      return new nodes.Block(this.parseExpr());\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n\n  parseCase: function(){\n    var val = this.expect('case').val\n      , node = new nodes.Case(val);\n    node.line = this.line();\n    node.block = this.block();\n    return node;\n  },\n\n  /**\n   * when\n   */\n\n  parseWhen: function(){\n    var val = this.expect('when').val\n    return new nodes.Case.When(val, this.parseBlockExpansion());\n  },\n  \n  /**\n   * default\n   */\n\n  parseDefault: function(){\n    this.expect('default');\n    return new nodes.Case.When('default', this.parseBlockExpansion());\n  },\n\n  /**\n   * code\n   */\n  \n  parseCode: function(){\n    var tok = this.expect('code')\n      , node = new nodes.Code(tok.val, tok.buffer, tok.escape)\n      , block\n      , i = 1;\n    node.line = this.line();\n    while (this.lookahead(i) && 'newline' == this.lookahead(i).type) ++i;\n    block = 'indent' == this.lookahead(i).type;\n    if (block) {\n      this.skip(i-1);\n      node.block = this.block();\n    }\n    return node;\n  },\n  \n  /**\n   * comment\n   */\n  \n  parseComment: function(){\n    var tok = this.expect('comment')\n      , node;\n\n    if ('indent' == this.peek().type) {\n      node = new nodes.BlockComment(tok.val, this.block(), tok.buffer);\n    } else {\n      node = new nodes.Comment(tok.val, tok.buffer);\n    }\n\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * doctype\n   */\n  \n  parseDoctype: function(){\n    var tok = this.expect('doctype')\n      , node = new nodes.Doctype(tok.val);\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * filter attrs? text-block\n   */\n  \n  parseFilter: function(){\n    var block\n      , tok = this.expect('filter')\n      , attrs = this.accept('attrs');\n\n    this.lexer.pipeless = true;\n    block = this.parseTextBlock();\n    this.lexer.pipeless = false;\n\n    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * tag ':' attrs? block\n   */\n  \n  parseASTFilter: function(){\n    var block\n      , tok = this.expect('tag')\n      , attrs = this.accept('attrs');\n\n    this.expect(':');\n    block = this.block();\n\n    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * each block\n   */\n  \n  parseEach: function(){\n    var tok = this.expect('each')\n      , node = new nodes.Each(tok.code, tok.val, tok.key);\n    node.line = this.line();\n    node.block = this.block();\n    return node;\n  },\n\n  /**\n   * 'extends' name\n   */\n\n  parseExtends: function(){\n    var path = require('path')\n      , fs = require('fs')\n      , dirname = path.dirname\n      , basename = path.basename\n      , join = path.join;\n\n    if (!this.filename)\n      throw new Error('the \"filename\" option is required to extend templates');\n\n    var path = this.expect('extends').val.trim()\n      , dir = dirname(this.filename);\n\n    var path = join(dir, path + '.jade')\n      , str = fs.readFileSync(path, 'utf8')\n      , parser = new Parser(str, path, this.options);\n\n    parser.blocks = this.blocks;\n    parser.contexts = this.contexts;\n    this.extending = parser;\n\n    // TODO: null node\n    return new nodes.Literal('');\n  },\n\n  /**\n   * 'block' name block\n   */\n\n  parseBlock: function(){\n    var block = this.expect('block')\n      , mode = block.mode\n      , name = block.val.trim();\n\n    block = 'indent' == this.peek().type\n      ? this.block()\n      : new nodes.Block(new nodes.Literal(''));\n\n    var prev = this.blocks[name];\n\n    if (prev) {\n      switch (prev.mode) {\n        case 'append':\n          block.nodes = block.nodes.concat(prev.nodes);\n          prev = block;\n          break;\n        case 'prepend':\n          block.nodes = prev.nodes.concat(block.nodes);\n          prev = block;\n          break;\n      }\n    }\n\n    block.mode = mode;\n    return this.blocks[name] = prev || block;\n  },\n\n  /**\n   * include block?\n   */\n\n  parseInclude: function(){\n    var path = require('path')\n      , fs = require('fs')\n      , dirname = path.dirname\n      , basename = path.basename\n      , join = path.join;\n\n    var path = this.expect('include').val.trim()\n      , dir = dirname(this.filename);\n\n    if (!this.filename)\n      throw new Error('the \"filename\" option is required to use includes');\n\n    // no extension\n    if (!~basename(path).indexOf('.')) {\n      path += '.jade';\n    }\n\n    // non-jade\n    if ('.jade' != path.substr(-5)) {\n      var path = join(dir, path)\n        , str = fs.readFileSync(path, 'utf8');\n      return new nodes.Literal(str);\n    }\n\n    var path = join(dir, path)\n      , str = fs.readFileSync(path, 'utf8')\n     , parser = new Parser(str, path, this.options);\n    parser.blocks = this.blocks;\n    parser.mixins = this.mixins;\n\n    this.context(parser);\n    var ast = parser.parse();\n    this.context();\n    ast.filename = path;\n\n    if ('indent' == this.peek().type) {\n      ast.includeBlock().push(this.block());\n    }\n\n    return ast;\n  },\n\n  /**\n   * call ident block\n   */\n\n  parseCall: function(){\n    var tok = this.expect('call')\n      , name = tok.val\n      , args = tok.args\n      , mixin = new nodes.Mixin(name, args, new nodes.Block, true);\n\n    this.tag(mixin);\n    if (mixin.block.isEmpty()) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n\n  parseMixin: function(){\n    var tok = this.expect('mixin')\n      , name = tok.val\n      , args = tok.args\n      , mixin;\n\n    // definition\n    if ('indent' == this.peek().type) {\n      mixin = new nodes.Mixin(name, args, this.block(), false);\n      this.mixins[name] = mixin;\n      return mixin;\n    // call\n    } else {\n      return new nodes.Mixin(name, args, null, true);\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n\n  parseTextBlock: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    var spaces = this.expect('indent').val;\n    if (null == this._spaces) this._spaces = spaces;\n    var indent = Array(spaces - this._spaces + 1).join(' ');\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'newline':\n          this.advance();\n          break;\n        case 'indent':\n          this.parseTextBlock().nodes.forEach(function(node){\n            block.push(node);\n          });\n          break;\n        default:\n          var text = new nodes.Text(indent + this.advance().val);\n          text.line = this.line();\n          block.push(text);\n      }\n    }\n\n    if (spaces == this._spaces) this._spaces = null;\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n  \n  block: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    this.expect('indent');\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        block.push(this.parseExpr());\n      }\n    }\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  \n  parseInterpolation: function(){\n    var tok = this.advance();\n    var tag = new nodes.Tag(tok.val);\n    tag.buffer = true;\n    return this.tag(tag);\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  \n  parseTag: function(){\n    // ast-filter look-ahead\n    var i = 2;\n    if ('attrs' == this.lookahead(i).type) ++i;\n    if (':' == this.lookahead(i).type) {\n      if ('indent' == this.lookahead(++i).type) {\n        return this.parseASTFilter();\n      }\n    }\n\n    var tok = this.advance()\n      , tag = new nodes.Tag(tok.val);\n\n    tag.selfClosing = tok.selfClosing;\n\n    return this.tag(tag);\n  },\n\n  /**\n   * Parse tag.\n   */\n\n  tag: function(tag){\n    var dot;\n\n    tag.line = this.line();\n\n    // (attrs | class | id)*\n    out:\n      while (true) {\n        switch (this.peek().type) {\n          case 'id':\n          case 'class':\n            var tok = this.advance();\n            tag.setAttribute(tok.type, \"'\" + tok.val + \"'\");\n            continue;\n          case 'attrs':\n            var tok = this.advance()\n              , obj = tok.attrs\n              , escaped = tok.escaped\n              , names = Object.keys(obj);\n\n            if (tok.selfClosing) tag.selfClosing = true;\n\n            for (var i = 0, len = names.length; i < len; ++i) {\n              var name = names[i]\n                , val = obj[name];\n              tag.setAttribute(name, val, escaped[name]);\n            }\n            continue;\n          default:\n            break out;\n        }\n      }\n\n    // check immediate '.'\n    if ('.' == this.peek().val) {\n      dot = tag.textOnly = true;\n      this.advance();\n    }\n\n    // (text | code | ':')?\n    switch (this.peek().type) {\n      case 'text':\n        tag.block.push(this.parseText());\n        break;\n      case 'code':\n        tag.code = this.parseCode();\n        break;\n      case ':':\n        this.advance();\n        tag.block = new nodes.Block;\n        tag.block.push(this.parseExpr());\n        break;\n    }\n\n    // newline*\n    while ('newline' == this.peek().type) this.advance();\n\n    tag.textOnly = tag.textOnly || ~textOnly.indexOf(tag.name);\n\n    // script special-case\n    if ('script' == tag.name) {\n      var type = tag.getAttribute('type');\n      if (!dot && type && 'text/javascript' != type.replace(/^['\"]|['\"]$/g, '')) {\n        tag.textOnly = false;\n      }\n    }\n\n    // block?\n    if ('indent' == this.peek().type) {\n      if (tag.textOnly) {\n        this.lexer.pipeless = true;\n        tag.block = this.parseTextBlock();\n        this.lexer.pipeless = false;\n      } else {\n        var block = this.block();\n        if (tag.block) {\n          for (var i = 0, len = block.nodes.length; i < len; ++i) {\n            tag.block.push(block.nodes[i]);\n          }\n        } else {\n          tag.block = block;\n        }\n      }\n    }\n    \n    return tag;\n  }\n};\n\n}); // module: parser.js\n\nrequire.register(\"runtime.js\", function(module, exports, require){\n\n/*!\n * Jade - runtime\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Lame Array.isArray() polyfill for now.\n */\n\nif (!Array.isArray) {\n  Array.isArray = function(arr){\n    return '[object Array]' == Object.prototype.toString.call(arr);\n  };\n}\n\n/**\n * Lame Object.keys() polyfill for now.\n */\n\nif (!Object.keys) {\n  Object.keys = function(obj){\n    var arr = [];\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        arr.push(key);\n      }\n    }\n    return arr;\n  }\n}\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    ac = ac.filter(nulls);\n    bc = bc.filter(nulls);\n    a['class'] = ac.concat(bc).join(' ');\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null;\n}\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n * @api private\n */\n\nexports.attrs = function attrs(obj, escaped){\n  var buf = []\n    , terse = obj.terse;\n\n  delete obj.terse;\n  var keys = Object.keys(obj)\n    , len = keys.length;\n\n  if (len) {\n    buf.push('');\n    for (var i = 0; i < len; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('boolean' == typeof val || null == val) {\n        if (val) {\n          terse\n            ? buf.push(key)\n            : buf.push(key + '=\"' + key + '\"');\n        }\n      } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n        buf.push(key + \"='\" + JSON.stringify(val) + \"'\");\n      } else if ('class' == key && Array.isArray(val)) {\n        buf.push(key + '=\"' + exports.escape(val.join(' ')) + '\"');\n      } else if (escaped && escaped[key]) {\n        buf.push(key + '=\"' + exports.escape(val) + '\"');\n      } else {\n        buf.push(key + '=\"' + val + '\"');\n      }\n    }\n  }\n\n  return buf.join(' ');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function escape(html){\n  return String(html)\n    .replace(/&(?!(\\w+|\\#\\d+);)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno){\n  if (!filename) throw err;\n\n  var context = 3\n    , str = require('fs').readFileSync(filename, 'utf8')\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n\n}); // module: runtime.js\n\nrequire.register(\"self-closing.js\", function(module, exports, require){\n\n/*!\n * Jade - self closing tags\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = [\n    'meta'\n  , 'img'\n  , 'link'\n  , 'input'\n  , 'source'\n  , 'area'\n  , 'base'\n  , 'col'\n  , 'br'\n  , 'hr'\n];\n}); // module: self-closing.js\n\nrequire.register(\"utils.js\", function(module, exports, require){\n\n/*!\n * Jade - utils\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Convert interpolation in the given string to JavaScript.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nvar interpolate = exports.interpolate = function(str){\n  return str.replace(/(\\\\)?([#!]){(.*?)}/g, function(str, escape, flag, code){\n    return escape\n      ? str\n      : \"' + \"\n        + ('!' == flag ? '' : 'escape')\n        + \"((interp = \" + code.replace(/\\\\'/g, \"'\")\n        + \") == null ? '' : interp) + '\";\n  });\n};\n\n/**\n * Escape single quotes in `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nvar escape = exports.escape = function(str) {\n  return str.replace(/'/g, \"\\\\'\");\n};\n\n/**\n * Interpolate, and escape the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.text = function(str){\n  return interpolate(escape(str));\n};\n}); // module: utils.js\n\nwindow.jade = require(\"jade\");\n})();\n",
  "node_modules/mocha/node_modules/jade/jade.min.js": "(function(){function require(p){var path=require.resolve(p),mod=require.modules[path];if(!mod)throw new Error('failed to require \"'+p+'\"');return mod.exports||(mod.exports={},mod.call(mod.exports,mod,mod.exports,require.relative(path))),mod.exports}require.modules={},require.resolve=function(path){var orig=path,reg=path+\".js\",index=path+\"/index.js\";return require.modules[reg]&&reg||require.modules[index]&&index||orig},require.register=function(path,fn){require.modules[path]=fn},require.relative=function(parent){return function(p){if(\".\"!=p.charAt(0))return require(p);var path=parent.split(\"/\"),segs=p.split(\"/\");path.pop();for(var i=0;i<segs.length;i++){var seg=segs[i];\"..\"==seg?path.pop():\".\"!=seg&&path.push(seg)}return require(path.join(\"/\"))}},require.register(\"compiler.js\",function(module,exports,require){var nodes=require(\"./nodes\"),filters=require(\"./filters\"),doctypes=require(\"./doctypes\"),selfClosing=require(\"./self-closing\"),runtime=require(\"./runtime\"),utils=require(\"./utils\");Object.keys||(Object.keys=function(obj){var arr=[];for(var key in obj)obj.hasOwnProperty(key)&&arr.push(key);return arr}),String.prototype.trimLeft||(String.prototype.trimLeft=function(){return this.replace(/^\\s+/,\"\")});var Compiler=module.exports=function Compiler(node,options){this.options=options=options||{},this.node=node,this.hasCompiledDoctype=!1,this.hasCompiledTag=!1,this.pp=options.pretty||!1,this.debug=!1!==options.compileDebug,this.indents=0,this.parentIndents=0,options.doctype&&this.setDoctype(options.doctype)};Compiler.prototype={compile:function(){return this.buf=[\"var interp;\"],this.pp&&this.buf.push(\"var __indent = [];\"),this.lastBufferedIdx=-1,this.visit(this.node),this.buf.join(\"\\n\")},setDoctype:function(name){var doctype=doctypes[(name||\"default\").toLowerCase()];doctype=doctype||\"<!DOCTYPE \"+name+\">\",this.doctype=doctype,this.terse=\"5\"==name||\"html\"==name,this.xml=0==this.doctype.indexOf(\"<?xml\")},buffer:function(str,esc){esc&&(str=utils.escape(str)),this.lastBufferedIdx==this.buf.length?(this.lastBuffered+=str,this.buf[this.lastBufferedIdx-1]=\"buf.push('\"+this.lastBuffered+\"');\"):(this.buf.push(\"buf.push('\"+str+\"');\"),this.lastBuffered=str,this.lastBufferedIdx=this.buf.length)},prettyIndent:function(offset,newline){offset=offset||0,newline=newline?\"\\\\n\":\"\",this.buffer(newline+Array(this.indents+offset).join(\"  \")),this.parentIndents&&this.buf.push(\"buf.push.apply(buf, __indent);\")},visit:function(node){var debug=this.debug;debug&&this.buf.push(\"__jade.unshift({ lineno: \"+node.line+\", filename: \"+(node.filename?JSON.stringify(node.filename):\"__jade[0].filename\")+\" });\"),!1===node.debug&&this.debug&&(this.buf.pop(),this.buf.pop()),this.visitNode(node),debug&&this.buf.push(\"__jade.shift();\")},visitNode:function(node){var name=node.constructor.name||node.constructor.toString().match(/function ([^(\\s]+)()/)[1];return this[\"visit\"+name](node)},visitCase:function(node){var _=this.withinCase;this.withinCase=!0,this.buf.push(\"switch (\"+node.expr+\"){\"),this.visit(node.block),this.buf.push(\"}\"),this.withinCase=_},visitWhen:function(node){\"default\"==node.expr?this.buf.push(\"default:\"):this.buf.push(\"case \"+node.expr+\":\"),this.visit(node.block),this.buf.push(\"  break;\")},visitLiteral:function(node){var str=node.str.replace(/\\n/g,\"\\\\\\\\n\");this.buffer(str)},visitBlock:function(block){var len=block.nodes.length,escape=this.escape,pp=this.pp;if(this.parentIndents&&block.mode){pp&&this.buf.push(\"__indent.push('\"+Array(this.indents+1).join(\"  \")+\"');\"),this.buf.push(\"block && block();\"),pp&&this.buf.push(\"__indent.pop();\");return}pp&&len>1&&!escape&&block.nodes[0].isText&&block.nodes[1].isText&&this.prettyIndent(1,!0);for(var i=0;i<len;++i)pp&&i>0&&!escape&&block.nodes[i].isText&&block.nodes[i-1].isText&&this.prettyIndent(1,!1),this.visit(block.nodes[i]),block.nodes[i+1]&&block.nodes[i].isText&&block.nodes[i+1].isText&&this.buffer(\"\\\\n\")},visitDoctype:function(doctype){doctype&&(doctype.val||!this.doctype)&&this.setDoctype(doctype.val||\"default\"),this.doctype&&this.buffer(this.doctype),this.hasCompiledDoctype=!0},visitMixin:function(mixin){var name=mixin.name.replace(/-/g,\"_\")+\"_mixin\",args=mixin.args||\"\",block=mixin.block,attrs=mixin.attrs,pp=this.pp;if(mixin.call){pp&&this.buf.push(\"__indent.push('\"+Array(this.indents+1).join(\"  \")+\"');\");if(block||attrs.length){this.buf.push(name+\".call({\");if(block){this.buf.push(\"block: function(){\"),this.parentIndents++;var _indents=this.indents;this.indents=0,this.visit(mixin.block),this.indents=_indents,this.parentIndents--,attrs.length?this.buf.push(\"},\"):this.buf.push(\"}\")}if(attrs.length){var val=this.attrs(attrs);val.inherits?this.buf.push(\"attributes: merge({\"+val.buf+\"}, attributes), escaped: merge(\"+val.escaped+\", escaped, true)\"):this.buf.push(\"attributes: {\"+val.buf+\"}, escaped: \"+val.escaped)}args?this.buf.push(\"}, \"+args+\");\"):this.buf.push(\"});\")}else this.buf.push(name+\"(\"+args+\");\");pp&&this.buf.push(\"__indent.pop();\")}else this.buf.push(\"var \"+name+\" = function(\"+args+\"){\"),this.buf.push(\"var block = this.block, attributes = this.attributes || {}, escaped = this.escaped || {};\"),this.parentIndents++,this.visit(block),this.parentIndents--,this.buf.push(\"};\")},visitTag:function(tag){this.indents++;var name=tag.name,pp=this.pp;tag.buffer&&(name=\"' + (\"+name+\") + '\"),this.hasCompiledTag||(!this.hasCompiledDoctype&&\"html\"==name&&this.visitDoctype(),this.hasCompiledTag=!0),pp&&!tag.isInline()&&this.prettyIndent(0,!0),(~selfClosing.indexOf(name)||tag.selfClosing)&&!this.xml?(this.buffer(\"<\"+name),this.visitAttributes(tag.attrs),this.terse?this.buffer(\">\"):this.buffer(\"/>\")):(tag.attrs.length?(this.buffer(\"<\"+name),tag.attrs.length&&this.visitAttributes(tag.attrs),this.buffer(\">\")):this.buffer(\"<\"+name+\">\"),tag.code&&this.visitCode(tag.code),this.escape=\"pre\"==tag.name,this.visit(tag.block),pp&&!tag.isInline()&&\"pre\"!=tag.name&&!tag.canInline()&&this.prettyIndent(0,!0),this.buffer(\"</\"+name+\">\")),this.indents--},visitFilter:function(filter){var fn=filters[filter.name];if(!fn)throw filter.isASTFilter?new Error('unknown ast filter \"'+filter.name+':\"'):new Error('unknown filter \":'+filter.name+'\"');if(filter.isASTFilter)this.buf.push(fn(filter.block,this,filter.attrs));else{var text=filter.block.nodes.map(function(node){return node.val}).join(\"\\n\");filter.attrs=filter.attrs||{},filter.attrs.filename=this.options.filename,this.buffer(utils.text(fn(text,filter.attrs)))}},visitText:function(text){text=utils.text(text.val.replace(/\\\\/g,\"\\\\\\\\\")),this.escape&&(text=escape(text)),this.buffer(text)},visitComment:function(comment){if(!comment.buffer)return;this.pp&&this.prettyIndent(1,!0),this.buffer(\"<!--\"+utils.escape(comment.val)+\"-->\")},visitBlockComment:function(comment){if(!comment.buffer)return;0==comment.val.trim().indexOf(\"if\")?(this.buffer(\"<!--[\"+comment.val.trim()+\"]>\"),this.visit(comment.block),this.buffer(\"<![endif]-->\")):(this.buffer(\"<!--\"+comment.val),this.visit(comment.block),this.buffer(\"-->\"))},visitCode:function(code){if(code.buffer){var val=code.val.trimLeft();this.buf.push(\"var __val__ = \"+val),val='null == __val__ ? \"\" : __val__',code.escape&&(val=\"escape(\"+val+\")\"),this.buf.push(\"buf.push(\"+val+\");\")}else this.buf.push(code.val);code.block&&(code.buffer||this.buf.push(\"{\"),this.visit(code.block),code.buffer||this.buf.push(\"}\"))},visitEach:function(each){this.buf.push(\"// iterate \"+each.obj+\"\\n\"+\";(function(){\\n\"+\"  if ('number' == typeof \"+each.obj+\".length) {\\n\"+\"    for (var \"+each.key+\" = 0, $$l = \"+each.obj+\".length; \"+each.key+\" < $$l; \"+each.key+\"++) {\\n\"+\"      var \"+each.val+\" = \"+each.obj+\"[\"+each.key+\"];\\n\"),this.visit(each.block),this.buf.push(\"    }\\n  } else {\\n    for (var \"+each.key+\" in \"+each.obj+\") {\\n\"+\"      if (\"+each.obj+\".hasOwnProperty(\"+each.key+\")){\"+\"      var \"+each.val+\" = \"+each.obj+\"[\"+each.key+\"];\\n\"),this.visit(each.block),this.buf.push(\"      }\\n\"),this.buf.push(\"   }\\n  }\\n}).call(this);\\n\")},visitAttributes:function(attrs){var val=this.attrs(attrs);val.inherits?this.buf.push(\"buf.push(attrs(merge({ \"+val.buf+\" }, attributes), merge(\"+val.escaped+\", escaped, true)));\"):val.constant?(eval(\"var buf={\"+val.buf+\"};\"),this.buffer(runtime.attrs(buf,JSON.parse(val.escaped)),!0)):this.buf.push(\"buf.push(attrs({ \"+val.buf+\" }, \"+val.escaped+\"));\")},attrs:function(attrs){var buf=[],classes=[],escaped={},constant=attrs.every(function(attr){return isConstant(attr.val)}),inherits=!1;return this.terse&&buf.push(\"terse: true\"),attrs.forEach(function(attr){if(attr.name==\"attributes\")return inherits=!0;escaped[attr.name]=attr.escaped;if(attr.name==\"class\")classes.push(\"(\"+attr.val+\")\");else{var pair=\"'\"+attr.name+\"':(\"+attr.val+\")\";buf.push(pair)}}),classes.length&&(classes=classes.join(\" + ' ' + \"),buf.push(\"class: \"+classes)),{buf:buf.join(\", \").replace(\"class:\",'\"class\":'),escaped:JSON.stringify(escaped),inherits:inherits,constant:constant}}};function isConstant(val){if(/^ *(\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"|'([^'\\\\]*(\\\\.[^'\\\\]*)*)'|true|false|null|undefined) *$/i.test(val))return!0;if(!isNaN(Number(val)))return!0;var matches;return(matches=/^ *\\[(.*)\\] *$/.exec(val))?matches[1].split(\",\").every(isConstant):!1}function escape(html){return String(html).replace(/&(?!\\w+;)/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\").replace(/\"/g,\"&quot;\")}}),require.register(\"doctypes.js\",function(module,exports,require){module.exports={5:\"<!DOCTYPE html>\",\"default\":\"<!DOCTYPE html>\",xml:'<?xml version=\"1.0\" encoding=\"utf-8\" ?>',transitional:'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',strict:'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">',frameset:'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">',1.1:'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">',basic:'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">',mobile:'<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">'}}),require.register(\"filters.js\",function(module,exports,require){module.exports={cdata:function(str){return\"<![CDATA[\\\\n\"+str+\"\\\\n]]>\"},sass:function(str){str=str.replace(/\\\\n/g,\"\\n\");var sass=require(\"sass\").render(str).replace(/\\n/g,\"\\\\n\");return'<style type=\"text/css\">'+sass+\"</style>\"},stylus:function(str,options){var ret;str=str.replace(/\\\\n/g,\"\\n\");var stylus=require(\"stylus\");return stylus(str,options).render(function(err,css){if(err)throw err;ret=css.replace(/\\n/g,\"\\\\n\")}),'<style type=\"text/css\">'+ret+\"</style>\"},less:function(str){var ret;return str=str.replace(/\\\\n/g,\"\\n\"),require(\"less\").render(str,function(err,css){if(err)throw err;ret='<style type=\"text/css\">'+css.replace(/\\n/g,\"\\\\n\")+\"</style>\"}),ret},markdown:function(str){var md;try{md=require(\"markdown\")}catch(err){try{md=require(\"discount\")}catch(err){try{md=require(\"markdown-js\")}catch(err){try{md=require(\"marked\")}catch(err){throw new Error(\"Cannot find markdown library, install markdown, discount, or marked.\")}}}}return str=str.replace(/\\\\n/g,\"\\n\"),md.parse(str).replace(/\\n/g,\"\\\\n\").replace(/'/g,\"&#39;\")},coffeescript:function(str){str=str.replace(/\\\\n/g,\"\\n\");var js=require(\"coffee-script\").compile(str).replace(/\\\\/g,\"\\\\\\\\\").replace(/\\n/g,\"\\\\n\");return'<script type=\"text/javascript\">\\\\n'+js+\"</script>\"}}}),require.register(\"inline-tags.js\",function(module,exports,require){module.exports=[\"a\",\"abbr\",\"acronym\",\"b\",\"br\",\"code\",\"em\",\"font\",\"i\",\"img\",\"ins\",\"kbd\",\"map\",\"samp\",\"small\",\"span\",\"strong\",\"sub\",\"sup\"]}),require.register(\"jade.js\",function(module,exports,require){var Parser=require(\"./parser\"),Lexer=require(\"./lexer\"),Compiler=require(\"./compiler\"),runtime=require(\"./runtime\");exports.version=\"0.26.1\",exports.selfClosing=require(\"./self-closing\"),exports.doctypes=require(\"./doctypes\"),exports.filters=require(\"./filters\"),exports.utils=require(\"./utils\"),exports.Compiler=Compiler,exports.Parser=Parser,exports.Lexer=Lexer,exports.nodes=require(\"./nodes\"),exports.runtime=runtime,exports.cache={};function parse(str,options){try{var parser=new Parser(str,options.filename,options),compiler=new(options.compiler||Compiler)(parser.parse(),options),js=compiler.compile();return options.debug&&console.error(\"\\nCompiled Function:\\n\\n\u001b[90m%s\u001b[0m\",js.replace(/^/gm,\"  \")),\"var buf = [];\\n\"+(options.self?\"var self = locals || {};\\n\"+js:\"with (locals || {}) {\\n\"+js+\"\\n}\\n\")+'return buf.join(\"\");'}catch(err){parser=parser.context(),runtime.rethrow(err,parser.filename,parser.lexer.lineno)}}exports.compile=function(str,options){var options=options||{},client=options.client,filename=options.filename?JSON.stringify(options.filename):\"undefined\",fn;return options.compileDebug!==!1?fn=[\"var __jade = [{ lineno: 1, filename: \"+filename+\" }];\",\"try {\",parse(String(str),options),\"} catch (err) {\",\"  rethrow(err, __jade[0].filename, __jade[0].lineno);\",\"}\"].join(\"\\n\"):fn=parse(String(str),options),client&&(fn=\"attrs = attrs || jade.attrs; escape = escape || jade.escape; rethrow = rethrow || jade.rethrow; merge = merge || jade.merge;\\n\"+fn),fn=new Function(\"locals, attrs, escape, rethrow, merge\",fn),client?fn:function(locals){return fn(locals,runtime.attrs,runtime.escape,runtime.rethrow,runtime.merge)}},exports.render=function(str,options,fn){\"function\"==typeof options&&(fn=options,options={});if(options.cache&&!options.filename)return fn(new Error('the \"filename\" option is required for caching'));try{var path=options.filename,tmpl=options.cache?exports.cache[path]||(exports.cache[path]=exports.compile(str,options)):exports.compile(str,options);fn(null,tmpl(options))}catch(err){fn(err)}},exports.renderFile=function(path,options,fn){var key=path+\":string\";\"function\"==typeof options&&(fn=options,options={});try{options.filename=path;var str=options.cache?exports.cache[key]||(exports.cache[key]=fs.readFileSync(path,\"utf8\")):fs.readFileSync(path,\"utf8\");exports.render(str,options,fn)}catch(err){fn(err)}},exports.__express=exports.renderFile}),require.register(\"lexer.js\",function(module,exports,require){var Lexer=module.exports=function Lexer(str,options){options=options||{},this.input=str.replace(/\\r\\n|\\r/g,\"\\n\"),this.colons=options.colons,this.deferredTokens=[],this.lastIndents=0,this.lineno=1,this.stash=[],this.indentStack=[],this.indentRe=null,this.pipeless=!1};Lexer.prototype={tok:function(type,val){return{type:type,line:this.lineno,val:val}},consume:function(len){this.input=this.input.substr(len)},scan:function(regexp,type){var captures;if(captures=regexp.exec(this.input))return this.consume(captures[0].length),this.tok(type,captures[1])},defer:function(tok){this.deferredTokens.push(tok)},lookahead:function(n){var fetch=n-this.stash.length;while(fetch-->0)this.stash.push(this.next());return this.stash[--n]},indexOfDelimiters:function(start,end){var str=this.input,nstart=0,nend=0,pos=0;for(var i=0,len=str.length;i<len;++i)if(start==str.charAt(i))++nstart;else if(end==str.charAt(i)&&++nend==nstart){pos=i;break}return pos},stashed:function(){return this.stash.length&&this.stash.shift()},deferred:function(){return this.deferredTokens.length&&this.deferredTokens.shift()},eos:function(){if(this.input.length)return;return this.indentStack.length?(this.indentStack.shift(),this.tok(\"outdent\")):this.tok(\"eos\")},blank:function(){var captures;if(captures=/^\\n *\\n/.exec(this.input))return this.consume(captures[0].length-1),this.pipeless?this.tok(\"text\",\"\"):this.next()},comment:function(){var captures;if(captures=/^ *\\/\\/(-)?([^\\n]*)/.exec(this.input)){this.consume(captures[0].length);var tok=this.tok(\"comment\",captures[2]);return tok.buffer=\"-\"!=captures[1],tok}},interpolation:function(){var captures;if(captures=/^#\\{(.*?)\\}/.exec(this.input))return this.consume(captures[0].length),this.tok(\"interpolation\",captures[1])},tag:function(){var captures;if(captures=/^(\\w[-:\\w]*)(\\/?)/.exec(this.input)){this.consume(captures[0].length);var tok,name=captures[1];if(\":\"==name[name.length-1]){name=name.slice(0,-1),tok=this.tok(\"tag\",name),this.defer(this.tok(\":\"));while(\" \"==this.input[0])this.input=this.input.substr(1)}else tok=this.tok(\"tag\",name);return tok.selfClosing=!!captures[2],tok}},filter:function(){return this.scan(/^:(\\w+)/,\"filter\")},doctype:function(){return this.scan(/^(?:!!!|doctype) *([^\\n]+)?/,\"doctype\")},id:function(){return this.scan(/^#([\\w-]+)/,\"id\")},className:function(){return this.scan(/^\\.([\\w-]+)/,\"class\")},text:function(){return this.scan(/^(?:\\| ?| ?)?([^\\n]+)/,\"text\")},\"extends\":function(){return this.scan(/^extends? +([^\\n]+)/,\"extends\")},prepend:function(){var captures;if(captures=/^prepend +([^\\n]+)/.exec(this.input)){this.consume(captures[0].length);var mode=\"prepend\",name=captures[1],tok=this.tok(\"block\",name);return tok.mode=mode,tok}},append:function(){var captures;if(captures=/^append +([^\\n]+)/.exec(this.input)){this.consume(captures[0].length);var mode=\"append\",name=captures[1],tok=this.tok(\"block\",name);return tok.mode=mode,tok}},block:function(){var captures;if(captures=/^block\\b *(?:(prepend|append) +)?([^\\n]*)/.exec(this.input)){this.consume(captures[0].length);var mode=captures[1]||\"replace\",name=captures[2],tok=this.tok(\"block\",name);return tok.mode=mode,tok}},yield:function(){return this.scan(/^yield */,\"yield\")},include:function(){return this.scan(/^include +([^\\n]+)/,\"include\")},\"case\":function(){return this.scan(/^case +([^\\n]+)/,\"case\")},when:function(){return this.scan(/^when +([^:\\n]+)/,\"when\")},\"default\":function(){return this.scan(/^default */,\"default\")},assignment:function(){var captures;if(captures=/^(\\w+) += *([^;\\n]+)( *;? *)/.exec(this.input)){this.consume(captures[0].length);var name=captures[1],val=captures[2];return this.tok(\"code\",\"var \"+name+\" = (\"+val+\");\")}},call:function(){var captures;if(captures=/^\\+([-\\w]+)/.exec(this.input)){this.consume(captures[0].length);var tok=this.tok(\"call\",captures[1]);if(captures=/^ *\\((.*?)\\)/.exec(this.input))/^ *[-\\w]+ *=/.test(captures[1])||(this.consume(captures[0].length),tok.args=captures[1]);return tok}},mixin:function(){var captures;if(captures=/^mixin +([-\\w]+)(?: *\\((.*)\\))?/.exec(this.input)){this.consume(captures[0].length);var tok=this.tok(\"mixin\",captures[1]);return tok.args=captures[2],tok}},conditional:function(){var captures;if(captures=/^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)){this.consume(captures[0].length);var type=captures[1],js=captures[2];switch(type){case\"if\":js=\"if (\"+js+\")\";break;case\"unless\":js=\"if (!(\"+js+\"))\";break;case\"else if\":js=\"else if (\"+js+\")\";break;case\"else\":js=\"else\"}return this.tok(\"code\",js)}},\"while\":function(){var captures;if(captures=/^while +([^\\n]+)/.exec(this.input))return this.consume(captures[0].length),this.tok(\"code\",\"while (\"+captures[1]+\")\")},each:function(){var captures;if(captures=/^(?:- *)?(?:each|for) +(\\w+)(?: *, *(\\w+))? * in *([^\\n]+)/.exec(this.input)){this.consume(captures[0].length);var tok=this.tok(\"each\",captures[1]);return tok.key=captures[2]||\"$index\",tok.code=captures[3],tok}},code:function(){var captures;if(captures=/^(!?=|-)([^\\n]+)/.exec(this.input)){this.consume(captures[0].length);var flags=captures[1];captures[1]=captures[2];var tok=this.tok(\"code\",captures[1]);return tok.escape=flags[0]===\"=\",tok.buffer=flags[0]===\"=\"||flags[1]===\"=\",tok}},attrs:function(){if(\"(\"==this.input.charAt(0)){var index=this.indexOfDelimiters(\"(\",\")\"),str=this.input.substr(1,index-1),tok=this.tok(\"attrs\"),len=str.length,colons=this.colons,states=[\"key\"],escapedAttr,key=\"\",val=\"\",quote,c,p;function state(){return states[states.length-1]}function interpolate(attr){return attr.replace(/#\\{([^}]+)\\}/g,function(_,expr){return quote+\" + (\"+expr+\") + \"+quote})}this.consume(index+1),tok.attrs={},tok.escaped={};function parse(c){var real=c;colons&&\":\"==c&&(c=\"=\");switch(c){case\",\":case\"\\n\":switch(state()){case\"expr\":case\"array\":case\"string\":case\"object\":val+=c;break;default:states.push(\"key\"),val=val.trim(),key=key.trim();if(\"\"==key)return;key=key.replace(/^['\"]|['\"]$/g,\"\").replace(\"!\",\"\"),tok.escaped[key]=escapedAttr,tok.attrs[key]=\"\"==val?!0:interpolate(val),key=val=\"\"}break;case\"=\":switch(state()){case\"key char\":key+=real;break;case\"val\":case\"expr\":case\"array\":case\"string\":case\"object\":val+=real;break;default:escapedAttr=\"!\"!=p,states.push(\"val\")}break;case\"(\":(\"val\"==state()||\"expr\"==state())&&states.push(\"expr\"),val+=c;break;case\")\":(\"expr\"==state()||\"val\"==state())&&states.pop(),val+=c;break;case\"{\":\"val\"==state()&&states.push(\"object\"),val+=c;break;case\"}\":\"object\"==state()&&states.pop(),val+=c;break;case\"[\":\"val\"==state()&&states.push(\"array\"),val+=c;break;case\"]\":\"array\"==state()&&states.pop(),val+=c;break;case'\"':case\"'\":switch(state()){case\"key\":states.push(\"key char\");break;case\"key char\":states.pop();break;case\"string\":c==quote&&states.pop(),val+=c;break;default:states.push(\"string\"),val+=c,quote=c}break;case\"\":break;default:switch(state()){case\"key\":case\"key char\":key+=c;break;default:val+=c}}p=c}for(var i=0;i<len;++i)parse(str.charAt(i));return parse(\",\"),\"/\"==this.input.charAt(0)&&(this.consume(1),tok.selfClosing=!0),tok}},indent:function(){var captures,re;this.indentRe?captures=this.indentRe.exec(this.input):(re=/^\\n(\\t*) */,captures=re.exec(this.input),captures&&!captures[1].length&&(re=/^\\n( *)/,captures=re.exec(this.input)),captures&&captures[1].length&&(this.indentRe=re));if(captures){var tok,indents=captures[1].length;++this.lineno,this.consume(indents+1);if(\" \"==this.input[0]||\"\\t\"==this.input[0])throw new Error(\"Invalid indentation, you can use tabs or spaces but not both\");if(\"\\n\"==this.input[0])return this.tok(\"newline\");if(this.indentStack.length&&indents<this.indentStack[0]){while(this.indentStack.length&&this.indentStack[0]>indents)this.stash.push(this.tok(\"outdent\")),this.indentStack.shift();tok=this.stash.pop()}else indents&&indents!=this.indentStack[0]?(this.indentStack.unshift(indents),tok=this.tok(\"indent\",indents)):tok=this.tok(\"newline\");return tok}},pipelessText:function(){if(this.pipeless){if(\"\\n\"==this.input[0])return;var i=this.input.indexOf(\"\\n\");-1==i&&(i=this.input.length);var str=this.input.substr(0,i);return this.consume(str.length),this.tok(\"text\",str)}},colon:function(){return this.scan(/^: */,\":\")},advance:function(){return this.stashed()||this.next()},next:function(){return this.deferred()||this.blank()||this.eos()||this.pipelessText()||this.yield()||this.doctype()||this.interpolation()||this[\"case\"]()||this.when()||this[\"default\"]()||this[\"extends\"]()||this.append()||this.prepend()||this.block()||this.include()||this.mixin()||this.call()||this.conditional()||this.each()||this[\"while\"]()||this.assignment()||this.tag()||this.filter()||this.code()||this.id()||this.className()||this.attrs()||this.indent()||this.comment()||this.colon()||this.text()}}}),require.register(\"nodes/attrs.js\",function(module,exports,require){var Node=require(\"./node\"),Block=require(\"./block\"),Attrs=module.exports=function Attrs(){this.attrs=[]};Attrs.prototype=new Node,Attrs.prototype.constructor=Attrs,Attrs.prototype.setAttribute=function(name,val,escaped){return this.attrs.push({name:name,val:val,escaped:escaped}),this},Attrs.prototype.removeAttribute=function(name){for(var i=0,len=this.attrs.length;i<len;++i)this.attrs[i]&&this.attrs[i].name==name&&delete this.attrs[i]},Attrs.prototype.getAttribute=function(name){for(var i=0,len=this.attrs.length;i<len;++i)if(this.attrs[i]&&this.attrs[i].name==name)return this.attrs[i].val}}),require.register(\"nodes/block-comment.js\",function(module,exports,require){var Node=require(\"./node\"),BlockComment=module.exports=function BlockComment(val,block,buffer){this.block=block,this.val=val,this.buffer=buffer};BlockComment.prototype=new Node,BlockComment.prototype.constructor=BlockComment}),require.register(\"nodes/block.js\",function(module,exports,require){var Node=require(\"./node\"),Block=module.exports=function Block(node){this.nodes=[],node&&this.push(node)};Block.prototype=new Node,Block.prototype.constructor=Block,Block.prototype.isBlock=!0,Block.prototype.replace=function(other){other.nodes=this.nodes},Block.prototype.push=function(node){return this.nodes.push(node)},Block.prototype.isEmpty=function(){return 0==this.nodes.length},Block.prototype.unshift=function(node){return this.nodes.unshift(node)},Block.prototype.includeBlock=function(){var ret=this,node;for(var i=0,len=this.nodes.length;i<len;++i){node=this.nodes[i];if(node.yield)return node;if(node.textOnly)continue;node.includeBlock?ret=node.includeBlock():node.block&&!node.block.isEmpty()&&(ret=node.block.includeBlock())}return ret},Block.prototype.clone=function(){var clone=new Block;for(var i=0,len=this.nodes.length;i<len;++i)clone.push(this.nodes[i].clone());return clone}}),require.register(\"nodes/case.js\",function(module,exports,require){var Node=require(\"./node\"),Case=exports=module.exports=function Case(expr,block){this.expr=expr,this.block=block};Case.prototype=new Node,Case.prototype.constructor=Case;var When=exports.When=function When(expr,block){this.expr=expr,this.block=block,this.debug=!1};When.prototype=new Node,When.prototype.constructor=When}),require.register(\"nodes/code.js\",function(module,exports,require){var Node=require(\"./node\"),Code=module.exports=function Code(val,buffer,escape){this.val=val,this.buffer=buffer,this.escape=escape,val.match(/^ *else/)&&(this.debug=!1)};Code.prototype=new Node,Code.prototype.constructor=Code}),require.register(\"nodes/comment.js\",function(module,exports,require){var Node=require(\"./node\"),Comment=module.exports=function Comment(val,buffer){this.val=val,this.buffer=buffer};Comment.prototype=new Node,Comment.prototype.constructor=Comment}),require.register(\"nodes/doctype.js\",function(module,exports,require){var Node=require(\"./node\"),Doctype=module.exports=function Doctype(val){this.val=val};Doctype.prototype=new Node,Doctype.prototype.constructor=Doctype}),require.register(\"nodes/each.js\",function(module,exports,require){var Node=require(\"./node\"),Each=module.exports=function Each(obj,val,key,block){this.obj=obj,this.val=val,this.key=key,this.block=block};Each.prototype=new Node,Each.prototype.constructor=Each}),require.register(\"nodes/filter.js\",function(module,exports,require){var Node=require(\"./node\"),Block=require(\"./block\"),Filter=module.exports=function Filter(name,block,attrs){this.name=name,this.block=block,this.attrs=attrs,this.isASTFilter=!block.nodes.every(function(node){return node.isText})};Filter.prototype=new Node,Filter.prototype.constructor=Filter}),require.register(\"nodes/index.js\",function(module,exports,require){exports.Node=require(\"./node\"),exports.Tag=require(\"./tag\"),exports.Code=require(\"./code\"),exports.Each=require(\"./each\"),exports.Case=require(\"./case\"),exports.Text=require(\"./text\"),exports.Block=require(\"./block\"),exports.Mixin=require(\"./mixin\"),exports.Filter=require(\"./filter\"),exports.Comment=require(\"./comment\"),exports.Literal=require(\"./literal\"),exports.BlockComment=require(\"./block-comment\"),exports.Doctype=require(\"./doctype\")}),require.register(\"nodes/literal.js\",function(module,exports,require){var Node=require(\"./node\"),Literal=module.exports=function Literal(str){this.str=str.replace(/\\\\/g,\"\\\\\\\\\").replace(/\\n|\\r\\n/g,\"\\\\n\").replace(/'/g,\"\\\\'\")};Literal.prototype=new Node,Literal.prototype.constructor=Literal}),require.register(\"nodes/mixin.js\",function(module,exports,require){var Attrs=require(\"./attrs\"),Mixin=module.exports=function Mixin(name,args,block,call){this.name=name,this.args=args,this.block=block,this.attrs=[],this.call=call};Mixin.prototype=new Attrs,Mixin.prototype.constructor=Mixin}),require.register(\"nodes/node.js\",function(module,exports,require){var Node=module.exports=function Node(){};Node.prototype.clone=function(){return this}}),require.register(\"nodes/tag.js\",function(module,exports,require){var Attrs=require(\"./attrs\"),Block=require(\"./block\"),inlineTags=require(\"../inline-tags\"),Tag=module.exports=function Tag(name,block){this.name=name,this.attrs=[],this.block=block||new Block};Tag.prototype=new Attrs,Tag.prototype.constructor=Tag,Tag.prototype.clone=function(){var clone=new Tag(this.name,this.block.clone());return clone.line=this.line,clone.attrs=this.attrs,clone.textOnly=this.textOnly,clone},Tag.prototype.isInline=function(){return~inlineTags.indexOf(this.name)},Tag.prototype.canInline=function(){var nodes=this.block.nodes;function isInline(node){return node.isBlock?node.nodes.every(isInline):node.isText||node.isInline&&node.isInline()}if(!nodes.length)return!0;if(1==nodes.length)return isInline(nodes[0]);if(this.block.nodes.every(isInline)){for(var i=1,len=nodes.length;i<len;++i)if(nodes[i-1].isText&&nodes[i].isText)return!1;return!0}return!1}}),require.register(\"nodes/text.js\",function(module,exports,require){var Node=require(\"./node\"),Text=module.exports=function Text(line){this.val=\"\",\"string\"==typeof line&&(this.val=line)};Text.prototype=new Node,Text.prototype.constructor=Text,Text.prototype.isText=!0}),require.register(\"parser.js\",function(module,exports,require){var Lexer=require(\"./lexer\"),nodes=require(\"./nodes\"),Parser=exports=module.exports=function Parser(str,filename,options){this.input=str,this.lexer=new Lexer(str,options),this.filename=filename,this.blocks={},this.mixins={},this.options=options,this.contexts=[this]},textOnly=exports.textOnly=[\"script\",\"style\"];Parser.prototype={context:function(parser){if(!parser)return this.contexts.pop();this.contexts.push(parser)},advance:function(){return this.lexer.advance()},skip:function(n){while(n--)this.advance()},peek:function(){return this.lookahead(1)},line:function(){return this.lexer.lineno},lookahead:function(n){return this.lexer.lookahead(n)},parse:function(){var block=new nodes.Block,parser;block.line=this.line();while(\"eos\"!=this.peek().type)\"newline\"==this.peek().type?this.advance():block.push(this.parseExpr());if(parser=this.extending){this.context(parser);var ast=parser.parse();this.context();for(var name in this.mixins)ast.unshift(this.mixins[name]);return ast}return block},expect:function(type){if(this.peek().type===type)return this.advance();throw new Error('expected \"'+type+'\", but got \"'+this.peek().type+'\"')},accept:function(type){if(this.peek().type===type)return this.advance()},parseExpr:function(){switch(this.peek().type){case\"tag\":return this.parseTag();case\"mixin\":return this.parseMixin();case\"block\":return this.parseBlock();case\"case\":return this.parseCase();case\"when\":return this.parseWhen();case\"default\":return this.parseDefault();case\"extends\":return this.parseExtends();case\"include\":return this.parseInclude();case\"doctype\":return this.parseDoctype();case\"filter\":return this.parseFilter();case\"comment\":return this.parseComment();case\"text\":return this.parseText();case\"each\":return this.parseEach();case\"code\":return this.parseCode();case\"call\":return this.parseCall();case\"interpolation\":return this.parseInterpolation();case\"yield\":this.advance();var block=new nodes.Block;return block.yield=!0,block;case\"id\":case\"class\":var tok=this.advance();return this.lexer.defer(this.lexer.tok(\"tag\",\"div\")),this.lexer.defer(tok),this.parseExpr();default:throw new Error('unexpected token \"'+this.peek().type+'\"')}},parseText:function(){var tok=this.expect(\"text\"),node=new nodes.Text(tok.val);return node.line=this.line(),node},parseBlockExpansion:function(){return\":\"==this.peek().type?(this.advance(),new nodes.Block(this.parseExpr())):this.block()},parseCase:function(){var val=this.expect(\"case\").val,node=new nodes.Case(val);return node.line=this.line(),node.block=this.block(),node},parseWhen:function(){var val=this.expect(\"when\").val;return new nodes.Case.When(val,this.parseBlockExpansion())},parseDefault:function(){return this.expect(\"default\"),new nodes.Case.When(\"default\",this.parseBlockExpansion())},parseCode:function(){var tok=this.expect(\"code\"),node=new nodes.Code(tok.val,tok.buffer,tok.escape),block,i=1;node.line=this.line();while(this.lookahead(i)&&\"newline\"==this.lookahead(i).type)++i;return block=\"indent\"==this.lookahead(i).type,block&&(this.skip(i-1),node.block=this.block()),node},parseComment:function(){var tok=this.expect(\"comment\"),node;return\"indent\"==this.peek().type?node=new nodes.BlockComment(tok.val,this.block(),tok.buffer):node=new nodes.Comment(tok.val,tok.buffer),node.line=this.line(),node},parseDoctype:function(){var tok=this.expect(\"doctype\"),node=new nodes.Doctype(tok.val);return node.line=this.line(),node},parseFilter:function(){var block,tok=this.expect(\"filter\"),attrs=this.accept(\"attrs\");this.lexer.pipeless=!0,block=this.parseTextBlock(),this.lexer.pipeless=!1;var node=new nodes.Filter(tok.val,block,attrs&&attrs.attrs);return node\n.line=this.line(),node},parseASTFilter:function(){var block,tok=this.expect(\"tag\"),attrs=this.accept(\"attrs\");this.expect(\":\"),block=this.block();var node=new nodes.Filter(tok.val,block,attrs&&attrs.attrs);return node.line=this.line(),node},parseEach:function(){var tok=this.expect(\"each\"),node=new nodes.Each(tok.code,tok.val,tok.key);return node.line=this.line(),node.block=this.block(),node},parseExtends:function(){var path=require(\"path\"),fs=require(\"fs\"),dirname=path.dirname,basename=path.basename,join=path.join;if(!this.filename)throw new Error('the \"filename\" option is required to extend templates');var path=this.expect(\"extends\").val.trim(),dir=dirname(this.filename),path=join(dir,path+\".jade\"),str=fs.readFileSync(path,\"utf8\"),parser=new Parser(str,path,this.options);return parser.blocks=this.blocks,parser.contexts=this.contexts,this.extending=parser,new nodes.Literal(\"\")},parseBlock:function(){var block=this.expect(\"block\"),mode=block.mode,name=block.val.trim();block=\"indent\"==this.peek().type?this.block():new nodes.Block(new nodes.Literal(\"\"));var prev=this.blocks[name];if(prev)switch(prev.mode){case\"append\":block.nodes=block.nodes.concat(prev.nodes),prev=block;break;case\"prepend\":block.nodes=prev.nodes.concat(block.nodes),prev=block}return block.mode=mode,this.blocks[name]=prev||block},parseInclude:function(){var path=require(\"path\"),fs=require(\"fs\"),dirname=path.dirname,basename=path.basename,join=path.join,path=this.expect(\"include\").val.trim(),dir=dirname(this.filename);if(!this.filename)throw new Error('the \"filename\" option is required to use includes');~basename(path).indexOf(\".\")||(path+=\".jade\");if(\".jade\"!=path.substr(-5)){var path=join(dir,path),str=fs.readFileSync(path,\"utf8\");return new nodes.Literal(str)}var path=join(dir,path),str=fs.readFileSync(path,\"utf8\"),parser=new Parser(str,path,this.options);parser.blocks=this.blocks,parser.mixins=this.mixins,this.context(parser);var ast=parser.parse();return this.context(),ast.filename=path,\"indent\"==this.peek().type&&ast.includeBlock().push(this.block()),ast},parseCall:function(){var tok=this.expect(\"call\"),name=tok.val,args=tok.args,mixin=new nodes.Mixin(name,args,new nodes.Block,!0);return this.tag(mixin),mixin.block.isEmpty()&&(mixin.block=null),mixin},parseMixin:function(){var tok=this.expect(\"mixin\"),name=tok.val,args=tok.args,mixin;return\"indent\"==this.peek().type?(mixin=new nodes.Mixin(name,args,this.block(),!1),this.mixins[name]=mixin,mixin):new nodes.Mixin(name,args,null,!0)},parseTextBlock:function(){var block=new nodes.Block;block.line=this.line();var spaces=this.expect(\"indent\").val;null==this._spaces&&(this._spaces=spaces);var indent=Array(spaces-this._spaces+1).join(\" \");while(\"outdent\"!=this.peek().type)switch(this.peek().type){case\"newline\":this.advance();break;case\"indent\":this.parseTextBlock().nodes.forEach(function(node){block.push(node)});break;default:var text=new nodes.Text(indent+this.advance().val);text.line=this.line(),block.push(text)}return spaces==this._spaces&&(this._spaces=null),this.expect(\"outdent\"),block},block:function(){var block=new nodes.Block;block.line=this.line(),this.expect(\"indent\");while(\"outdent\"!=this.peek().type)\"newline\"==this.peek().type?this.advance():block.push(this.parseExpr());return this.expect(\"outdent\"),block},parseInterpolation:function(){var tok=this.advance(),tag=new nodes.Tag(tok.val);return tag.buffer=!0,this.tag(tag)},parseTag:function(){var i=2;\"attrs\"==this.lookahead(i).type&&++i;if(\":\"==this.lookahead(i).type&&\"indent\"==this.lookahead(++i).type)return this.parseASTFilter();var tok=this.advance(),tag=new nodes.Tag(tok.val);return tag.selfClosing=tok.selfClosing,this.tag(tag)},tag:function(tag){var dot;tag.line=this.line();out:for(;;)switch(this.peek().type){case\"id\":case\"class\":var tok=this.advance();tag.setAttribute(tok.type,\"'\"+tok.val+\"'\");continue;case\"attrs\":var tok=this.advance(),obj=tok.attrs,escaped=tok.escaped,names=Object.keys(obj);tok.selfClosing&&(tag.selfClosing=!0);for(var i=0,len=names.length;i<len;++i){var name=names[i],val=obj[name];tag.setAttribute(name,val,escaped[name])}continue;default:break out}\".\"==this.peek().val&&(dot=tag.textOnly=!0,this.advance());switch(this.peek().type){case\"text\":tag.block.push(this.parseText());break;case\"code\":tag.code=this.parseCode();break;case\":\":this.advance(),tag.block=new nodes.Block,tag.block.push(this.parseExpr())}while(\"newline\"==this.peek().type)this.advance();tag.textOnly=tag.textOnly||~textOnly.indexOf(tag.name);if(\"script\"==tag.name){var type=tag.getAttribute(\"type\");!dot&&type&&\"text/javascript\"!=type.replace(/^['\"]|['\"]$/g,\"\")&&(tag.textOnly=!1)}if(\"indent\"==this.peek().type)if(tag.textOnly)this.lexer.pipeless=!0,tag.block=this.parseTextBlock(),this.lexer.pipeless=!1;else{var block=this.block();if(tag.block)for(var i=0,len=block.nodes.length;i<len;++i)tag.block.push(block.nodes[i]);else tag.block=block}return tag}}}),require.register(\"runtime.js\",function(module,exports,require){Array.isArray||(Array.isArray=function(arr){return\"[object Array]\"==Object.prototype.toString.call(arr)}),Object.keys||(Object.keys=function(obj){var arr=[];for(var key in obj)obj.hasOwnProperty(key)&&arr.push(key);return arr}),exports.merge=function merge(a,b){var ac=a[\"class\"],bc=b[\"class\"];if(ac||bc)ac=ac||[],bc=bc||[],Array.isArray(ac)||(ac=[ac]),Array.isArray(bc)||(bc=[bc]),ac=ac.filter(nulls),bc=bc.filter(nulls),a[\"class\"]=ac.concat(bc).join(\" \");for(var key in b)key!=\"class\"&&(a[key]=b[key]);return a};function nulls(val){return val!=null}exports.attrs=function attrs(obj,escaped){var buf=[],terse=obj.terse;delete obj.terse;var keys=Object.keys(obj),len=keys.length;if(len){buf.push(\"\");for(var i=0;i<len;++i){var key=keys[i],val=obj[key];\"boolean\"==typeof val||null==val?val&&(terse?buf.push(key):buf.push(key+'=\"'+key+'\"')):0==key.indexOf(\"data\")&&\"string\"!=typeof val?buf.push(key+\"='\"+JSON.stringify(val)+\"'\"):\"class\"==key&&Array.isArray(val)?buf.push(key+'=\"'+exports.escape(val.join(\" \"))+'\"'):escaped&&escaped[key]?buf.push(key+'=\"'+exports.escape(val)+'\"'):buf.push(key+'=\"'+val+'\"')}}return buf.join(\" \")},exports.escape=function escape(html){return String(html).replace(/&(?!(\\w+|\\#\\d+);)/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\").replace(/\"/g,\"&quot;\")},exports.rethrow=function rethrow(err,filename,lineno){if(!filename)throw err;var context=3,str=require(\"fs\").readFileSync(filename,\"utf8\"),lines=str.split(\"\\n\"),start=Math.max(lineno-context,0),end=Math.min(lines.length,lineno+context),context=lines.slice(start,end).map(function(line,i){var curr=i+start+1;return(curr==lineno?\"  > \":\"    \")+curr+\"| \"+line}).join(\"\\n\");throw err.path=filename,err.message=(filename||\"Jade\")+\":\"+lineno+\"\\n\"+context+\"\\n\\n\"+err.message,err}}),require.register(\"self-closing.js\",function(module,exports,require){module.exports=[\"meta\",\"img\",\"link\",\"input\",\"source\",\"area\",\"base\",\"col\",\"br\",\"hr\"]}),require.register(\"utils.js\",function(module,exports,require){var interpolate=exports.interpolate=function(str){return str.replace(/(\\\\)?([#!]){(.*?)}/g,function(str,escape,flag,code){return escape?str:\"' + \"+(\"!\"==flag?\"\":\"escape\")+\"((interp = \"+code.replace(/\\\\'/g,\"'\")+\") == null ? '' : interp) + '\"})},escape=exports.escape=function(str){return str.replace(/'/g,\"\\\\'\")};exports.text=function(str){return interpolate(escape(str))}}),window.jade=require(\"jade\")})();",
  "node_modules/mocha/node_modules/jade/lib/compiler.js": "\n/*!\n * Jade - Compiler\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar nodes = require('./nodes')\n  , filters = require('./filters')\n  , doctypes = require('./doctypes')\n  , selfClosing = require('./self-closing')\n  , runtime = require('./runtime')\n  , utils = require('./utils');\n\n// if browser\n//\n// if (!Object.keys) {\n//   Object.keys = function(obj){\n//     var arr = [];\n//     for (var key in obj) {\n//       if (obj.hasOwnProperty(key)) {\n//         arr.push(key);\n//       }\n//     }\n//     return arr;\n//   }\n// }\n//\n// if (!String.prototype.trimLeft) {\n//   String.prototype.trimLeft = function(){\n//     return this.replace(/^\\s+/, '');\n//   }\n// }\n//\n// end\n\n\n/**\n * Initialize `Compiler` with the given `node`.\n *\n * @param {Node} node\n * @param {Object} options\n * @api public\n */\n\nvar Compiler = module.exports = function Compiler(node, options) {\n  this.options = options = options || {};\n  this.node = node;\n  this.hasCompiledDoctype = false;\n  this.hasCompiledTag = false;\n  this.pp = options.pretty || false;\n  this.debug = false !== options.compileDebug;\n  this.indents = 0;\n  this.parentIndents = 0;\n  if (options.doctype) this.setDoctype(options.doctype);\n};\n\n/**\n * Compiler prototype.\n */\n\nCompiler.prototype = {\n\n  /**\n   * Compile parse tree to JavaScript.\n   *\n   * @api public\n   */\n\n  compile: function(){\n    this.buf = ['var interp;'];\n    if (this.pp) this.buf.push(\"var __indent = [];\");\n    this.lastBufferedIdx = -1;\n    this.visit(this.node);\n    return this.buf.join('\\n');\n  },\n\n  /**\n   * Sets the default doctype `name`. Sets terse mode to `true` when\n   * html 5 is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {string} name\n   * @api public\n   */\n\n  setDoctype: function(name){\n    var doctype = doctypes[(name || 'default').toLowerCase()];\n    doctype = doctype || '<!DOCTYPE ' + name + '>';\n    this.doctype = doctype;\n    this.terse = '5' == name || 'html' == name;\n    this.xml = 0 == this.doctype.indexOf('<?xml');\n  },\n\n  /**\n   * Buffer the given `str` optionally escaped.\n   *\n   * @param {String} str\n   * @param {Boolean} esc\n   * @api public\n   */\n\n  buffer: function(str, esc){\n    if (esc) str = utils.escape(str);\n\n    if (this.lastBufferedIdx == this.buf.length) {\n      this.lastBuffered += str;\n      this.buf[this.lastBufferedIdx - 1] = \"buf.push('\" + this.lastBuffered + \"');\"\n    } else {\n      this.buf.push(\"buf.push('\" + str + \"');\");\n      this.lastBuffered = str;\n      this.lastBufferedIdx = this.buf.length;\n    }\n  },\n\n  /**\n   * Buffer an indent based on the current `indent`\n   * property and an additional `offset`.\n   *\n   * @param {Number} offset\n   * @param {Boolean} newline\n   * @api public\n   */\n  \n  prettyIndent: function(offset, newline){\n    offset = offset || 0;\n    newline = newline ? '\\\\n' : '';\n    this.buffer(newline + Array(this.indents + offset).join('  '));\n    if (this.parentIndents)\n      this.buf.push(\"buf.push.apply(buf, __indent);\");\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n\n  visit: function(node){\n    var debug = this.debug;\n\n    if (debug) {\n      this.buf.push('__jade.unshift({ lineno: ' + node.line\n        + ', filename: ' + (node.filename\n          ? JSON.stringify(node.filename)\n          : '__jade[0].filename')\n        + ' });');\n    }\n\n    // Massive hack to fix our context\n    // stack for - else[ if] etc\n    if (false === node.debug && this.debug) {\n      this.buf.pop();\n      this.buf.pop();\n    }\n\n    this.visitNode(node);\n\n    if (debug) this.buf.push('__jade.shift();');\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n\n  visitNode: function(node){\n    var name = node.constructor.name\n      || node.constructor.toString().match(/function ([^(\\s]+)()/)[1];\n    return this['visit' + name](node);\n  },\n\n  /**\n   * Visit case `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitCase: function(node){\n    var _ = this.withinCase;\n    this.withinCase = true;\n    this.buf.push('switch (' + node.expr + '){');\n    this.visit(node.block);\n    this.buf.push('}');\n    this.withinCase = _;\n  },\n\n  /**\n   * Visit when `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitWhen: function(node){\n    if ('default' == node.expr) {\n      this.buf.push('default:');\n    } else {\n      this.buf.push('case ' + node.expr + ':');\n    }\n    this.visit(node.block);\n    this.buf.push('  break;');\n  },\n\n  /**\n   * Visit literal `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitLiteral: function(node){\n    var str = node.str.replace(/\\n/g, '\\\\\\\\n');\n    this.buffer(str);\n  },\n\n  /**\n   * Visit all nodes in `block`.\n   *\n   * @param {Block} block\n   * @api public\n   */\n\n  visitBlock: function(block){\n    var len = block.nodes.length\n      , escape = this.escape\n      , pp = this.pp\n    \n    // Block keyword has a special meaning in mixins\n    if (this.parentIndents && block.mode) {\n      if (pp) this.buf.push(\"__indent.push('\" + Array(this.indents + 1).join('  ') + \"');\")\n      this.buf.push('block && block();');\n      if (pp) this.buf.push(\"__indent.pop();\")\n      return;\n    }\n    \n    // Pretty print multi-line text\n    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)\n      this.prettyIndent(1, true);\n    \n    for (var i = 0; i < len; ++i) {\n      // Pretty print text\n      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)\n        this.prettyIndent(1, false);\n      \n      this.visit(block.nodes[i]);\n      // Multiple text nodes are separated by newlines\n      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)\n        this.buffer('\\\\n');\n    }\n  },\n\n  /**\n   * Visit `doctype`. Sets terse mode to `true` when html 5\n   * is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {Doctype} doctype\n   * @api public\n   */\n\n  visitDoctype: function(doctype){\n    if (doctype && (doctype.val || !this.doctype)) {\n      this.setDoctype(doctype.val || 'default');\n    }\n\n    if (this.doctype) this.buffer(this.doctype);\n    this.hasCompiledDoctype = true;\n  },\n\n  /**\n   * Visit `mixin`, generating a function that\n   * may be called within the template.\n   *\n   * @param {Mixin} mixin\n   * @api public\n   */\n\n  visitMixin: function(mixin){\n    var name = mixin.name.replace(/-/g, '_') + '_mixin'\n      , args = mixin.args || ''\n      , block = mixin.block\n      , attrs = mixin.attrs\n      , pp = this.pp;\n\n    if (mixin.call) {\n      if (pp) this.buf.push(\"__indent.push('\" + Array(this.indents + 1).join('  ') + \"');\")\n      if (block || attrs.length) {\n        \n        this.buf.push(name + '.call({');\n        \n        if (block) {\n          this.buf.push('block: function(){');\n          \n          // Render block with no indents, dynamically added when rendered\n          this.parentIndents++;\n          var _indents = this.indents;\n          this.indents = 0;\n          this.visit(mixin.block);\n          this.indents = _indents;\n          this.parentIndents--;\n          \n          if (attrs.length) {\n            this.buf.push('},');\n          } else {\n            this.buf.push('}');\n          }\n        }\n        \n        if (attrs.length) {\n          var val = this.attrs(attrs);\n          if (val.inherits) {\n            this.buf.push('attributes: merge({' + val.buf\n                + '}, attributes), escaped: merge(' + val.escaped + ', escaped, true)');\n          } else {\n            this.buf.push('attributes: {' + val.buf + '}, escaped: ' + val.escaped);\n          }\n        }\n        \n        if (args) {\n          this.buf.push('}, ' + args + ');');\n        } else {\n          this.buf.push('});');\n        }\n        \n      } else {\n        this.buf.push(name + '(' + args + ');');\n      }\n      if (pp) this.buf.push(\"__indent.pop();\")\n    } else {\n      this.buf.push('var ' + name + ' = function(' + args + '){');\n      this.buf.push('var block = this.block, attributes = this.attributes || {}, escaped = this.escaped || {};');\n      this.parentIndents++;\n      this.visit(block);\n      this.parentIndents--;\n      this.buf.push('};');\n    }\n  },\n\n  /**\n   * Visit `tag` buffering tag markup, generating\n   * attributes, visiting the `tag`'s code and block.\n   *\n   * @param {Tag} tag\n   * @api public\n   */\n\n  visitTag: function(tag){\n    this.indents++;\n    var name = tag.name\n      , pp = this.pp;\n\n    if (tag.buffer) name = \"' + (\" + name + \") + '\";\n\n    if (!this.hasCompiledTag) {\n      if (!this.hasCompiledDoctype && 'html' == name) {\n        this.visitDoctype();\n      }\n      this.hasCompiledTag = true;\n    }\n\n    // pretty print\n    if (pp && !tag.isInline())\n      this.prettyIndent(0, true);\n\n    if ((~selfClosing.indexOf(name) || tag.selfClosing) && !this.xml) {\n      this.buffer('<' + name);\n      this.visitAttributes(tag.attrs);\n      this.terse\n        ? this.buffer('>')\n        : this.buffer('/>');\n    } else {\n      // Optimize attributes buffering\n      if (tag.attrs.length) {\n        this.buffer('<' + name);\n        if (tag.attrs.length) this.visitAttributes(tag.attrs);\n        this.buffer('>');\n      } else {\n        this.buffer('<' + name + '>');\n      }\n      if (tag.code) this.visitCode(tag.code);\n      this.escape = 'pre' == tag.name;\n      this.visit(tag.block);\n\n      // pretty print\n      if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())\n        this.prettyIndent(0, true);\n\n      this.buffer('</' + name + '>');\n    }\n    this.indents--;\n  },\n\n  /**\n   * Visit `filter`, throwing when the filter does not exist.\n   *\n   * @param {Filter} filter\n   * @api public\n   */\n\n  visitFilter: function(filter){\n    var fn = filters[filter.name];\n\n    // unknown filter\n    if (!fn) {\n      if (filter.isASTFilter) {\n        throw new Error('unknown ast filter \"' + filter.name + ':\"');\n      } else {\n        throw new Error('unknown filter \":' + filter.name + '\"');\n      }\n    }\n\n    if (filter.isASTFilter) {\n      this.buf.push(fn(filter.block, this, filter.attrs));\n    } else {\n      var text = filter.block.nodes.map(function(node){ return node.val }).join('\\n');\n      filter.attrs = filter.attrs || {};\n      filter.attrs.filename = this.options.filename;\n      this.buffer(utils.text(fn(text, filter.attrs)));\n    }\n  },\n\n  /**\n   * Visit `text` node.\n   *\n   * @param {Text} text\n   * @api public\n   */\n\n  visitText: function(text){\n    text = utils.text(text.val.replace(/\\\\/g, '\\\\\\\\'));\n    if (this.escape) text = escape(text);\n    this.buffer(text);\n  },\n\n  /**\n   * Visit a `comment`, only buffering when the buffer flag is set.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n\n  visitComment: function(comment){\n    if (!comment.buffer) return;\n    if (this.pp) this.prettyIndent(1, true);\n    this.buffer('<!--' + utils.escape(comment.val) + '-->');\n  },\n\n  /**\n   * Visit a `BlockComment`.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n\n  visitBlockComment: function(comment){\n    if (!comment.buffer) return;\n    if (0 == comment.val.trim().indexOf('if')) {\n      this.buffer('<!--[' + comment.val.trim() + ']>');\n      this.visit(comment.block);\n      this.buffer('<![endif]-->');\n    } else {\n      this.buffer('<!--' + comment.val);\n      this.visit(comment.block);\n      this.buffer('-->');\n    }\n  },\n\n  /**\n   * Visit `code`, respecting buffer / escape flags.\n   * If the code is followed by a block, wrap it in\n   * a self-calling function.\n   *\n   * @param {Code} code\n   * @api public\n   */\n\n  visitCode: function(code){\n    // Wrap code blocks with {}.\n    // we only wrap unbuffered code blocks ATM\n    // since they are usually flow control\n\n    // Buffer code\n    if (code.buffer) {\n      var val = code.val.trimLeft();\n      this.buf.push('var __val__ = ' + val);\n      val = 'null == __val__ ? \"\" : __val__';\n      if (code.escape) val = 'escape(' + val + ')';\n      this.buf.push(\"buf.push(\" + val + \");\");\n    } else {\n      this.buf.push(code.val);\n    }\n\n    // Block support\n    if (code.block) {\n      if (!code.buffer) this.buf.push('{');\n      this.visit(code.block);\n      if (!code.buffer) this.buf.push('}');\n    }\n  },\n\n  /**\n   * Visit `each` block.\n   *\n   * @param {Each} each\n   * @api public\n   */\n\n  visitEach: function(each){\n    this.buf.push(''\n      + '// iterate ' + each.obj + '\\n'\n      + ';(function(){\\n'\n      + '  if (\\'number\\' == typeof ' + each.obj + '.length) {\\n'\n      + '    for (var ' + each.key + ' = 0, $$l = ' + each.obj + '.length; ' + each.key + ' < $$l; ' + each.key + '++) {\\n'\n      + '      var ' + each.val + ' = ' + each.obj + '[' + each.key + '];\\n');\n\n    this.visit(each.block);\n\n    this.buf.push(''\n      + '    }\\n'\n      + '  } else {\\n'\n      + '    for (var ' + each.key + ' in ' + each.obj + ') {\\n'\n      // if browser\n      // + '      if (' + each.obj + '.hasOwnProperty(' + each.key + ')){'\n      // end\n      + '      var ' + each.val + ' = ' + each.obj + '[' + each.key + '];\\n');\n\n    this.visit(each.block);\n\n    // if browser\n    // this.buf.push('      }\\n');\n    // end\n\n    this.buf.push('   }\\n  }\\n}).call(this);\\n');\n  },\n\n  /**\n   * Visit `attrs`.\n   *\n   * @param {Array} attrs\n   * @api public\n   */\n\n  visitAttributes: function(attrs){\n    var val = this.attrs(attrs);\n    if (val.inherits) {\n      this.buf.push(\"buf.push(attrs(merge({ \" + val.buf +\n          \" }, attributes), merge(\" + val.escaped + \", escaped, true)));\");\n    } else if (val.constant) {\n      eval('var buf={' + val.buf + '};');\n      this.buffer(runtime.attrs(buf, JSON.parse(val.escaped)), true);\n    } else {\n      this.buf.push(\"buf.push(attrs({ \" + val.buf + \" }, \" + val.escaped + \"));\");\n    }\n  },\n\n  /**\n   * Compile attributes.\n   */\n\n  attrs: function(attrs){\n    var buf = []\n      , classes = []\n      , escaped = {}\n      , constant = attrs.every(function(attr){ return isConstant(attr.val) })\n      , inherits = false;\n\n    if (this.terse) buf.push('terse: true');\n\n    attrs.forEach(function(attr){\n      if (attr.name == 'attributes') return inherits = true;\n      escaped[attr.name] = attr.escaped;\n      if (attr.name == 'class') {\n        classes.push('(' + attr.val + ')');\n      } else {\n        var pair = \"'\" + attr.name + \"':(\" + attr.val + ')';\n        buf.push(pair);\n      }\n    });\n\n    if (classes.length) {\n      classes = classes.join(\" + ' ' + \");\n      buf.push(\"class: \" + classes);\n    }\n\n    return {\n      buf: buf.join(', ').replace('class:', '\"class\":'),\n      escaped: JSON.stringify(escaped),\n      inherits: inherits,\n      constant: constant\n    };\n  }\n};\n\n/**\n * Check if expression can be evaluated to a constant\n *\n * @param {String} expression\n * @return {Boolean}\n * @api private\n */\n\nfunction isConstant(val){\n  // Check strings/literals\n  if (/^ *(\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"|'([^'\\\\]*(\\\\.[^'\\\\]*)*)'|true|false|null|undefined) *$/i.test(val))\n    return true;\n  \n  // Check numbers\n  if (!isNaN(Number(val)))\n    return true;\n  \n  // Check arrays\n  var matches;\n  if (matches = /^ *\\[(.*)\\] *$/.exec(val))\n    return matches[1].split(',').every(isConstant);\n  \n  return false;\n}\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nfunction escape(html){\n  return String(html)\n    .replace(/&(?!\\w+;)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n}",
  "node_modules/mocha/node_modules/jade/lib/doctypes.js": "\n/*!\n * Jade - doctypes\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = {\n    '5': '<!DOCTYPE html>'\n  , 'default': '<!DOCTYPE html>'\n  , 'xml': '<?xml version=\"1.0\" encoding=\"utf-8\" ?>'\n  , 'transitional': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">'\n  , 'strict': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">'\n  , 'frameset': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">'\n  , '1.1': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">'\n  , 'basic': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">'\n  , 'mobile': '<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">'\n};",
  "node_modules/mocha/node_modules/jade/lib/filters.js": "\n/*!\n * Jade - filters\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = {\n  \n  /**\n   * Wrap text with CDATA block.\n   */\n  \n  cdata: function(str){\n    return '<![CDATA[\\\\n' + str + '\\\\n]]>';\n  },\n  \n  /**\n   * Transform sass to css, wrapped in style tags.\n   */\n  \n  sass: function(str){\n    str = str.replace(/\\\\n/g, '\\n');\n    var sass = require('sass').render(str).replace(/\\n/g, '\\\\n');\n    return '<style type=\"text/css\">' + sass + '</style>'; \n  },\n  \n  /**\n   * Transform stylus to css, wrapped in style tags.\n   */\n  \n  stylus: function(str, options){\n    var ret;\n    str = str.replace(/\\\\n/g, '\\n');\n    var stylus = require('stylus');\n    stylus(str, options).render(function(err, css){\n      if (err) throw err;\n      ret = css.replace(/\\n/g, '\\\\n');\n    });\n    return '<style type=\"text/css\">' + ret + '</style>'; \n  },\n  \n  /**\n   * Transform less to css, wrapped in style tags.\n   */\n  \n  less: function(str){\n    var ret;\n    str = str.replace(/\\\\n/g, '\\n');\n    require('less').render(str, function(err, css){\n      if (err) throw err;\n      ret = '<style type=\"text/css\">' + css.replace(/\\n/g, '\\\\n') + '</style>';  \n    });\n    return ret;\n  },\n  \n  /**\n   * Transform markdown to html.\n   */\n  \n  markdown: function(str){\n    var md;\n\n    // support markdown / discount\n    try {\n      md = require('markdown');\n    } catch (err){\n      try {\n        md = require('discount');\n      } catch (err) {\n        try {\n          md = require('markdown-js');\n        } catch (err) {\n          try {\n            md = require('marked');\n          } catch (err) {\n            throw new\n              Error('Cannot find markdown library, install markdown, discount, or marked.');\n          }\n        }\n      }\n    }\n\n    str = str.replace(/\\\\n/g, '\\n');\n    return md.parse(str).replace(/\\n/g, '\\\\n').replace(/'/g,'&#39;');\n  },\n  \n  /**\n   * Transform coffeescript to javascript.\n   */\n\n  coffeescript: function(str){\n    str = str.replace(/\\\\n/g, '\\n');\n    var js = require('coffee-script').compile(str).replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n');\n    return '<script type=\"text/javascript\">\\\\n' + js + '</script>';\n  }\n};\n",
  "node_modules/mocha/node_modules/jade/lib/inline-tags.js": "\n/*!\n * Jade - inline tags\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = [\n    'a'\n  , 'abbr'\n  , 'acronym'\n  , 'b'\n  , 'br'\n  , 'code'\n  , 'em'\n  , 'font'\n  , 'i'\n  , 'img'\n  , 'ins'\n  , 'kbd'\n  , 'map'\n  , 'samp'\n  , 'small'\n  , 'span'\n  , 'strong'\n  , 'sub'\n  , 'sup'\n];",
  "node_modules/mocha/node_modules/jade/lib/jade.js": "/*!\n * Jade\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Parser = require('./parser')\n  , Lexer = require('./lexer')\n  , Compiler = require('./compiler')\n  , runtime = require('./runtime')\n// if node\n  , fs = require('fs');\n// end\n\n/**\n * Library version.\n */\n\nexports.version = '0.26.3';\n\n/**\n * Expose self closing tags.\n */\n\nexports.selfClosing = require('./self-closing');\n\n/**\n * Default supported doctypes.\n */\n\nexports.doctypes = require('./doctypes');\n\n/**\n * Text filters.\n */\n\nexports.filters = require('./filters');\n\n/**\n * Utilities.\n */\n\nexports.utils = require('./utils');\n\n/**\n * Expose `Compiler`.\n */\n\nexports.Compiler = Compiler;\n\n/**\n * Expose `Parser`.\n */\n\nexports.Parser = Parser;\n\n/**\n * Expose `Lexer`.\n */\n\nexports.Lexer = Lexer;\n\n/**\n * Nodes.\n */\n\nexports.nodes = require('./nodes');\n\n/**\n * Jade runtime helpers.\n */\n\nexports.runtime = runtime;\n\n/**\n * Template function cache.\n */\n\nexports.cache = {};\n\n/**\n * Parse the given `str` of jade and return a function body.\n *\n * @param {String} str\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction parse(str, options){\n  try {\n    // Parse\n    var parser = new Parser(str, options.filename, options);\n\n    // Compile\n    var compiler = new (options.compiler || Compiler)(parser.parse(), options)\n      , js = compiler.compile();\n\n    // Debug compiler\n    if (options.debug) {\n      console.error('\\nCompiled Function:\\n\\n\\033[90m%s\\033[0m', js.replace(/^/gm, '  '));\n    }\n\n    return ''\n      + 'var buf = [];\\n'\n      + (options.self\n        ? 'var self = locals || {};\\n' + js\n        : 'with (locals || {}) {\\n' + js + '\\n}\\n')\n      + 'return buf.join(\"\");';\n  } catch (err) {\n    parser = parser.context();\n    runtime.rethrow(err, parser.filename, parser.lexer.lineno);\n  }\n}\n\n/**\n * Compile a `Function` representation of the given jade `str`.\n *\n * Options:\n *\n *   - `compileDebug` when `false` debugging code is stripped from the compiled template\n *   - `client` when `true` the helper functions `escape()` etc will reference `jade.escape()`\n *      for use with the Jade client-side runtime.js\n *\n * @param {String} str\n * @param {Options} options\n * @return {Function}\n * @api public\n */\n\nexports.compile = function(str, options){\n  var options = options || {}\n    , client = options.client\n    , filename = options.filename\n      ? JSON.stringify(options.filename)\n      : 'undefined'\n    , fn;\n\n  if (options.compileDebug !== false) {\n    fn = [\n        'var __jade = [{ lineno: 1, filename: ' + filename + ' }];'\n      , 'try {'\n      , parse(String(str), options)\n      , '} catch (err) {'\n      , '  rethrow(err, __jade[0].filename, __jade[0].lineno);'\n      , '}'\n    ].join('\\n');\n  } else {\n    fn = parse(String(str), options);\n  }\n\n  if (client) {\n    fn = 'attrs = attrs || jade.attrs; escape = escape || jade.escape; rethrow = rethrow || jade.rethrow; merge = merge || jade.merge;\\n' + fn;\n  }\n\n  fn = new Function('locals, attrs, escape, rethrow, merge', fn);\n\n  if (client) return fn;\n\n  return function(locals){\n    return fn(locals, runtime.attrs, runtime.escape, runtime.rethrow, runtime.merge);\n  };\n};\n\n/**\n * Render the given `str` of jade and invoke\n * the callback `fn(err, str)`.\n *\n * Options:\n *\n *   - `cache` enable template caching\n *   - `filename` filename required for `include` / `extends` and caching\n *\n * @param {String} str\n * @param {Object|Function} options or fn\n * @param {Function} fn\n * @api public\n */\n\nexports.render = function(str, options, fn){\n  // swap args\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  // cache requires .filename\n  if (options.cache && !options.filename) {\n    return fn(new Error('the \"filename\" option is required for caching'));\n  }\n\n  try {\n    var path = options.filename;\n    var tmpl = options.cache\n      ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))\n      : exports.compile(str, options);\n    fn(null, tmpl(options));\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Render a Jade file at the given `path` and callback `fn(err, str)`.\n *\n * @param {String} path\n * @param {Object|Function} options or callback\n * @param {Function} fn\n * @api public\n */\n\nexports.renderFile = function(path, options, fn){\n  var key = path + ':string';\n\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  try {\n    options.filename = path;\n    var str = options.cache\n      ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))\n      : fs.readFileSync(path, 'utf8');\n    exports.render(str, options, fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Express support.\n */\n\nexports.__express = exports.renderFile;\n",
  "node_modules/mocha/node_modules/jade/lib/lexer.js": "\n/*!\n * Jade - Lexer\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Initialize `Lexer` with the given `str`.\n *\n * Options:\n *\n *   - `colons` allow colons for attr delimiters\n *\n * @param {String} str\n * @param {Object} options\n * @api private\n */\n\nvar Lexer = module.exports = function Lexer(str, options) {\n  options = options || {};\n  this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n  this.colons = options.colons;\n  this.deferredTokens = [];\n  this.lastIndents = 0;\n  this.lineno = 1;\n  this.stash = [];\n  this.indentStack = [];\n  this.indentRe = null;\n  this.pipeless = false;\n};\n\n/**\n * Lexer prototype.\n */\n\nLexer.prototype = {\n  \n  /**\n   * Construct a token with the given `type` and `val`.\n   *\n   * @param {String} type\n   * @param {String} val\n   * @return {Object}\n   * @api private\n   */\n  \n  tok: function(type, val){\n    return {\n        type: type\n      , line: this.lineno\n      , val: val\n    }\n  },\n  \n  /**\n   * Consume the given `len` of input.\n   *\n   * @param {Number} len\n   * @api private\n   */\n  \n  consume: function(len){\n    this.input = this.input.substr(len);\n  },\n  \n  /**\n   * Scan for `type` with the given `regexp`.\n   *\n   * @param {String} type\n   * @param {RegExp} regexp\n   * @return {Object}\n   * @api private\n   */\n  \n  scan: function(regexp, type){\n    var captures;\n    if (captures = regexp.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok(type, captures[1]);\n    }\n  },\n  \n  /**\n   * Defer the given `tok`.\n   *\n   * @param {Object} tok\n   * @api private\n   */\n  \n  defer: function(tok){\n    this.deferredTokens.push(tok);\n  },\n  \n  /**\n   * Lookahead `n` tokens.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  \n  lookahead: function(n){\n    var fetch = n - this.stash.length;\n    while (fetch-- > 0) this.stash.push(this.next());\n    return this.stash[--n];\n  },\n  \n  /**\n   * Return the indexOf `start` / `end` delimiters.\n   *\n   * @param {String} start\n   * @param {String} end\n   * @return {Number}\n   * @api private\n   */\n  \n  indexOfDelimiters: function(start, end){\n    var str = this.input\n      , nstart = 0\n      , nend = 0\n      , pos = 0;\n    for (var i = 0, len = str.length; i < len; ++i) {\n      if (start == str.charAt(i)) {\n        ++nstart;\n      } else if (end == str.charAt(i)) {\n        if (++nend == nstart) {\n          pos = i;\n          break;\n        }\n      }\n    }\n    return pos;\n  },\n  \n  /**\n   * Stashed token.\n   */\n  \n  stashed: function() {\n    return this.stash.length\n      && this.stash.shift();\n  },\n  \n  /**\n   * Deferred token.\n   */\n  \n  deferred: function() {\n    return this.deferredTokens.length \n      && this.deferredTokens.shift();\n  },\n  \n  /**\n   * end-of-source.\n   */\n  \n  eos: function() {\n    if (this.input.length) return;\n    if (this.indentStack.length) {\n      this.indentStack.shift();\n      return this.tok('outdent');\n    } else {\n      return this.tok('eos');\n    }\n  },\n\n  /**\n   * Blank line.\n   */\n  \n  blank: function() {\n    var captures;\n    if (captures = /^\\n *\\n/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n      if (this.pipeless) return this.tok('text', '');\n      return this.next();\n    }\n  },\n\n  /**\n   * Comment.\n   */\n  \n  comment: function() {\n    var captures;\n    if (captures = /^ *\\/\\/(-)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('comment', captures[2]);\n      tok.buffer = '-' != captures[1];\n      return tok;\n    }\n  },\n\n  /**\n   * Interpolated tag.\n   */\n\n  interpolation: function() {\n    var captures;\n    if (captures = /^#\\{(.*?)\\}/.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok('interpolation', captures[1]);\n    }\n  },\n\n  /**\n   * Tag.\n   */\n  \n  tag: function() {\n    var captures;\n    if (captures = /^(\\w[-:\\w]*)(\\/?)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok, name = captures[1];\n      if (':' == name[name.length - 1]) {\n        name = name.slice(0, -1);\n        tok = this.tok('tag', name);\n        this.defer(this.tok(':'));\n        while (' ' == this.input[0]) this.input = this.input.substr(1);\n      } else {\n        tok = this.tok('tag', name);\n      }\n      tok.selfClosing = !! captures[2];\n      return tok;\n    }\n  },\n  \n  /**\n   * Filter.\n   */\n  \n  filter: function() {\n    return this.scan(/^:(\\w+)/, 'filter');\n  },\n  \n  /**\n   * Doctype.\n   */\n  \n  doctype: function() {\n    return this.scan(/^(?:!!!|doctype) *([^\\n]+)?/, 'doctype');\n  },\n\n  /**\n   * Id.\n   */\n  \n  id: function() {\n    return this.scan(/^#([\\w-]+)/, 'id');\n  },\n  \n  /**\n   * Class.\n   */\n  \n  className: function() {\n    return this.scan(/^\\.([\\w-]+)/, 'class');\n  },\n  \n  /**\n   * Text.\n   */\n  \n  text: function() {\n    return this.scan(/^(?:\\| ?| ?)?([^\\n]+)/, 'text');\n  },\n\n  /**\n   * Extends.\n   */\n  \n  \"extends\": function() {\n    return this.scan(/^extends? +([^\\n]+)/, 'extends');\n  },\n\n  /**\n   * Block prepend.\n   */\n  \n  prepend: function() {\n    var captures;\n    if (captures = /^prepend +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = 'prepend'\n        , name = captures[1]\n        , tok = this.tok('block', name);\n      tok.mode = mode;\n      return tok;\n    }\n  },\n  \n  /**\n   * Block append.\n   */\n  \n  append: function() {\n    var captures;\n    if (captures = /^append +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = 'append'\n        , name = captures[1]\n        , tok = this.tok('block', name);\n      tok.mode = mode;\n      return tok;\n    }\n  },\n\n  /**\n   * Block.\n   */\n  \n  block: function() {\n    var captures;\n    if (captures = /^block\\b *(?:(prepend|append) +)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = captures[1] || 'replace'\n        , name = captures[2]\n        , tok = this.tok('block', name);\n\n      tok.mode = mode;\n      return tok;\n    }\n  },\n\n  /**\n   * Yield.\n   */\n  \n  yield: function() {\n    return this.scan(/^yield */, 'yield');\n  },\n\n  /**\n   * Include.\n   */\n  \n  include: function() {\n    return this.scan(/^include +([^\\n]+)/, 'include');\n  },\n\n  /**\n   * Case.\n   */\n  \n  \"case\": function() {\n    return this.scan(/^case +([^\\n]+)/, 'case');\n  },\n\n  /**\n   * When.\n   */\n  \n  when: function() {\n    return this.scan(/^when +([^:\\n]+)/, 'when');\n  },\n\n  /**\n   * Default.\n   */\n  \n  \"default\": function() {\n    return this.scan(/^default */, 'default');\n  },\n\n  /**\n   * Assignment.\n   */\n  \n  assignment: function() {\n    var captures;\n    if (captures = /^(\\w+) += *([^;\\n]+)( *;? *)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var name = captures[1]\n        , val = captures[2];\n      return this.tok('code', 'var ' + name + ' = (' + val + ');');\n    }\n  },\n\n  /**\n   * Call mixin.\n   */\n  \n  call: function(){\n    var captures;\n    if (captures = /^\\+([-\\w]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('call', captures[1]);\n      \n      // Check for args (not attributes)\n      if (captures = /^ *\\((.*?)\\)/.exec(this.input)) {\n        if (!/^ *[-\\w]+ *=/.test(captures[1])) {\n          this.consume(captures[0].length);\n          tok.args = captures[1];\n        }\n      }\n      \n      return tok;\n    }\n  },\n\n  /**\n   * Mixin.\n   */\n\n  mixin: function(){\n    var captures;\n    if (captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))?/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('mixin', captures[1]);\n      tok.args = captures[2];\n      return tok;\n    }\n  },\n\n  /**\n   * Conditional.\n   */\n  \n  conditional: function() {\n    var captures;\n    if (captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var type = captures[1]\n        , js = captures[2];\n\n      switch (type) {\n        case 'if': js = 'if (' + js + ')'; break;\n        case 'unless': js = 'if (!(' + js + '))'; break;\n        case 'else if': js = 'else if (' + js + ')'; break;\n        case 'else': js = 'else'; break;\n      }\n\n      return this.tok('code', js);\n    }\n  },\n\n  /**\n   * While.\n   */\n  \n  \"while\": function() {\n    var captures;\n    if (captures = /^while +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok('code', 'while (' + captures[1] + ')');\n    }\n  },\n\n  /**\n   * Each.\n   */\n  \n  each: function() {\n    var captures;\n    if (captures = /^(?:- *)?(?:each|for) +(\\w+)(?: *, *(\\w+))? * in *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('each', captures[1]);\n      tok.key = captures[2] || '$index';\n      tok.code = captures[3];\n      return tok;\n    }\n  },\n  \n  /**\n   * Code.\n   */\n  \n  code: function() {\n    var captures;\n    if (captures = /^(!?=|-)([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var flags = captures[1];\n      captures[1] = captures[2];\n      var tok = this.tok('code', captures[1]);\n      tok.escape = flags[0] === '=';\n      tok.buffer = flags[0] === '=' || flags[1] === '=';\n      return tok;\n    }\n  },\n  \n  /**\n   * Attributes.\n   */\n  \n  attrs: function() {\n    if ('(' == this.input.charAt(0)) {\n      var index = this.indexOfDelimiters('(', ')')\n        , str = this.input.substr(1, index-1)\n        , tok = this.tok('attrs')\n        , len = str.length\n        , colons = this.colons\n        , states = ['key']\n        , escapedAttr\n        , key = ''\n        , val = ''\n        , quote\n        , c\n        , p;\n\n      function state(){\n        return states[states.length - 1];\n      }\n\n      function interpolate(attr) {\n        return attr.replace(/#\\{([^}]+)\\}/g, function(_, expr){\n          return quote + \" + (\" + expr + \") + \" + quote;\n        });\n      }\n\n      this.consume(index + 1);\n      tok.attrs = {};\n      tok.escaped = {};\n\n      function parse(c) {\n        var real = c;\n        // TODO: remove when people fix \":\"\n        if (colons && ':' == c) c = '=';\n        switch (c) {\n          case ',':\n          case '\\n':\n            switch (state()) {\n              case 'expr':\n              case 'array':\n              case 'string':\n              case 'object':\n                val += c;\n                break;\n              default:\n                states.push('key');\n                val = val.trim();\n                key = key.trim();\n                if ('' == key) return;\n                key = key.replace(/^['\"]|['\"]$/g, '').replace('!', '');\n                tok.escaped[key] = escapedAttr;\n                tok.attrs[key] = '' == val\n                  ? true\n                  : interpolate(val);\n                key = val = '';\n            }\n            break;\n          case '=':\n            switch (state()) {\n              case 'key char':\n                key += real;\n                break;\n              case 'val':\n              case 'expr':\n              case 'array':\n              case 'string':\n              case 'object':\n                val += real;\n                break;\n              default:\n                escapedAttr = '!' != p;\n                states.push('val');\n            }\n            break;\n          case '(':\n            if ('val' == state()\n              || 'expr' == state()) states.push('expr');\n            val += c;\n            break;\n          case ')':\n            if ('expr' == state()\n              || 'val' == state()) states.pop();\n            val += c;\n            break;\n          case '{':\n            if ('val' == state()) states.push('object');\n            val += c;\n            break;\n          case '}':\n            if ('object' == state()) states.pop();\n            val += c;\n            break;\n          case '[':\n            if ('val' == state()) states.push('array');\n            val += c;\n            break;\n          case ']':\n            if ('array' == state()) states.pop();\n            val += c;\n            break;\n          case '\"':\n          case \"'\":\n            switch (state()) {\n              case 'key':\n                states.push('key char');\n                break;\n              case 'key char':\n                states.pop();\n                break;\n              case 'string':\n                if (c == quote) states.pop();\n                val += c;\n                break;\n              default:\n                states.push('string');\n                val += c;\n                quote = c;\n            }\n            break;\n          case '':\n            break;\n          default:\n            switch (state()) {\n              case 'key':\n              case 'key char':\n                key += c;\n                break;\n              default:\n                val += c;\n            }\n        }\n        p = c;\n      }\n\n      for (var i = 0; i < len; ++i) {\n        parse(str.charAt(i));\n      }\n\n      parse(',');\n\n      if ('/' == this.input.charAt(0)) {\n        this.consume(1);\n        tok.selfClosing = true;\n      }\n\n      return tok;\n    }\n  },\n  \n  /**\n   * Indent | Outdent | Newline.\n   */\n  \n  indent: function() {\n    var captures, re;\n\n    // established regexp\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input);\n    // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input);\n\n      // spaces\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      }\n\n      // established\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    if (captures) {\n      var tok\n        , indents = captures[1].length;\n\n      ++this.lineno;\n      this.consume(indents + 1);\n\n      if (' ' == this.input[0] || '\\t' == this.input[0]) {\n        throw new Error('Invalid indentation, you can use tabs or spaces but not both');\n      }\n\n      // blank line\n      if ('\\n' == this.input[0]) return this.tok('newline');\n\n      // outdent\n      if (this.indentStack.length && indents < this.indentStack[0]) {\n        while (this.indentStack.length && this.indentStack[0] > indents) {\n          this.stash.push(this.tok('outdent'));\n          this.indentStack.shift();\n        }\n        tok = this.stash.pop();\n      // indent\n      } else if (indents && indents != this.indentStack[0]) {\n        this.indentStack.unshift(indents);\n        tok = this.tok('indent', indents);\n      // newline\n      } else {\n        tok = this.tok('newline');\n      }\n\n      return tok;\n    }\n  },\n\n  /**\n   * Pipe-less text consumed only when \n   * pipeless is true;\n   */\n\n  pipelessText: function() {\n    if (this.pipeless) {\n      if ('\\n' == this.input[0]) return;\n      var i = this.input.indexOf('\\n');\n      if (-1 == i) i = this.input.length;\n      var str = this.input.substr(0, i);\n      this.consume(str.length);\n      return this.tok('text', str);\n    }\n  },\n\n  /**\n   * ':'\n   */\n\n  colon: function() {\n    return this.scan(/^: */, ':');\n  },\n\n  /**\n   * Return the next token object, or those\n   * previously stashed by lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n  \n  advance: function(){\n    return this.stashed()\n      || this.next();\n  },\n  \n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n  \n  next: function() {\n    return this.deferred()\n      || this.blank()\n      || this.eos()\n      || this.pipelessText()\n      || this.yield()\n      || this.doctype()\n      || this.interpolation()\n      || this[\"case\"]()\n      || this.when()\n      || this[\"default\"]()\n      || this[\"extends\"]()\n      || this.append()\n      || this.prepend()\n      || this.block()\n      || this.include()\n      || this.mixin()\n      || this.call()\n      || this.conditional()\n      || this.each()\n      || this[\"while\"]()\n      || this.assignment()\n      || this.tag()\n      || this.filter()\n      || this.code()\n      || this.id()\n      || this.className()\n      || this.attrs()\n      || this.indent()\n      || this.comment()\n      || this.colon()\n      || this.text();\n  }\n};\n",
  "node_modules/mocha/node_modules/jade/lib/nodes/attrs.js": "\n/*!\n * Jade - nodes - Attrs\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node'),\n    Block = require('./block');\n\n/**\n * Initialize a `Attrs` node.\n *\n * @api public\n */\n\nvar Attrs = module.exports = function Attrs() {\n  this.attrs = [];\n};\n\n/**\n * Inherit from `Node`.\n */\n\nAttrs.prototype.__proto__ = Node.prototype;\n\n/**\n * Set attribute `name` to `val`, keep in mind these become\n * part of a raw js object literal, so to quote a value you must\n * '\"quote me\"', otherwise or example 'user.name' is literal JavaScript.\n *\n * @param {String} name\n * @param {String} val\n * @param {Boolean} escaped\n * @return {Tag} for chaining\n * @api public\n */\n\nAttrs.prototype.setAttribute = function(name, val, escaped){\n  this.attrs.push({ name: name, val: val, escaped: escaped });\n  return this;\n};\n\n/**\n * Remove attribute `name` when present.\n *\n * @param {String} name\n * @api public\n */\n\nAttrs.prototype.removeAttribute = function(name){\n  for (var i = 0, len = this.attrs.length; i < len; ++i) {\n    if (this.attrs[i] && this.attrs[i].name == name) {\n      delete this.attrs[i];\n    }\n  }\n};\n\n/**\n * Get attribute value by `name`.\n *\n * @param {String} name\n * @return {String}\n * @api public\n */\n\nAttrs.prototype.getAttribute = function(name){\n  for (var i = 0, len = this.attrs.length; i < len; ++i) {\n    if (this.attrs[i] && this.attrs[i].name == name) {\n      return this.attrs[i].val;\n    }\n  }\n};\n",
  "node_modules/mocha/node_modules/jade/lib/nodes/block-comment.js": "\n/*!\n * Jade - nodes - BlockComment\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `BlockComment` with the given `block`.\n *\n * @param {String} val\n * @param {Block} block\n * @param {Boolean} buffer\n * @api public\n */\n\nvar BlockComment = module.exports = function BlockComment(val, block, buffer) {\n  this.block = block;\n  this.val = val;\n  this.buffer = buffer;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nBlockComment.prototype.__proto__ = Node.prototype;",
  "node_modules/mocha/node_modules/jade/lib/nodes/block.js": "\n/*!\n * Jade - nodes - Block\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Block` with an optional `node`.\n *\n * @param {Node} node\n * @api public\n */\n\nvar Block = module.exports = function Block(node){\n  this.nodes = [];\n  if (node) this.push(node);\n};\n\n/**\n * Inherit from `Node`.\n */\n\nBlock.prototype.__proto__ = Node.prototype;\n\n/**\n * Block flag.\n */\n\nBlock.prototype.isBlock = true;\n\n/**\n * Replace the nodes in `other` with the nodes\n * in `this` block.\n *\n * @param {Block} other\n * @api private\n */\n\nBlock.prototype.replace = function(other){\n  other.nodes = this.nodes;\n};\n\n/**\n * Pust the given `node`.\n *\n * @param {Node} node\n * @return {Number}\n * @api public\n */\n\nBlock.prototype.push = function(node){\n  return this.nodes.push(node);\n};\n\n/**\n * Check if this block is empty.\n *\n * @return {Boolean}\n * @api public\n */\n\nBlock.prototype.isEmpty = function(){\n  return 0 == this.nodes.length;\n};\n\n/**\n * Unshift the given `node`.\n *\n * @param {Node} node\n * @return {Number}\n * @api public\n */\n\nBlock.prototype.unshift = function(node){\n  return this.nodes.unshift(node);\n};\n\n/**\n * Return the \"last\" block, or the first `yield` node.\n *\n * @return {Block}\n * @api private\n */\n\nBlock.prototype.includeBlock = function(){\n  var ret = this\n    , node;\n\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    node = this.nodes[i];\n    if (node.yield) return node;\n    else if (node.textOnly) continue;\n    else if (node.includeBlock) ret = node.includeBlock();\n    else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();\n  }\n\n  return ret;\n};\n\n/**\n * Return a clone of this block.\n *\n * @return {Block}\n * @api private\n */\n\nBlock.prototype.clone = function(){\n  var clone = new Block;\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    clone.push(this.nodes[i].clone());\n  }\n  return clone;\n};\n\n",
  "node_modules/mocha/node_modules/jade/lib/nodes/case.js": "\n/*!\n * Jade - nodes - Case\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Case` with `expr`.\n *\n * @param {String} expr\n * @api public\n */\n\nvar Case = exports = module.exports = function Case(expr, block){\n  this.expr = expr;\n  this.block = block;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nCase.prototype.__proto__ = Node.prototype;\n\nvar When = exports.When = function When(expr, block){\n  this.expr = expr;\n  this.block = block;\n  this.debug = false;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nWhen.prototype.__proto__ = Node.prototype;\n\n",
  "node_modules/mocha/node_modules/jade/lib/nodes/code.js": "\n/*!\n * Jade - nodes - Code\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Code` node with the given code `val`.\n * Code may also be optionally buffered and escaped.\n *\n * @param {String} val\n * @param {Boolean} buffer\n * @param {Boolean} escape\n * @api public\n */\n\nvar Code = module.exports = function Code(val, buffer, escape) {\n  this.val = val;\n  this.buffer = buffer;\n  this.escape = escape;\n  if (val.match(/^ *else/)) this.debug = false;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nCode.prototype.__proto__ = Node.prototype;",
  "node_modules/mocha/node_modules/jade/lib/nodes/comment.js": "\n/*!\n * Jade - nodes - Comment\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Comment` with the given `val`, optionally `buffer`,\n * otherwise the comment may render in the output.\n *\n * @param {String} val\n * @param {Boolean} buffer\n * @api public\n */\n\nvar Comment = module.exports = function Comment(val, buffer) {\n  this.val = val;\n  this.buffer = buffer;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nComment.prototype.__proto__ = Node.prototype;",
  "node_modules/mocha/node_modules/jade/lib/nodes/doctype.js": "\n/*!\n * Jade - nodes - Doctype\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Doctype` with the given `val`. \n *\n * @param {String} val\n * @api public\n */\n\nvar Doctype = module.exports = function Doctype(val) {\n  this.val = val;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nDoctype.prototype.__proto__ = Node.prototype;",
  "node_modules/mocha/node_modules/jade/lib/nodes/each.js": "\n/*!\n * Jade - nodes - Each\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize an `Each` node, representing iteration\n *\n * @param {String} obj\n * @param {String} val\n * @param {String} key\n * @param {Block} block\n * @api public\n */\n\nvar Each = module.exports = function Each(obj, val, key, block) {\n  this.obj = obj;\n  this.val = val;\n  this.key = key;\n  this.block = block;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nEach.prototype.__proto__ = Node.prototype;",
  "node_modules/mocha/node_modules/jade/lib/nodes/filter.js": "\n/*!\n * Jade - nodes - Filter\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , Block = require('./block');\n\n/**\n * Initialize a `Filter` node with the given \n * filter `name` and `block`.\n *\n * @param {String} name\n * @param {Block|Node} block\n * @api public\n */\n\nvar Filter = module.exports = function Filter(name, block, attrs) {\n  this.name = name;\n  this.block = block;\n  this.attrs = attrs;\n  this.isASTFilter = !block.nodes.every(function(node){ return node.isText });\n};\n\n/**\n * Inherit from `Node`.\n */\n\nFilter.prototype.__proto__ = Node.prototype;",
  "node_modules/mocha/node_modules/jade/lib/nodes/index.js": "\n/*!\n * Jade - nodes\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nexports.Node = require('./node');\nexports.Tag = require('./tag');\nexports.Code = require('./code');\nexports.Each = require('./each');\nexports.Case = require('./case');\nexports.Text = require('./text');\nexports.Block = require('./block');\nexports.Mixin = require('./mixin');\nexports.Filter = require('./filter');\nexports.Comment = require('./comment');\nexports.Literal = require('./literal');\nexports.BlockComment = require('./block-comment');\nexports.Doctype = require('./doctype');\n",
  "node_modules/mocha/node_modules/jade/lib/nodes/literal.js": "\n/*!\n * Jade - nodes - Literal\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Literal` node with the given `str.\n *\n * @param {String} str\n * @api public\n */\n\nvar Literal = module.exports = function Literal(str) {\n  this.str = str\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\\n|\\r\\n/g, \"\\\\n\")\n    .replace(/'/g, \"\\\\'\");\n};\n\n/**\n * Inherit from `Node`.\n */\n\nLiteral.prototype.__proto__ = Node.prototype;\n",
  "node_modules/mocha/node_modules/jade/lib/nodes/mixin.js": "\n/*!\n * Jade - nodes - Mixin\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Attrs = require('./attrs');\n\n/**\n * Initialize a new `Mixin` with `name` and `block`.\n *\n * @param {String} name\n * @param {String} args\n * @param {Block} block\n * @api public\n */\n\nvar Mixin = module.exports = function Mixin(name, args, block, call){\n  this.name = name;\n  this.args = args;\n  this.block = block;\n  this.attrs = [];\n  this.call = call;\n};\n\n/**\n * Inherit from `Attrs`.\n */\n\nMixin.prototype.__proto__ = Attrs.prototype;\n\n",
  "node_modules/mocha/node_modules/jade/lib/nodes/node.js": "\n/*!\n * Jade - nodes - Node\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Initialize a `Node`.\n *\n * @api public\n */\n\nvar Node = module.exports = function Node(){};\n\n/**\n * Clone this node (return itself)\n *\n * @return {Node}\n * @api private\n */\n\nNode.prototype.clone = function(){\n  return this;\n};\n",
  "node_modules/mocha/node_modules/jade/lib/nodes/tag.js": "\n/*!\n * Jade - nodes - Tag\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Attrs = require('./attrs'),\n    Block = require('./block'),\n    inlineTags = require('../inline-tags');\n\n/**\n * Initialize a `Tag` node with the given tag `name` and optional `block`.\n *\n * @param {String} name\n * @param {Block} block\n * @api public\n */\n\nvar Tag = module.exports = function Tag(name, block) {\n  this.name = name;\n  this.attrs = [];\n  this.block = block || new Block;\n};\n\n/**\n * Inherit from `Attrs`.\n */\n\nTag.prototype.__proto__ = Attrs.prototype;\n\n/**\n * Clone this tag.\n *\n * @return {Tag}\n * @api private\n */\n\nTag.prototype.clone = function(){\n  var clone = new Tag(this.name, this.block.clone());\n  clone.line = this.line;\n  clone.attrs = this.attrs;\n  clone.textOnly = this.textOnly;\n  return clone;\n};\n\n/**\n * Check if this tag is an inline tag.\n *\n * @return {Boolean}\n * @api private\n */\n\nTag.prototype.isInline = function(){\n  return ~inlineTags.indexOf(this.name);\n};\n\n/**\n * Check if this tag's contents can be inlined.  Used for pretty printing.\n *\n * @return {Boolean}\n * @api private\n */\n\nTag.prototype.canInline = function(){\n  var nodes = this.block.nodes;\n\n  function isInline(node){\n    // Recurse if the node is a block\n    if (node.isBlock) return node.nodes.every(isInline);\n    return node.isText || (node.isInline && node.isInline());\n  }\n  \n  // Empty tag\n  if (!nodes.length) return true;\n  \n  // Text-only or inline-only tag\n  if (1 == nodes.length) return isInline(nodes[0]);\n  \n  // Multi-line inline-only tag\n  if (this.block.nodes.every(isInline)) {\n    for (var i = 1, len = nodes.length; i < len; ++i) {\n      if (nodes[i-1].isText && nodes[i].isText)\n        return false;\n    }\n    return true;\n  }\n  \n  // Mixed tag\n  return false;\n};",
  "node_modules/mocha/node_modules/jade/lib/nodes/text.js": "\n/*!\n * Jade - nodes - Text\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Text` node with optional `line`.\n *\n * @param {String} line\n * @api public\n */\n\nvar Text = module.exports = function Text(line) {\n  this.val = '';\n  if ('string' == typeof line) this.val = line;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nText.prototype.__proto__ = Node.prototype;\n\n/**\n * Flag as text.\n */\n\nText.prototype.isText = true;",
  "node_modules/mocha/node_modules/jade/lib/parser.js": "\n/*!\n * Jade - Parser\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Lexer = require('./lexer')\n  , nodes = require('./nodes');\n\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\nvar Parser = exports = module.exports = function Parser(str, filename, options){\n  this.input = str;\n  this.lexer = new Lexer(str, options);\n  this.filename = filename;\n  this.blocks = {};\n  this.mixins = {};\n  this.options = options;\n  this.contexts = [this];\n};\n\n/**\n * Tags that may not contain tags.\n */\n\nvar textOnly = exports.textOnly = ['script', 'style'];\n\n/**\n * Parser prototype.\n */\n\nParser.prototype = {\n\n  /**\n   * Push `parser` onto the context stack,\n   * or pop and return a `Parser`.\n   */\n\n  context: function(parser){\n    if (parser) {\n      this.contexts.push(parser);\n    } else {\n      return this.contexts.pop();\n    }\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  advance: function(){\n    return this.lexer.advance();\n  },\n\n  /**\n   * Skip `n` tokens.\n   *\n   * @param {Number} n\n   * @api private\n   */\n\n  skip: function(n){\n    while (n--) this.advance();\n  },\n  \n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n  \n  peek: function() {\n    return this.lookahead(1);\n  },\n  \n  /**\n   * Return lexer lineno.\n   *\n   * @return {Number}\n   * @api private\n   */\n  \n  line: function() {\n    return this.lexer.lineno;\n  },\n  \n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  \n  lookahead: function(n){\n    return this.lexer.lookahead(n);\n  },\n  \n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n  \n  parse: function(){\n    var block = new nodes.Block, parser;\n    block.line = this.line();\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        block.push(this.parseExpr());\n      }\n    }\n\n    if (parser = this.extending) {\n      this.context(parser);\n      var ast = parser.parse();\n      this.context();\n      // hoist mixins\n      for (var name in this.mixins)\n        ast.unshift(this.mixins[name]);\n      return ast;\n    }\n\n    return block;\n  },\n  \n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n  \n  expect: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      throw new Error('expected \"' + type + '\", but got \"' + this.peek().type + '\"');\n    }\n  },\n  \n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n  \n  accept: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n  \n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n  \n  parseExpr: function(){\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n      case 'mixin':\n        return this.parseMixin();\n      case 'block':\n        return this.parseBlock();\n      case 'case':\n        return this.parseCase();\n      case 'when':\n        return this.parseWhen();\n      case 'default':\n        return this.parseDefault();\n      case 'extends':\n        return this.parseExtends();\n      case 'include':\n        return this.parseInclude();\n      case 'doctype':\n        return this.parseDoctype();\n      case 'filter':\n        return this.parseFilter();\n      case 'comment':\n        return this.parseComment();\n      case 'text':\n        return this.parseText();\n      case 'each':\n        return this.parseEach();\n      case 'code':\n        return this.parseCode();\n      case 'call':\n        return this.parseCall();\n      case 'interpolation':\n        return this.parseInterpolation();\n      case 'yield':\n        this.advance();\n        var block = new nodes.Block;\n        block.yield = true;\n        return block;\n      case 'id':\n      case 'class':\n        var tok = this.advance();\n        this.lexer.defer(this.lexer.tok('tag', 'div'));\n        this.lexer.defer(tok);\n        return this.parseExpr();\n      default:\n        throw new Error('unexpected token \"' + this.peek().type + '\"');\n    }\n  },\n  \n  /**\n   * Text\n   */\n  \n  parseText: function(){\n    var tok = this.expect('text')\n      , node = new nodes.Text(tok.val);\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n\n  parseBlockExpansion: function(){\n    if (':' == this.peek().type) {\n      this.advance();\n      return new nodes.Block(this.parseExpr());\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n\n  parseCase: function(){\n    var val = this.expect('case').val\n      , node = new nodes.Case(val);\n    node.line = this.line();\n    node.block = this.block();\n    return node;\n  },\n\n  /**\n   * when\n   */\n\n  parseWhen: function(){\n    var val = this.expect('when').val\n    return new nodes.Case.When(val, this.parseBlockExpansion());\n  },\n  \n  /**\n   * default\n   */\n\n  parseDefault: function(){\n    this.expect('default');\n    return new nodes.Case.When('default', this.parseBlockExpansion());\n  },\n\n  /**\n   * code\n   */\n  \n  parseCode: function(){\n    var tok = this.expect('code')\n      , node = new nodes.Code(tok.val, tok.buffer, tok.escape)\n      , block\n      , i = 1;\n    node.line = this.line();\n    while (this.lookahead(i) && 'newline' == this.lookahead(i).type) ++i;\n    block = 'indent' == this.lookahead(i).type;\n    if (block) {\n      this.skip(i-1);\n      node.block = this.block();\n    }\n    return node;\n  },\n  \n  /**\n   * comment\n   */\n  \n  parseComment: function(){\n    var tok = this.expect('comment')\n      , node;\n\n    if ('indent' == this.peek().type) {\n      node = new nodes.BlockComment(tok.val, this.block(), tok.buffer);\n    } else {\n      node = new nodes.Comment(tok.val, tok.buffer);\n    }\n\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * doctype\n   */\n  \n  parseDoctype: function(){\n    var tok = this.expect('doctype')\n      , node = new nodes.Doctype(tok.val);\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * filter attrs? text-block\n   */\n  \n  parseFilter: function(){\n    var block\n      , tok = this.expect('filter')\n      , attrs = this.accept('attrs');\n\n    this.lexer.pipeless = true;\n    block = this.parseTextBlock();\n    this.lexer.pipeless = false;\n\n    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * tag ':' attrs? block\n   */\n  \n  parseASTFilter: function(){\n    var block\n      , tok = this.expect('tag')\n      , attrs = this.accept('attrs');\n\n    this.expect(':');\n    block = this.block();\n\n    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * each block\n   */\n  \n  parseEach: function(){\n    var tok = this.expect('each')\n      , node = new nodes.Each(tok.code, tok.val, tok.key);\n    node.line = this.line();\n    node.block = this.block();\n    return node;\n  },\n\n  /**\n   * 'extends' name\n   */\n\n  parseExtends: function(){\n    var path = require('path')\n      , fs = require('fs')\n      , dirname = path.dirname\n      , basename = path.basename\n      , join = path.join;\n\n    if (!this.filename)\n      throw new Error('the \"filename\" option is required to extend templates');\n\n    var path = this.expect('extends').val.trim()\n      , dir = dirname(this.filename);\n\n    var path = join(dir, path + '.jade')\n      , str = fs.readFileSync(path, 'utf8')\n      , parser = new Parser(str, path, this.options);\n\n    parser.blocks = this.blocks;\n    parser.contexts = this.contexts;\n    this.extending = parser;\n\n    // TODO: null node\n    return new nodes.Literal('');\n  },\n\n  /**\n   * 'block' name block\n   */\n\n  parseBlock: function(){\n    var block = this.expect('block')\n      , mode = block.mode\n      , name = block.val.trim();\n\n    block = 'indent' == this.peek().type\n      ? this.block()\n      : new nodes.Block(new nodes.Literal(''));\n\n    var prev = this.blocks[name];\n\n    if (prev) {\n      switch (prev.mode) {\n        case 'append':\n          block.nodes = block.nodes.concat(prev.nodes);\n          prev = block;\n          break;\n        case 'prepend':\n          block.nodes = prev.nodes.concat(block.nodes);\n          prev = block;\n          break;\n      }\n    }\n\n    block.mode = mode;\n    return this.blocks[name] = prev || block;\n  },\n\n  /**\n   * include block?\n   */\n\n  parseInclude: function(){\n    var path = require('path')\n      , fs = require('fs')\n      , dirname = path.dirname\n      , basename = path.basename\n      , join = path.join;\n\n    var path = this.expect('include').val.trim()\n      , dir = dirname(this.filename);\n\n    if (!this.filename)\n      throw new Error('the \"filename\" option is required to use includes');\n\n    // no extension\n    if (!~basename(path).indexOf('.')) {\n      path += '.jade';\n    }\n\n    // non-jade\n    if ('.jade' != path.substr(-5)) {\n      var path = join(dir, path)\n        , str = fs.readFileSync(path, 'utf8');\n      return new nodes.Literal(str);\n    }\n\n    var path = join(dir, path)\n      , str = fs.readFileSync(path, 'utf8')\n     , parser = new Parser(str, path, this.options);\n    parser.blocks = this.blocks;\n    parser.mixins = this.mixins;\n\n    this.context(parser);\n    var ast = parser.parse();\n    this.context();\n    ast.filename = path;\n\n    if ('indent' == this.peek().type) {\n      ast.includeBlock().push(this.block());\n    }\n\n    return ast;\n  },\n\n  /**\n   * call ident block\n   */\n\n  parseCall: function(){\n    var tok = this.expect('call')\n      , name = tok.val\n      , args = tok.args\n      , mixin = new nodes.Mixin(name, args, new nodes.Block, true);\n\n    this.tag(mixin);\n    if (mixin.block.isEmpty()) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n\n  parseMixin: function(){\n    var tok = this.expect('mixin')\n      , name = tok.val\n      , args = tok.args\n      , mixin;\n\n    // definition\n    if ('indent' == this.peek().type) {\n      mixin = new nodes.Mixin(name, args, this.block(), false);\n      this.mixins[name] = mixin;\n      return mixin;\n    // call\n    } else {\n      return new nodes.Mixin(name, args, null, true);\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n\n  parseTextBlock: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    var spaces = this.expect('indent').val;\n    if (null == this._spaces) this._spaces = spaces;\n    var indent = Array(spaces - this._spaces + 1).join(' ');\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'newline':\n          this.advance();\n          break;\n        case 'indent':\n          this.parseTextBlock().nodes.forEach(function(node){\n            block.push(node);\n          });\n          break;\n        default:\n          var text = new nodes.Text(indent + this.advance().val);\n          text.line = this.line();\n          block.push(text);\n      }\n    }\n\n    if (spaces == this._spaces) this._spaces = null;\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n  \n  block: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    this.expect('indent');\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        block.push(this.parseExpr());\n      }\n    }\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  \n  parseInterpolation: function(){\n    var tok = this.advance();\n    var tag = new nodes.Tag(tok.val);\n    tag.buffer = true;\n    return this.tag(tag);\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  \n  parseTag: function(){\n    // ast-filter look-ahead\n    var i = 2;\n    if ('attrs' == this.lookahead(i).type) ++i;\n    if (':' == this.lookahead(i).type) {\n      if ('indent' == this.lookahead(++i).type) {\n        return this.parseASTFilter();\n      }\n    }\n\n    var tok = this.advance()\n      , tag = new nodes.Tag(tok.val);\n\n    tag.selfClosing = tok.selfClosing;\n\n    return this.tag(tag);\n  },\n\n  /**\n   * Parse tag.\n   */\n\n  tag: function(tag){\n    var dot;\n\n    tag.line = this.line();\n\n    // (attrs | class | id)*\n    out:\n      while (true) {\n        switch (this.peek().type) {\n          case 'id':\n          case 'class':\n            var tok = this.advance();\n            tag.setAttribute(tok.type, \"'\" + tok.val + \"'\");\n            continue;\n          case 'attrs':\n            var tok = this.advance()\n              , obj = tok.attrs\n              , escaped = tok.escaped\n              , names = Object.keys(obj);\n\n            if (tok.selfClosing) tag.selfClosing = true;\n\n            for (var i = 0, len = names.length; i < len; ++i) {\n              var name = names[i]\n                , val = obj[name];\n              tag.setAttribute(name, val, escaped[name]);\n            }\n            continue;\n          default:\n            break out;\n        }\n      }\n\n    // check immediate '.'\n    if ('.' == this.peek().val) {\n      dot = tag.textOnly = true;\n      this.advance();\n    }\n\n    // (text | code | ':')?\n    switch (this.peek().type) {\n      case 'text':\n        tag.block.push(this.parseText());\n        break;\n      case 'code':\n        tag.code = this.parseCode();\n        break;\n      case ':':\n        this.advance();\n        tag.block = new nodes.Block;\n        tag.block.push(this.parseExpr());\n        break;\n    }\n\n    // newline*\n    while ('newline' == this.peek().type) this.advance();\n\n    tag.textOnly = tag.textOnly || ~textOnly.indexOf(tag.name);\n\n    // script special-case\n    if ('script' == tag.name) {\n      var type = tag.getAttribute('type');\n      if (!dot && type && 'text/javascript' != type.replace(/^['\"]|['\"]$/g, '')) {\n        tag.textOnly = false;\n      }\n    }\n\n    // block?\n    if ('indent' == this.peek().type) {\n      if (tag.textOnly) {\n        this.lexer.pipeless = true;\n        tag.block = this.parseTextBlock();\n        this.lexer.pipeless = false;\n      } else {\n        var block = this.block();\n        if (tag.block) {\n          for (var i = 0, len = block.nodes.length; i < len; ++i) {\n            tag.block.push(block.nodes[i]);\n          }\n        } else {\n          tag.block = block;\n        }\n      }\n    }\n    \n    return tag;\n  }\n};\n",
  "node_modules/mocha/node_modules/jade/lib/runtime.js": "\n/*!\n * Jade - runtime\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Lame Array.isArray() polyfill for now.\n */\n\nif (!Array.isArray) {\n  Array.isArray = function(arr){\n    return '[object Array]' == Object.prototype.toString.call(arr);\n  };\n}\n\n/**\n * Lame Object.keys() polyfill for now.\n */\n\nif (!Object.keys) {\n  Object.keys = function(obj){\n    var arr = [];\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        arr.push(key);\n      }\n    }\n    return arr;\n  }\n}\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    ac = ac.filter(nulls);\n    bc = bc.filter(nulls);\n    a['class'] = ac.concat(bc).join(' ');\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null;\n}\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n * @api private\n */\n\nexports.attrs = function attrs(obj, escaped){\n  var buf = []\n    , terse = obj.terse;\n\n  delete obj.terse;\n  var keys = Object.keys(obj)\n    , len = keys.length;\n\n  if (len) {\n    buf.push('');\n    for (var i = 0; i < len; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('boolean' == typeof val || null == val) {\n        if (val) {\n          terse\n            ? buf.push(key)\n            : buf.push(key + '=\"' + key + '\"');\n        }\n      } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n        buf.push(key + \"='\" + JSON.stringify(val) + \"'\");\n      } else if ('class' == key && Array.isArray(val)) {\n        buf.push(key + '=\"' + exports.escape(val.join(' ')) + '\"');\n      } else if (escaped && escaped[key]) {\n        buf.push(key + '=\"' + exports.escape(val) + '\"');\n      } else {\n        buf.push(key + '=\"' + val + '\"');\n      }\n    }\n  }\n\n  return buf.join(' ');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function escape(html){\n  return String(html)\n    .replace(/&(?!(\\w+|\\#\\d+);)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno){\n  if (!filename) throw err;\n\n  var context = 3\n    , str = require('fs').readFileSync(filename, 'utf8')\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n",
  "node_modules/mocha/node_modules/jade/lib/self-closing.js": "\n/*!\n * Jade - self closing tags\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = [\n    'meta'\n  , 'img'\n  , 'link'\n  , 'input'\n  , 'source'\n  , 'area'\n  , 'base'\n  , 'col'\n  , 'br'\n  , 'hr'\n];",
  "node_modules/mocha/node_modules/jade/lib/utils.js": "\n/*!\n * Jade - utils\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Convert interpolation in the given string to JavaScript.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nvar interpolate = exports.interpolate = function(str){\n  return str.replace(/(\\\\)?([#!]){(.*?)}/g, function(str, escape, flag, code){\n    return escape\n      ? str\n      : \"' + \"\n        + ('!' == flag ? '' : 'escape')\n        + \"((interp = \" + code.replace(/\\\\'/g, \"'\")\n        + \") == null ? '' : interp) + '\";\n  });\n};\n\n/**\n * Escape single quotes in `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nvar escape = exports.escape = function(str) {\n  return str.replace(/'/g, \"\\\\'\");\n};\n\n/**\n * Interpolate, and escape the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.text = function(str){\n  return interpolate(escape(str));\n};",
  "node_modules/mocha/node_modules/jade/node_modules/commander/index.js": "\nmodule.exports = require('./lib/commander');",
  "node_modules/mocha/node_modules/jade/node_modules/commander/lib/commander.js": "\n/*!\n * commander\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter\n  , path = require('path')\n  , tty = require('tty')\n  , basename = path.basename;\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command;\n\n/**\n * Expose `Command`.\n */\n\nexports.Command = Command;\n\n/**\n * Expose `Option`.\n */\n\nexports.Option = Option;\n\n/**\n * Initialize a new `Option` with the given `flags` and `description`.\n *\n * @param {String} flags\n * @param {String} description\n * @api public\n */\n\nfunction Option(flags, description) {\n  this.flags = flags;\n  this.required = ~flags.indexOf('<');\n  this.optional = ~flags.indexOf('[');\n  this.bool = !~flags.indexOf('-no-');\n  flags = flags.split(/[ ,|]+/);\n  if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();\n  this.long = flags.shift();\n  this.description = description;\n}\n\n/**\n * Return option name.\n *\n * @return {String}\n * @api private\n */\n\nOption.prototype.name = function(){\n  return this.long\n    .replace('--', '')\n    .replace('no-', '');\n};\n\n/**\n * Check if `arg` matches the short or long flag.\n *\n * @param {String} arg\n * @return {Boolean}\n * @api private\n */\n\nOption.prototype.is = function(arg){\n  return arg == this.short\n    || arg == this.long;\n};\n\n/**\n * Initialize a new `Command`.\n *\n * @param {String} name\n * @api public\n */\n\nfunction Command(name) {\n  this.commands = [];\n  this.options = [];\n  this.args = [];\n  this.name = name;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nCommand.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Add command `name`.\n *\n * The `.action()` callback is invoked when the\n * command `name` is specified via __ARGV__,\n * and the remaining arguments are applied to the\n * function for access.\n *\n * When the `name` is \"*\" an un-matched command\n * will be passed as the first arg, followed by\n * the rest of __ARGV__ remaining.\n *\n * Examples:\n *\n *      program\n *        .version('0.0.1')\n *        .option('-C, --chdir <path>', 'change the working directory')\n *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')\n *        .option('-T, --no-tests', 'ignore test hook')\n *     \n *      program\n *        .command('setup')\n *        .description('run remote setup commands')\n *        .action(function(){\n *          console.log('setup');\n *        });\n *     \n *      program\n *        .command('exec <cmd>')\n *        .description('run the given remote command')\n *        .action(function(cmd){\n *          console.log('exec \"%s\"', cmd);\n *        });\n *     \n *      program\n *        .command('*')\n *        .description('deploy the given env')\n *        .action(function(env){\n *          console.log('deploying \"%s\"', env);\n *        });\n *     \n *      program.parse(process.argv);\n  *\n * @param {String} name\n * @return {Command} the new command\n * @api public\n */\n\nCommand.prototype.command = function(name){\n  var args = name.split(/ +/);\n  var cmd = new Command(args.shift());\n  this.commands.push(cmd);\n  cmd.parseExpectedArgs(args);\n  cmd.parent = this;\n  return cmd;\n};\n\n/**\n * Parse expected `args`.\n *\n * For example `[\"[type]\"]` becomes `[{ required: false, name: 'type' }]`.\n *\n * @param {Array} args\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.parseExpectedArgs = function(args){\n  if (!args.length) return;\n  var self = this;\n  args.forEach(function(arg){\n    switch (arg[0]) {\n      case '<':\n        self.args.push({ required: true, name: arg.slice(1, -1) });\n        break;\n      case '[':\n        self.args.push({ required: false, name: arg.slice(1, -1) });\n        break;\n    }\n  });\n  return this;\n};\n\n/**\n * Register callback `fn` for the command.\n *\n * Examples:\n *\n *      program\n *        .command('help')\n *        .description('display verbose help')\n *        .action(function(){\n *           // output help here\n *        });\n *\n * @param {Function} fn\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.action = function(fn){\n  var self = this;\n  this.parent.on(this.name, function(args, unknown){    \n    // Parse any so-far unknown options\n    unknown = unknown || [];\n    var parsed = self.parseOptions(unknown);\n    \n    // Output help if necessary\n    outputHelpIfNecessary(self, parsed.unknown);\n    \n    // If there are still any unknown options, then we simply \n    // die, unless someone asked for help, in which case we give it\n    // to them, and then we die.\n    if (parsed.unknown.length > 0) {      \n      self.unknownOption(parsed.unknown[0]);\n    }\n    \n    self.args.forEach(function(arg, i){\n      if (arg.required && null == args[i]) {\n        self.missingArgument(arg.name);\n      }\n    });\n    \n    // Always append ourselves to the end of the arguments,\n    // to make sure we match the number of arguments the user\n    // expects\n    if (self.args.length) {\n      args[self.args.length] = self;\n    } else {\n      args.push(self);\n    }\n    \n    fn.apply(this, args);\n  });\n  return this;\n};\n\n/**\n * Define option with `flags`, `description` and optional\n * coercion `fn`. \n *\n * The `flags` string should contain both the short and long flags,\n * separated by comma, a pipe or space. The following are all valid\n * all will output this way when `--help` is used.\n *\n *    \"-p, --pepper\"\n *    \"-p|--pepper\"\n *    \"-p --pepper\"\n *\n * Examples:\n *\n *     // simple boolean defaulting to false\n *     program.option('-p, --pepper', 'add pepper');\n *\n *     --pepper\n *     program.pepper\n *     // => Boolean\n *\n *     // simple boolean defaulting to false\n *     program.option('-C, --no-cheese', 'remove cheese');\n *\n *     program.cheese\n *     // => true\n *\n *     --no-cheese\n *     program.cheese\n *     // => true\n *\n *     // required argument\n *     program.option('-C, --chdir <path>', 'change the working directory');\n *\n *     --chdir /tmp\n *     program.chdir\n *     // => \"/tmp\"\n *\n *     // optional argument\n *     program.option('-c, --cheese [type]', 'add cheese [marble]');\n *\n * @param {String} flags\n * @param {String} description\n * @param {Function|Mixed} fn or default\n * @param {Mixed} defaultValue\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.option = function(flags, description, fn, defaultValue){\n  var self = this\n    , option = new Option(flags, description)\n    , oname = option.name()\n    , name = camelcase(oname);\n\n  // default as 3rd arg\n  if ('function' != typeof fn) defaultValue = fn, fn = null;\n\n  // preassign default value only for --no-*, [optional], or <required>\n  if (false == option.bool || option.optional || option.required) {\n    // when --no-* we make sure default is true\n    if (false == option.bool) defaultValue = true;\n    // preassign only if we have a default\n    if (undefined !== defaultValue) self[name] = defaultValue;\n  }\n\n  // register the option\n  this.options.push(option);\n\n  // when it's passed assign the value\n  // and conditionally invoke the callback\n  this.on(oname, function(val){\n    // coercion\n    if (null != val && fn) val = fn(val);\n\n    // unassigned or bool\n    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {\n      // if no value, bool true, and we have a default, then use it!\n      if (null == val) {\n        self[name] = option.bool\n          ? defaultValue || true\n          : false;\n      } else {\n        self[name] = val;\n      }\n    } else if (null !== val) {\n      // reassign\n      self[name] = val;\n    }\n  });\n\n  return this;\n};\n\n/**\n * Parse `argv`, settings options and invoking commands when defined.\n *\n * @param {Array} argv\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.parse = function(argv){\n  // store raw args\n  this.rawArgs = argv;\n\n  // guess name\n  if (!this.name) this.name = basename(argv[1]);\n\n  // process argv\n  var parsed = this.parseOptions(this.normalize(argv.slice(2)));\n  this.args = parsed.args;\n  return this.parseArgs(this.args, parsed.unknown);\n};\n\n/**\n * Normalize `args`, splitting joined short flags. For example\n * the arg \"-abc\" is equivalent to \"-a -b -c\".\n *\n * @param {Array} args\n * @return {Array}\n * @api private\n */\n\nCommand.prototype.normalize = function(args){\n  var ret = []\n    , arg;\n\n  for (var i = 0, len = args.length; i < len; ++i) {\n    arg = args[i];\n    if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {\n      arg.slice(1).split('').forEach(function(c){\n        ret.push('-' + c);\n      });\n    } else {\n      ret.push(arg);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Parse command `args`.\n *\n * When listener(s) are available those\n * callbacks are invoked, otherwise the \"*\"\n * event is emitted and those actions are invoked.\n *\n * @param {Array} args\n * @return {Command} for chaining\n * @api private\n */\n\nCommand.prototype.parseArgs = function(args, unknown){\n  var cmds = this.commands\n    , len = cmds.length\n    , name;\n\n  if (args.length) {\n    name = args[0];\n    if (this.listeners(name).length) {\n      this.emit(args.shift(), args, unknown);\n    } else {\n      this.emit('*', args);\n    }\n  } else {\n    outputHelpIfNecessary(this, unknown);\n    \n    // If there were no args and we have unknown options,\n    // then they are extraneous and we need to error.\n    if (unknown.length > 0) {      \n      this.unknownOption(unknown[0]);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return an option matching `arg` if any.\n *\n * @param {String} arg\n * @return {Option}\n * @api private\n */\n\nCommand.prototype.optionFor = function(arg){\n  for (var i = 0, len = this.options.length; i < len; ++i) {\n    if (this.options[i].is(arg)) {\n      return this.options[i];\n    }\n  }\n};\n\n/**\n * Parse options from `argv` returning `argv`\n * void of these options.\n *\n * @param {Array} argv\n * @return {Array}\n * @api public\n */\n\nCommand.prototype.parseOptions = function(argv){\n  var args = []\n    , len = argv.length\n    , literal\n    , option\n    , arg;\n\n  var unknownOptions = [];\n\n  // parse options\n  for (var i = 0; i < len; ++i) {\n    arg = argv[i];\n\n    // literal args after --\n    if ('--' == arg) {\n      literal = true;\n      continue;\n    }\n\n    if (literal) {\n      args.push(arg);\n      continue;\n    }\n\n    // find matching Option\n    option = this.optionFor(arg);\n\n    // option is defined\n    if (option) {\n      // requires arg\n      if (option.required) {\n        arg = argv[++i];\n        if (null == arg) return this.optionMissingArgument(option);\n        if ('-' == arg[0]) return this.optionMissingArgument(option, arg);\n        this.emit(option.name(), arg);\n      // optional arg\n      } else if (option.optional) {\n        arg = argv[i+1];\n        if (null == arg || '-' == arg[0]) {\n          arg = null;\n        } else {\n          ++i;\n        }\n        this.emit(option.name(), arg);\n      // bool\n      } else {\n        this.emit(option.name());\n      }\n      continue;\n    }\n    \n    // looks like an option\n    if (arg.length > 1 && '-' == arg[0]) {\n      unknownOptions.push(arg);\n      \n      // If the next argument looks like it might be\n      // an argument for this option, we pass it on.\n      // If it isn't, then it'll simply be ignored\n      if (argv[i+1] && '-' != argv[i+1][0]) {\n        unknownOptions.push(argv[++i]);\n      }\n      continue;\n    }\n    \n    // arg\n    args.push(arg);\n  }\n  \n  return { args: args, unknown: unknownOptions };\n};\n\n/**\n * Argument `name` is missing.\n *\n * @param {String} name\n * @api private\n */\n\nCommand.prototype.missingArgument = function(name){\n  console.error();\n  console.error(\"  error: missing required argument `%s'\", name);\n  console.error();\n  process.exit(1);\n};\n\n/**\n * `Option` is missing an argument, but received `flag` or nothing.\n *\n * @param {String} option\n * @param {String} flag\n * @api private\n */\n\nCommand.prototype.optionMissingArgument = function(option, flag){\n  console.error();\n  if (flag) {\n    console.error(\"  error: option `%s' argument missing, got `%s'\", option.flags, flag);\n  } else {\n    console.error(\"  error: option `%s' argument missing\", option.flags);\n  }\n  console.error();\n  process.exit(1);\n};\n\n/**\n * Unknown option `flag`.\n *\n * @param {String} flag\n * @api private\n */\n\nCommand.prototype.unknownOption = function(flag){\n  console.error();\n  console.error(\"  error: unknown option `%s'\", flag);\n  console.error();\n  process.exit(1);\n};\n\n/**\n * Set the program version to `str`.\n *\n * This method auto-registers the \"-V, --version\" flag\n * which will print the version number when passed.\n *\n * @param {String} str\n * @param {String} flags\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.version = function(str, flags){\n  if (0 == arguments.length) return this._version;\n  this._version = str;\n  flags = flags || '-V, --version';\n  this.option(flags, 'output the version number');\n  this.on('version', function(){\n    console.log(str);\n    process.exit(0);\n  });\n  return this;\n};\n\n/**\n * Set the description `str`.\n *\n * @param {String} str\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.description = function(str){\n  if (0 == arguments.length) return this._description;\n  this._description = str;\n  return this;\n};\n\n/**\n * Set / get the command usage `str`.\n *\n * @param {String} str\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.usage = function(str){\n  var args = this.args.map(function(arg){\n    return arg.required\n      ? '<' + arg.name + '>'\n      : '[' + arg.name + ']';\n  });\n\n  var usage = '[options'\n    + (this.commands.length ? '] [command' : '')\n    + ']'\n    + (this.args.length ? ' ' + args : '');\n  if (0 == arguments.length) return this._usage || usage;\n  this._usage = str;\n\n  return this;\n};\n\n/**\n * Return the largest option length.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.largestOptionLength = function(){\n  return this.options.reduce(function(max, option){\n    return Math.max(max, option.flags.length);\n  }, 0);\n};\n\n/**\n * Return help for options.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.optionHelp = function(){\n  var width = this.largestOptionLength();\n  \n  // Prepend the help information\n  return [pad('-h, --help', width) + '  ' + 'output usage information']\n    .concat(this.options.map(function(option){\n      return pad(option.flags, width)\n        + '  ' + option.description;\n      }))\n    .join('\\n');\n};\n\n/**\n * Return command help documentation.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.commandHelp = function(){\n  if (!this.commands.length) return '';\n  return [\n      ''\n    , '  Commands:'\n    , ''\n    , this.commands.map(function(cmd){\n      var args = cmd.args.map(function(arg){\n        return arg.required\n          ? '<' + arg.name + '>'\n          : '[' + arg.name + ']';\n      }).join(' ');\n\n      return cmd.name \n        + (cmd.options.length \n          ? ' [options]'\n          : '') + ' ' + args\n        + (cmd.description()\n          ? '\\n' + cmd.description()\n          : '');\n    }).join('\\n\\n').replace(/^/gm, '    ')\n    , ''\n  ].join('\\n');\n};\n\n/**\n * Return program help documentation.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.helpInformation = function(){\n  return [\n      ''\n    , '  Usage: ' + this.name + ' ' + this.usage()\n    , '' + this.commandHelp()\n    , '  Options:'\n    , ''\n    , '' + this.optionHelp().replace(/^/gm, '    ')\n    , ''\n    , ''\n  ].join('\\n');\n};\n\n/**\n * Prompt for a `Number`.\n *\n * @param {String} str\n * @param {Function} fn\n * @api private\n */\n\nCommand.prototype.promptForNumber = function(str, fn){\n  var self = this;\n  this.promptSingleLine(str, function parseNumber(val){\n    val = Number(val);\n    if (isNaN(val)) return self.promptSingleLine(str + '(must be a number) ', parseNumber);\n    fn(val);\n  });\n};\n\n/**\n * Prompt for a `Date`.\n *\n * @param {String} str\n * @param {Function} fn\n * @api private\n */\n\nCommand.prototype.promptForDate = function(str, fn){\n  var self = this;\n  this.promptSingleLine(str, function parseDate(val){\n    val = new Date(val);\n    if (isNaN(val.getTime())) return self.promptSingleLine(str + '(must be a date) ', parseDate);\n    fn(val);\n  });\n};\n\n/**\n * Single-line prompt.\n *\n * @param {String} str\n * @param {Function} fn\n * @api private\n */\n\nCommand.prototype.promptSingleLine = function(str, fn){\n  if ('function' == typeof arguments[2]) {\n    return this['promptFor' + (fn.name || fn)](str, arguments[2]);\n  }\n\n  process.stdout.write(str);\n  process.stdin.setEncoding('utf8');\n  process.stdin.once('data', function(val){\n    fn(val.trim());\n  }).resume();\n};\n\n/**\n * Multi-line prompt.\n *\n * @param {String} str\n * @param {Function} fn\n * @api private\n */\n\nCommand.prototype.promptMultiLine = function(str, fn){\n  var buf = [];\n  console.log(str);\n  process.stdin.setEncoding('utf8');\n  process.stdin.on('data', function(val){\n    if ('\\n' == val || '\\r\\n' == val) {\n      process.stdin.removeAllListeners('data');\n      fn(buf.join('\\n'));\n    } else {\n      buf.push(val.trimRight());\n    }\n  }).resume();\n};\n\n/**\n * Prompt `str` and callback `fn(val)`\n *\n * Commander supports single-line and multi-line prompts.\n * To issue a single-line prompt simply add white-space\n * to the end of `str`, something like \"name: \", whereas\n * for a multi-line prompt omit this \"description:\".\n *\n *\n * Examples:\n *\n *     program.prompt('Username: ', function(name){\n *       console.log('hi %s', name);\n *     });\n *     \n *     program.prompt('Description:', function(desc){\n *       console.log('description was \"%s\"', desc.trim());\n *     });\n *\n * @param {String|Object} str\n * @param {Function} fn\n * @api public\n */\n\nCommand.prototype.prompt = function(str, fn){\n  var self = this;\n\n  if ('string' == typeof str) {\n    if (/ $/.test(str)) return this.promptSingleLine.apply(this, arguments);\n    this.promptMultiLine(str, fn);\n  } else {\n    var keys = Object.keys(str)\n      , obj = {};\n\n    function next() {\n      var key = keys.shift()\n        , label = str[key];\n\n      if (!key) return fn(obj);\n      self.prompt(label, function(val){\n        obj[key] = val;\n        next();\n      });\n    }\n\n    next();\n  }\n};\n\n/**\n * Prompt for password with `str`, `mask` char and callback `fn(val)`.\n *\n * The mask string defaults to '', aka no output is\n * written while typing, you may want to use \"*\" etc.\n *\n * Examples:\n *\n *     program.password('Password: ', function(pass){\n *       console.log('got \"%s\"', pass);\n *       process.stdin.destroy();\n *     });\n *\n *     program.password('Password: ', '*', function(pass){\n *       console.log('got \"%s\"', pass);\n *       process.stdin.destroy();\n *     });\n *\n * @param {String} str\n * @param {String} mask\n * @param {Function} fn\n * @api public\n */\n\nCommand.prototype.password = function(str, mask, fn){\n  var self = this\n    , buf = '';\n\n  // default mask\n  if ('function' == typeof mask) {\n    fn = mask;\n    mask = '';\n  }\n\n  process.stdin.resume();\n  tty.setRawMode(true);\n  process.stdout.write(str);\n\n  // keypress\n  process.stdin.on('keypress', function(c, key){\n    if (key && 'enter' == key.name) {\n      console.log();\n      process.stdin.removeAllListeners('keypress');\n      tty.setRawMode(false);\n      if (!buf.trim().length) return self.password(str, mask, fn);\n      fn(buf);\n      return;\n    }\n\n    if (key && key.ctrl && 'c' == key.name) {\n      console.log('%s', buf);\n      process.exit();\n    }\n\n    process.stdout.write(mask);\n    buf += c;\n  }).resume();\n};\n\n/**\n * Confirmation prompt with `str` and callback `fn(bool)`\n *\n * Examples:\n *\n *      program.confirm('continue? ', function(ok){\n *        console.log(' got %j', ok);\n *        process.stdin.destroy();\n *      });\n *\n * @param {String} str\n * @param {Function} fn\n * @api public\n */\n\n\nCommand.prototype.confirm = function(str, fn, verbose){\n  var self = this;\n  this.prompt(str, function(ok){\n    if (!ok.trim()) {\n      if (!verbose) str += '(yes or no) ';\n      return self.confirm(str, fn, true);\n    }\n    fn(parseBool(ok));\n  });\n};\n\n/**\n * Choice prompt with `list` of items and callback `fn(index, item)`\n *\n * Examples:\n *\n *      var list = ['tobi', 'loki', 'jane', 'manny', 'luna'];\n *      \n *      console.log('Choose the coolest pet:');\n *      program.choose(list, function(i){\n *        console.log('you chose %d \"%s\"', i, list[i]);\n *        process.stdin.destroy();\n *      });\n *\n * @param {Array} list\n * @param {Number|Function} index or fn\n * @param {Function} fn\n * @api public\n */\n\nCommand.prototype.choose = function(list, index, fn){\n  var self = this\n    , hasDefault = 'number' == typeof index;\n\n  if (!hasDefault) {\n    fn = index;\n    index = null;\n  }\n\n  list.forEach(function(item, i){\n    if (hasDefault && i == index) {\n      console.log('* %d) %s', i + 1, item);\n    } else {\n      console.log('  %d) %s', i + 1, item);\n    }\n  });\n\n  function again() {\n    self.prompt('  : ', function(val){\n      val = parseInt(val, 10) - 1;\n      if (hasDefault && isNaN(val)) val = index;\n\n      if (null == list[val]) {\n        again();\n      } else {\n        fn(val, list[val]);\n      }\n    });\n  }\n\n  again();\n};\n\n/**\n * Camel-case the given `flag`\n *\n * @param {String} flag\n * @return {String}\n * @api private\n */\n\nfunction camelcase(flag) {\n  return flag.split('-').reduce(function(str, word){\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Parse a boolean `str`.\n *\n * @param {String} str\n * @return {Boolean}\n * @api private\n */\n\nfunction parseBool(str) {\n  return /^y|yes|ok|true$/i.test(str);\n}\n\n/**\n * Pad `str` to `width`.\n *\n * @param {String} str\n * @param {Number} width\n * @return {String}\n * @api private\n */\n\nfunction pad(str, width) {\n  var len = Math.max(0, width - str.length);\n  return str + Array(len + 1).join(' ');\n}\n\n/**\n * Output help information if necessary\n *\n * @param {Command} command to output help for\n * @param {Array} array of options to search for -h or --help\n * @api private\n */\n\nfunction outputHelpIfNecessary(cmd, options) {\n  options = options || [];\n  for (var i = 0; i < options.length; i++) {\n    if (options[i] == '--help' || options[i] == '-h') {\n      process.stdout.write(cmd.helpInformation());\n      cmd.emit('--help');\n      process.exit(0);\n    }\n  }\n}\n",
  "node_modules/mocha/node_modules/jade/node_modules/commander/package.json": "{\n  \"name\": \"commander\",\n  \"version\": \"0.6.1\",\n  \"description\": \"the complete solution for node.js command-line programs\",\n  \"keywords\": [\n    \"command\",\n    \"option\",\n    \"parser\",\n    \"prompt\",\n    \"stdin\"\n  ],\n  \"author\": {\n    \"name\": \"TJ Holowaychuk\",\n    \"email\": \"tj@vision-media.ca\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/visionmedia/commander.js.git\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"should\": \">= 0.0.1\"\n  },\n  \"scripts\": {\n    \"test\": \"make test\"\n  },\n  \"main\": \"index\",\n  \"engines\": {\n    \"node\": \">= 0.4.x\"\n  },\n  \"_npmUser\": {\n    \"name\": \"tjholowaychuk\",\n    \"email\": \"tj@vision-media.ca\"\n  },\n  \"_id\": \"commander@0.6.1\",\n  \"optionalDependencies\": {},\n  \"_engineSupported\": true,\n  \"_npmVersion\": \"1.1.0-3\",\n  \"_nodeVersion\": \"v0.6.12\",\n  \"_defaultsLoaded\": true,\n  \"dist\": {\n    \"shasum\": \"fa68a14f6a945d54dbbe50d8cdb3320e9e3b1a06\",\n    \"tarball\": \"http://registry.npmjs.org/commander/-/commander-0.6.1.tgz\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"tjholowaychuk\",\n      \"email\": \"tj@vision-media.ca\"\n    }\n  ],\n  \"directories\": {},\n  \"_shasum\": \"fa68a14f6a945d54dbbe50d8cdb3320e9e3b1a06\",\n  \"_resolved\": \"https://registry.npmjs.org/commander/-/commander-0.6.1.tgz\",\n  \"_from\": \"commander@0.6.1\",\n  \"bugs\": {\n    \"url\": \"https://github.com/visionmedia/commander.js/issues\"\n  },\n  \"readme\": \"ERROR: No README data found!\",\n  \"homepage\": \"https://github.com/visionmedia/commander.js#readme\"\n}\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/examples/pow.js": "var mkdirp = require('mkdirp');\n\nmkdirp('/tmp/foo/bar/baz', function (err) {\n    if (err) console.error(err)\n    else console.log('pow!')\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/index.js": "var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, mode, f) {\n    if (typeof mode === 'function' || mode === undefined) {\n        f = mode;\n        mode = 0777 & (~process.umask());\n    }\n    \n    var cb = f || function () {};\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    fs.mkdir(p, mode, function (er) {\n        if (!er) return cb();\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), mode, function (er) {\n                    if (er) cb(er);\n                    else mkdirP(p, mode, cb);\n                });\n                break;\n\n            case 'EEXIST':\n                fs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original EEXIST be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er)\n                    else cb();\n                });\n                break;\n\n            default:\n                cb(er);\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, mode) {\n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    \n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n    \n    try {\n        fs.mkdirSync(p, mode)\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                var err1 = sync(path.dirname(p), mode)\n                if (err1) throw err1;\n                else return sync(p, mode);\n                break;\n            \n            case 'EEXIST' :\n                var stat;\n                try {\n                    stat = fs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0\n                }\n                if (!stat.isDirectory()) throw err0;\n                else return null;\n                break;\n            default :\n                throw err0\n                break;\n        }\n    }\n    \n    return null;\n};\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/package.json": "{\n  \"name\": \"mkdirp\",\n  \"description\": \"Recursively mkdir, like `mkdir -p`\",\n  \"version\": \"0.3.0\",\n  \"author\": {\n    \"name\": \"James Halliday\",\n    \"email\": \"mail@substack.net\",\n    \"url\": \"http://substack.net\"\n  },\n  \"main\": \"./index\",\n  \"keywords\": [\n    \"mkdir\",\n    \"directory\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/substack/node-mkdirp.git\"\n  },\n  \"scripts\": {\n    \"test\": \"tap test/*.js\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"0.0.x\"\n  },\n  \"license\": \"MIT/X11\",\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"_npmUser\": {\n    \"name\": \"substack\",\n    \"email\": \"mail@substack.net\"\n  },\n  \"_id\": \"mkdirp@0.3.0\",\n  \"dependencies\": {},\n  \"_engineSupported\": true,\n  \"_npmVersion\": \"1.0.106\",\n  \"_nodeVersion\": \"v0.4.12\",\n  \"_defaultsLoaded\": true,\n  \"dist\": {\n    \"shasum\": \"1bbf5ab1ba827af23575143490426455f481fe1e\",\n    \"tarball\": \"http://registry.npmjs.org/mkdirp/-/mkdirp-0.3.0.tgz\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"substack\",\n      \"email\": \"mail@substack.net\"\n    }\n  ],\n  \"directories\": {},\n  \"_shasum\": \"1bbf5ab1ba827af23575143490426455f481fe1e\",\n  \"_resolved\": \"https://registry.npmjs.org/mkdirp/-/mkdirp-0.3.0.tgz\",\n  \"_from\": \"mkdirp@0.3.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/substack/node-mkdirp/issues\"\n  },\n  \"readme\": \"ERROR: No README data found!\",\n  \"homepage\": \"https://github.com/substack/node-mkdirp#readme\"\n}\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/chmod.js": "var mkdirp = require('../').mkdirp;\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\nvar ps = [ '', 'tmp' ];\n\nfor (var i = 0; i < 25; i++) {\n    var dir = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    ps.push(dir);\n}\n\nvar file = ps.join('/');\n\ntest('chmod-pre', function (t) {\n    var mode = 0744\n    mkdirp(file, mode, function (er) {\n        t.ifError(er, 'should not error');\n        fs.stat(file, function (er, stat) {\n            t.ifError(er, 'should exist');\n            t.ok(stat && stat.isDirectory(), 'should be directory');\n            t.equal(stat && stat.mode & 0777, mode, 'should be 0744');\n            t.end();\n        });\n    });\n});\n\ntest('chmod', function (t) {\n    var mode = 0755\n    mkdirp(file, mode, function (er) {\n        t.ifError(er, 'should not error');\n        fs.stat(file, function (er, stat) {\n            t.ifError(er, 'should exist');\n            t.ok(stat && stat.isDirectory(), 'should be directory');\n            t.end();\n        });\n    });\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/clobber.js": "var mkdirp = require('../').mkdirp;\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\nvar ps = [ '', 'tmp' ];\n\nfor (var i = 0; i < 25; i++) {\n    var dir = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    ps.push(dir);\n}\n\nvar file = ps.join('/');\n\n// a file in the way\nvar itw = ps.slice(0, 3).join('/');\n\n\ntest('clobber-pre', function (t) {\n    console.error(\"about to write to \"+itw)\n    fs.writeFileSync(itw, 'I AM IN THE WAY, THE TRUTH, AND THE LIGHT.');\n\n    fs.stat(itw, function (er, stat) {\n        t.ifError(er)\n        t.ok(stat && stat.isFile(), 'should be file')\n        t.end()\n    })\n})\n\ntest('clobber', function (t) {\n    t.plan(2);\n    mkdirp(file, 0755, function (err) {\n        t.ok(err);\n        t.equal(err.code, 'ENOTDIR');\n        t.end();\n    });\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/mkdirp.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('woo', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/tmp/' + [x,y,z].join('/');\n    \n    mkdirp(file, 0755, function (err) {\n        if (err) t.fail(err);\n        else path.exists(file, function (ex) {\n            if (!ex) t.fail('file not created')\n            else fs.stat(file, function (err, stat) {\n                if (err) t.fail(err)\n                else {\n                    t.equal(stat.mode & 0777, 0755);\n                    t.ok(stat.isDirectory(), 'target not a directory');\n                    t.end();\n                }\n            })\n        })\n    });\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/perm_sync.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('sync perm', function (t) {\n    t.plan(2);\n    var file = '/tmp/' + (Math.random() * (1<<30)).toString(16) + '.json';\n    \n    mkdirp.sync(file, 0755);\n    path.exists(file, function (ex) {\n        if (!ex) t.fail('file not created')\n        else fs.stat(file, function (err, stat) {\n            if (err) t.fail(err)\n            else {\n                t.equal(stat.mode & 0777, 0755);\n                t.ok(stat.isDirectory(), 'target not a directory');\n                t.end();\n            }\n        })\n    });\n});\n\ntest('sync root perm', function (t) {\n    t.plan(1);\n    \n    var file = '/tmp';\n    mkdirp.sync(file, 0755);\n    path.exists(file, function (ex) {\n        if (!ex) t.fail('file not created')\n        else fs.stat(file, function (err, stat) {\n            if (err) t.fail(err)\n            else {\n                t.ok(stat.isDirectory(), 'target not a directory');\n                t.end();\n            }\n        })\n    });\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/perm.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('async perm', function (t) {\n    t.plan(2);\n    var file = '/tmp/' + (Math.random() * (1<<30)).toString(16);\n    \n    mkdirp(file, 0755, function (err) {\n        if (err) t.fail(err);\n        else path.exists(file, function (ex) {\n            if (!ex) t.fail('file not created')\n            else fs.stat(file, function (err, stat) {\n                if (err) t.fail(err)\n                else {\n                    t.equal(stat.mode & 0777, 0755);\n                    t.ok(stat.isDirectory(), 'target not a directory');\n                    t.end();\n                }\n            })\n        })\n    });\n});\n\ntest('async root perm', function (t) {\n    mkdirp('/tmp', 0755, function (err) {\n        if (err) t.fail(err);\n        t.end();\n    });\n    t.end();\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/race.js": "var mkdirp = require('../').mkdirp;\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('race', function (t) {\n    t.plan(4);\n    var ps = [ '', 'tmp' ];\n    \n    for (var i = 0; i < 25; i++) {\n        var dir = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n        ps.push(dir);\n    }\n    var file = ps.join('/');\n    \n    var res = 2;\n    mk(file, function () {\n        if (--res === 0) t.end();\n    });\n    \n    mk(file, function () {\n        if (--res === 0) t.end();\n    });\n    \n    function mk (file, cb) {\n        mkdirp(file, 0755, function (err) {\n            if (err) t.fail(err);\n            else path.exists(file, function (ex) {\n                if (!ex) t.fail('file not created')\n                else fs.stat(file, function (err, stat) {\n                    if (err) t.fail(err)\n                    else {\n                        t.equal(stat.mode & 0777, 0755);\n                        t.ok(stat.isDirectory(), 'target not a directory');\n                        if (cb) cb();\n                    }\n                })\n            })\n        });\n    }\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/rel.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('rel', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var cwd = process.cwd();\n    process.chdir('/tmp');\n    \n    var file = [x,y,z].join('/');\n    \n    mkdirp(file, 0755, function (err) {\n        if (err) t.fail(err);\n        else path.exists(file, function (ex) {\n            if (!ex) t.fail('file not created')\n            else fs.stat(file, function (err, stat) {\n                if (err) t.fail(err)\n                else {\n                    process.chdir(cwd);\n                    t.equal(stat.mode & 0777, 0755);\n                    t.ok(stat.isDirectory(), 'target not a directory');\n                    t.end();\n                }\n            })\n        })\n    });\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/sync.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('sync', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/tmp/' + [x,y,z].join('/');\n    \n    var err = mkdirp.sync(file, 0755);\n    if (err) t.fail(err);\n    else path.exists(file, function (ex) {\n        if (!ex) t.fail('file not created')\n        else fs.stat(file, function (err, stat) {\n            if (err) t.fail(err)\n            else {\n                t.equal(stat.mode & 0777, 0755);\n                t.ok(stat.isDirectory(), 'target not a directory');\n                t.end();\n            }\n        })\n    })\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/umask_sync.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('umask sync modes', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/tmp/' + [x,y,z].join('/');\n    \n    var err = mkdirp.sync(file);\n    if (err) t.fail(err);\n    else path.exists(file, function (ex) {\n        if (!ex) t.fail('file not created')\n        else fs.stat(file, function (err, stat) {\n            if (err) t.fail(err)\n            else {\n                t.equal(stat.mode & 0777, (0777 & (~process.umask())));\n                t.ok(stat.isDirectory(), 'target not a directory');\n                t.end();\n            }\n        })\n    })\n});\n",
  "node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/umask.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('implicit mode from umask', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/tmp/' + [x,y,z].join('/');\n    \n    mkdirp(file, function (err) {\n        if (err) t.fail(err);\n        else path.exists(file, function (ex) {\n            if (!ex) t.fail('file not created')\n            else fs.stat(file, function (err, stat) {\n                if (err) t.fail(err)\n                else {\n                    t.equal(stat.mode & 0777, 0777 & (~process.umask()));\n                    t.ok(stat.isDirectory(), 'target not a directory');\n                    t.end();\n                }\n            })\n        })\n    });\n});\n",
  "node_modules/mocha/node_modules/jade/package.json": "{\n  \"name\": \"jade\",\n  \"description\": \"Jade template engine\",\n  \"version\": \"0.26.3\",\n  \"author\": {\n    \"name\": \"TJ Holowaychuk\",\n    \"email\": \"tj@vision-media.ca\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/visionmedia/jade.git\"\n  },\n  \"main\": \"./index.js\",\n  \"bin\": {\n    \"jade\": \"./bin/jade\"\n  },\n  \"man\": [\n    \"./jade.1\"\n  ],\n  \"dependencies\": {\n    \"commander\": \"0.6.1\",\n    \"mkdirp\": \"0.3.0\"\n  },\n  \"devDependencies\": {\n    \"mocha\": \"*\",\n    \"markdown\": \"*\",\n    \"stylus\": \"*\",\n    \"uubench\": \"*\",\n    \"should\": \"*\",\n    \"less\": \"*\",\n    \"uglify-js\": \"*\"\n  },\n  \"component\": {\n    \"scripts\": {\n      \"jade\": \"runtime.js\"\n    }\n  },\n  \"scripts\": {\n    \"prepublish\": \"npm prune\"\n  },\n  \"_id\": \"jade@0.26.3\",\n  \"dist\": {\n    \"shasum\": \"8f10d7977d8d79f2f6ff862a81b0513ccb25686c\",\n    \"tarball\": \"http://registry.npmjs.org/jade/-/jade-0.26.3.tgz\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"tjholowaychuk\",\n      \"email\": \"tj@vision-media.ca\"\n    }\n  ],\n  \"directories\": {},\n  \"_shasum\": \"8f10d7977d8d79f2f6ff862a81b0513ccb25686c\",\n  \"_resolved\": \"https://registry.npmjs.org/jade/-/jade-0.26.3.tgz\",\n  \"_from\": \"jade@0.26.3\",\n  \"bugs\": {\n    \"url\": \"https://github.com/visionmedia/jade/issues\"\n  },\n  \"readme\": \"ERROR: No README data found!\",\n  \"homepage\": \"https://github.com/visionmedia/jade#readme\"\n}\n",
  "node_modules/mocha/node_modules/jade/runtime.js": "\njade = (function(exports){\n/*!\n * Jade - runtime\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Lame Array.isArray() polyfill for now.\n */\n\nif (!Array.isArray) {\n  Array.isArray = function(arr){\n    return '[object Array]' == Object.prototype.toString.call(arr);\n  };\n}\n\n/**\n * Lame Object.keys() polyfill for now.\n */\n\nif (!Object.keys) {\n  Object.keys = function(obj){\n    var arr = [];\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        arr.push(key);\n      }\n    }\n    return arr;\n  }\n}\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    ac = ac.filter(nulls);\n    bc = bc.filter(nulls);\n    a['class'] = ac.concat(bc).join(' ');\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null;\n}\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n * @api private\n */\n\nexports.attrs = function attrs(obj, escaped){\n  var buf = []\n    , terse = obj.terse;\n\n  delete obj.terse;\n  var keys = Object.keys(obj)\n    , len = keys.length;\n\n  if (len) {\n    buf.push('');\n    for (var i = 0; i < len; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('boolean' == typeof val || null == val) {\n        if (val) {\n          terse\n            ? buf.push(key)\n            : buf.push(key + '=\"' + key + '\"');\n        }\n      } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n        buf.push(key + \"='\" + JSON.stringify(val) + \"'\");\n      } else if ('class' == key && Array.isArray(val)) {\n        buf.push(key + '=\"' + exports.escape(val.join(' ')) + '\"');\n      } else if (escaped && escaped[key]) {\n        buf.push(key + '=\"' + exports.escape(val) + '\"');\n      } else {\n        buf.push(key + '=\"' + val + '\"');\n      }\n    }\n  }\n\n  return buf.join(' ');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function escape(html){\n  return String(html)\n    .replace(/&(?!(\\w+|\\#\\d+);)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno){\n  if (!filename) throw err;\n\n  var context = 3\n    , str = require('fs').readFileSync(filename, 'utf8')\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n\n  return exports;\n\n})({});\n",
  "node_modules/mocha/node_modules/jade/runtime.min.js": "jade=function(exports){Array.isArray||(Array.isArray=function(arr){return\"[object Array]\"==Object.prototype.toString.call(arr)}),Object.keys||(Object.keys=function(obj){var arr=[];for(var key in obj)obj.hasOwnProperty(key)&&arr.push(key);return arr}),exports.merge=function merge(a,b){var ac=a[\"class\"],bc=b[\"class\"];if(ac||bc)ac=ac||[],bc=bc||[],Array.isArray(ac)||(ac=[ac]),Array.isArray(bc)||(bc=[bc]),ac=ac.filter(nulls),bc=bc.filter(nulls),a[\"class\"]=ac.concat(bc).join(\" \");for(var key in b)key!=\"class\"&&(a[key]=b[key]);return a};function nulls(val){return val!=null}return exports.attrs=function attrs(obj,escaped){var buf=[],terse=obj.terse;delete obj.terse;var keys=Object.keys(obj),len=keys.length;if(len){buf.push(\"\");for(var i=0;i<len;++i){var key=keys[i],val=obj[key];\"boolean\"==typeof val||null==val?val&&(terse?buf.push(key):buf.push(key+'=\"'+key+'\"')):0==key.indexOf(\"data\")&&\"string\"!=typeof val?buf.push(key+\"='\"+JSON.stringify(val)+\"'\"):\"class\"==key&&Array.isArray(val)?buf.push(key+'=\"'+exports.escape(val.join(\" \"))+'\"'):escaped&&escaped[key]?buf.push(key+'=\"'+exports.escape(val)+'\"'):buf.push(key+'=\"'+val+'\"')}}return buf.join(\" \")},exports.escape=function escape(html){return String(html).replace(/&(?!(\\w+|\\#\\d+);)/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\").replace(/\"/g,\"&quot;\")},exports.rethrow=function rethrow(err,filename,lineno){if(!filename)throw err;var context=3,str=require(\"fs\").readFileSync(filename,\"utf8\"),lines=str.split(\"\\n\"),start=Math.max(lineno-context,0),end=Math.min(lines.length,lineno+context),context=lines.slice(start,end).map(function(line,i){var curr=i+start+1;return(curr==lineno?\"  > \":\"    \")+curr+\"| \"+line}).join(\"\\n\");throw err.path=filename,err.message=(filename||\"Jade\")+\":\"+lineno+\"\\n\"+context+\"\\n\\n\"+err.message,err},exports}({});",
  "node_modules/mocha/node_modules/jade/testing/index.js": "\n/**\n * Module dependencies.\n */\n\nvar jade = require('../');\n\njade.renderFile('testing/index.jade', { pretty: true, debug: true, compileDebug: false }, function(err, str){\n  if (err) throw err;\n  console.log(str);\n});",
  "node_modules/mocha/node_modules/jade/testing/user.js": "function anonymous(locals, attrs, escape, rethrow) {\nvar attrs = jade.attrs, escape = jade.escape, rethrow = jade.rethrow;\nvar __jade = [{ lineno: 1, filename: \"testing/user.jade\" }];\ntry {\nvar buf = [];\nwith (locals || {}) {\nvar interp;\n__jade.unshift({ lineno: 1, filename: __jade[0].filename });\n__jade.unshift({ lineno: 1, filename: __jade[0].filename });\nbuf.push('<h1>Tobi');\n__jade.unshift({ lineno: undefined, filename: __jade[0].filename });\n__jade.shift();\nbuf.push('</h1>');\n__jade.shift();\n__jade.unshift({ lineno: 2, filename: __jade[0].filename });\nbuf.push('<p>Is a ferret');\n__jade.unshift({ lineno: undefined, filename: __jade[0].filename });\n__jade.shift();\nbuf.push('</p>');\n__jade.shift();\n__jade.shift();\n}\nreturn buf.join(\"\");\n} catch (err) {\n  rethrow(err, __jade[0].filename, __jade[0].lineno);\n}\n}",
  "node_modules/mocha/node_modules/mkdirp/bin/cmd.js": "#!/usr/bin/env node\n\nvar mkdirp = require('../');\nvar minimist = require('minimist');\nvar fs = require('fs');\n\nvar argv = minimist(process.argv.slice(2), {\n    alias: { m: 'mode', h: 'help' },\n    string: [ 'mode' ]\n});\nif (argv.help) {\n    fs.createReadStream(__dirname + '/usage.txt').pipe(process.stdout);\n    return;\n}\n\nvar paths = argv._.slice();\nvar mode = argv.mode ? parseInt(argv.mode, 8) : undefined;\n\n(function next () {\n    if (paths.length === 0) return;\n    var p = paths.shift();\n    \n    if (mode === undefined) mkdirp(p, cb)\n    else mkdirp(p, mode, cb)\n    \n    function cb (err) {\n        if (err) {\n            console.error(err.message);\n            process.exit(1);\n        }\n        else next();\n    }\n})();\n",
  "node_modules/mocha/node_modules/mkdirp/examples/pow.js": "var mkdirp = require('mkdirp');\n\nmkdirp('/tmp/foo/bar/baz', function (err) {\n    if (err) console.error(err)\n    else console.log('pow!')\n});\n",
  "node_modules/mocha/node_modules/mkdirp/index.js": "var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/example/parse.js": "var argv = require('../')(process.argv.slice(2));\nconsole.dir(argv);\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/index.js": "module.exports = function (args, opts) {\n    if (!opts) opts = {};\n    \n    var flags = { bools : {}, strings : {} };\n    \n    [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {\n        flags.bools[key] = true;\n    });\n    \n    [].concat(opts.string).filter(Boolean).forEach(function (key) {\n        flags.strings[key] = true;\n    });\n    \n    var aliases = {};\n    Object.keys(opts.alias || {}).forEach(function (key) {\n        aliases[key] = [].concat(opts.alias[key]);\n        aliases[key].forEach(function (x) {\n            aliases[x] = [key].concat(aliases[key].filter(function (y) {\n                return x !== y;\n            }));\n        });\n    });\n    \n    var defaults = opts['default'] || {};\n    \n    var argv = { _ : [] };\n    Object.keys(flags.bools).forEach(function (key) {\n        setArg(key, defaults[key] === undefined ? false : defaults[key]);\n    });\n    \n    var notFlags = [];\n\n    if (args.indexOf('--') !== -1) {\n        notFlags = args.slice(args.indexOf('--')+1);\n        args = args.slice(0, args.indexOf('--'));\n    }\n\n    function setArg (key, val) {\n        var value = !flags.strings[key] && isNumber(val)\n            ? Number(val) : val\n        ;\n        setKey(argv, key.split('.'), value);\n        \n        (aliases[key] || []).forEach(function (x) {\n            setKey(argv, x.split('.'), value);\n        });\n    }\n    \n    for (var i = 0; i < args.length; i++) {\n        var arg = args[i];\n        \n        if (/^--.+=/.test(arg)) {\n            // Using [\\s\\S] instead of . because js doesn't support the\n            // 'dotall' regex modifier. See:\n            // http://stackoverflow.com/a/1068308/13216\n            var m = arg.match(/^--([^=]+)=([\\s\\S]*)$/);\n            setArg(m[1], m[2]);\n        }\n        else if (/^--no-.+/.test(arg)) {\n            var key = arg.match(/^--no-(.+)/)[1];\n            setArg(key, false);\n        }\n        else if (/^--.+/.test(arg)) {\n            var key = arg.match(/^--(.+)/)[1];\n            var next = args[i + 1];\n            if (next !== undefined && !/^-/.test(next)\n            && !flags.bools[key]\n            && (aliases[key] ? !flags.bools[aliases[key]] : true)) {\n                setArg(key, next);\n                i++;\n            }\n            else if (/^(true|false)$/.test(next)) {\n                setArg(key, next === 'true');\n                i++;\n            }\n            else {\n                setArg(key, flags.strings[key] ? '' : true);\n            }\n        }\n        else if (/^-[^-]+/.test(arg)) {\n            var letters = arg.slice(1,-1).split('');\n            \n            var broken = false;\n            for (var j = 0; j < letters.length; j++) {\n                var next = arg.slice(j+2);\n                \n                if (next === '-') {\n                    setArg(letters[j], next)\n                    continue;\n                }\n                \n                if (/[A-Za-z]/.test(letters[j])\n                && /-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n                    setArg(letters[j], next);\n                    broken = true;\n                    break;\n                }\n                \n                if (letters[j+1] && letters[j+1].match(/\\W/)) {\n                    setArg(letters[j], arg.slice(j+2));\n                    broken = true;\n                    break;\n                }\n                else {\n                    setArg(letters[j], flags.strings[letters[j]] ? '' : true);\n                }\n            }\n            \n            var key = arg.slice(-1)[0];\n            if (!broken && key !== '-') {\n                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])\n                && !flags.bools[key]\n                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {\n                    setArg(key, args[i+1]);\n                    i++;\n                }\n                else if (args[i+1] && /true|false/.test(args[i+1])) {\n                    setArg(key, args[i+1] === 'true');\n                    i++;\n                }\n                else {\n                    setArg(key, flags.strings[key] ? '' : true);\n                }\n            }\n        }\n        else {\n            argv._.push(\n                flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)\n            );\n        }\n    }\n    \n    Object.keys(defaults).forEach(function (key) {\n        if (!hasKey(argv, key.split('.'))) {\n            setKey(argv, key.split('.'), defaults[key]);\n            \n            (aliases[key] || []).forEach(function (x) {\n                setKey(argv, x.split('.'), defaults[key]);\n            });\n        }\n    });\n    \n    notFlags.forEach(function(key) {\n        argv._.push(key);\n    });\n\n    return argv;\n};\n\nfunction hasKey (obj, keys) {\n    var o = obj;\n    keys.slice(0,-1).forEach(function (key) {\n        o = (o[key] || {});\n    });\n\n    var key = keys[keys.length - 1];\n    return key in o;\n}\n\nfunction setKey (obj, keys, value) {\n    var o = obj;\n    keys.slice(0,-1).forEach(function (key) {\n        if (o[key] === undefined) o[key] = {};\n        o = o[key];\n    });\n    \n    var key = keys[keys.length - 1];\n    if (o[key] === undefined || typeof o[key] === 'boolean') {\n        o[key] = value;\n    }\n    else if (Array.isArray(o[key])) {\n        o[key].push(value);\n    }\n    else {\n        o[key] = [ o[key], value ];\n    }\n}\n\nfunction isNumber (x) {\n    if (typeof x === 'number') return true;\n    if (/^0x[0-9a-f]+$/i.test(x)) return true;\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\n\nfunction longest (xs) {\n    return Math.max.apply(null, xs.map(function (x) { return x.length }));\n}\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/package.json": "{\n  \"name\": \"minimist\",\n  \"version\": \"0.0.8\",\n  \"description\": \"parse argument options\",\n  \"main\": \"index.js\",\n  \"devDependencies\": {\n    \"tape\": \"~1.0.4\",\n    \"tap\": \"~0.4.0\"\n  },\n  \"scripts\": {\n    \"test\": \"tap test/*.js\"\n  },\n  \"testling\": {\n    \"files\": \"test/*.js\",\n    \"browsers\": [\n      \"ie/6..latest\",\n      \"ff/5\",\n      \"firefox/latest\",\n      \"chrome/10\",\n      \"chrome/latest\",\n      \"safari/5.1\",\n      \"safari/latest\",\n      \"opera/12\"\n    ]\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/substack/minimist.git\"\n  },\n  \"homepage\": \"https://github.com/substack/minimist\",\n  \"keywords\": [\n    \"argv\",\n    \"getopt\",\n    \"parser\",\n    \"optimist\"\n  ],\n  \"author\": {\n    \"name\": \"James Halliday\",\n    \"email\": \"mail@substack.net\",\n    \"url\": \"http://substack.net\"\n  },\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/substack/minimist/issues\"\n  },\n  \"_id\": \"minimist@0.0.8\",\n  \"dist\": {\n    \"shasum\": \"857fcabfc3397d2625b8228262e86aa7a011b05d\",\n    \"tarball\": \"http://registry.npmjs.org/minimist/-/minimist-0.0.8.tgz\"\n  },\n  \"_from\": \"minimist@0.0.8\",\n  \"_npmVersion\": \"1.4.3\",\n  \"_npmUser\": {\n    \"name\": \"substack\",\n    \"email\": \"mail@substack.net\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"substack\",\n      \"email\": \"mail@substack.net\"\n    }\n  ],\n  \"directories\": {},\n  \"_shasum\": \"857fcabfc3397d2625b8228262e86aa7a011b05d\",\n  \"_resolved\": \"https://registry.npmjs.org/minimist/-/minimist-0.0.8.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/test/dash.js": "var parse = require('../');\nvar test = require('tape');\n\ntest('-', function (t) {\n    t.plan(5);\n    t.deepEqual(parse([ '-n', '-' ]), { n: '-', _: [] });\n    t.deepEqual(parse([ '-' ]), { _: [ '-' ] });\n    t.deepEqual(parse([ '-f-' ]), { f: '-', _: [] });\n    t.deepEqual(\n        parse([ '-b', '-' ], { boolean: 'b' }),\n        { b: true, _: [ '-' ] }\n    );\n    t.deepEqual(\n        parse([ '-s', '-' ], { string: 's' }),\n        { s: '-', _: [] }\n    );\n});\n\ntest('-a -- b', function (t) {\n    t.plan(3);\n    t.deepEqual(parse([ '-a', '--', 'b' ]), { a: true, _: [ 'b' ] });\n    t.deepEqual(parse([ '--a', '--', 'b' ]), { a: true, _: [ 'b' ] });\n    t.deepEqual(parse([ '--a', '--', 'b' ]), { a: true, _: [ 'b' ] });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/test/default_bool.js": "var test = require('tape');\nvar parse = require('../');\n\ntest('boolean default true', function (t) {\n    var argv = parse([], {\n        boolean: 'sometrue',\n        default: { sometrue: true }\n    });\n    t.equal(argv.sometrue, true);\n    t.end();\n});\n\ntest('boolean default false', function (t) {\n    var argv = parse([], {\n        boolean: 'somefalse',\n        default: { somefalse: false }\n    });\n    t.equal(argv.somefalse, false);\n    t.end();\n});\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/test/dotted.js": "var parse = require('../');\nvar test = require('tape');\n\ntest('dotted alias', function (t) {\n    var argv = parse(['--a.b', '22'], {default: {'a.b': 11}, alias: {'a.b': 'aa.bb'}});\n    t.equal(argv.a.b, 22);\n    t.equal(argv.aa.bb, 22);\n    t.end();\n});\n\ntest('dotted default', function (t) {\n    var argv = parse('', {default: {'a.b': 11}, alias: {'a.b': 'aa.bb'}});\n    t.equal(argv.a.b, 11);\n    t.equal(argv.aa.bb, 11);\n    t.end();\n});\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/test/long.js": "var test = require('tape');\nvar parse = require('../');\n\ntest('long opts', function (t) {\n    t.deepEqual(\n        parse([ '--bool' ]),\n        { bool : true, _ : [] },\n        'long boolean'\n    );\n    t.deepEqual(\n        parse([ '--pow', 'xixxle' ]),\n        { pow : 'xixxle', _ : [] },\n        'long capture sp'\n    );\n    t.deepEqual(\n        parse([ '--pow=xixxle' ]),\n        { pow : 'xixxle', _ : [] },\n        'long capture eq'\n    );\n    t.deepEqual(\n        parse([ '--host', 'localhost', '--port', '555' ]),\n        { host : 'localhost', port : 555, _ : [] },\n        'long captures sp'\n    );\n    t.deepEqual(\n        parse([ '--host=localhost', '--port=555' ]),\n        { host : 'localhost', port : 555, _ : [] },\n        'long captures eq'\n    );\n    t.end();\n});\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/test/parse_modified.js": "var parse = require('../');\nvar test = require('tape');\n\ntest('parse with modifier functions' , function (t) {\n    t.plan(1);\n    \n    var argv = parse([ '-b', '123' ], { boolean: 'b' });\n    t.deepEqual(argv, { b: true, _: ['123'] });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/test/parse.js": "var parse = require('../');\nvar test = require('tape');\n\ntest('parse args', function (t) {\n    t.deepEqual(\n        parse([ '--no-moo' ]),\n        { moo : false, _ : [] },\n        'no'\n    );\n    t.deepEqual(\n        parse([ '-v', 'a', '-v', 'b', '-v', 'c' ]),\n        { v : ['a','b','c'], _ : [] },\n        'multi'\n    );\n    t.end();\n});\n \ntest('comprehensive', function (t) {\n    t.deepEqual(\n        parse([\n            '--name=meowmers', 'bare', '-cats', 'woo',\n            '-h', 'awesome', '--multi=quux',\n            '--key', 'value',\n            '-b', '--bool', '--no-meep', '--multi=baz',\n            '--', '--not-a-flag', 'eek'\n        ]),\n        {\n            c : true,\n            a : true,\n            t : true,\n            s : 'woo',\n            h : 'awesome',\n            b : true,\n            bool : true,\n            key : 'value',\n            multi : [ 'quux', 'baz' ],\n            meep : false,\n            name : 'meowmers',\n            _ : [ 'bare', '--not-a-flag', 'eek' ]\n        }\n    );\n    t.end();\n});\n\ntest('nums', function (t) {\n    var argv = parse([\n        '-x', '1234',\n        '-y', '5.67',\n        '-z', '1e7',\n        '-w', '10f',\n        '--hex', '0xdeadbeef',\n        '789'\n    ]);\n    t.deepEqual(argv, {\n        x : 1234,\n        y : 5.67,\n        z : 1e7,\n        w : '10f',\n        hex : 0xdeadbeef,\n        _ : [ 789 ]\n    });\n    t.deepEqual(typeof argv.x, 'number');\n    t.deepEqual(typeof argv.y, 'number');\n    t.deepEqual(typeof argv.z, 'number');\n    t.deepEqual(typeof argv.w, 'string');\n    t.deepEqual(typeof argv.hex, 'number');\n    t.deepEqual(typeof argv._[0], 'number');\n    t.end();\n});\n\ntest('flag boolean', function (t) {\n    var argv = parse([ '-t', 'moo' ], { boolean: 't' });\n    t.deepEqual(argv, { t : true, _ : [ 'moo' ] });\n    t.deepEqual(typeof argv.t, 'boolean');\n    t.end();\n});\n\ntest('flag boolean value', function (t) {\n    var argv = parse(['--verbose', 'false', 'moo', '-t', 'true'], {\n        boolean: [ 't', 'verbose' ],\n        default: { verbose: true }\n    });\n    \n    t.deepEqual(argv, {\n        verbose: false,\n        t: true,\n        _: ['moo']\n    });\n    \n    t.deepEqual(typeof argv.verbose, 'boolean');\n    t.deepEqual(typeof argv.t, 'boolean');\n    t.end();\n});\n\ntest('flag boolean default false', function (t) {\n    var argv = parse(['moo'], {\n        boolean: ['t', 'verbose'],\n        default: { verbose: false, t: false }\n    });\n    \n    t.deepEqual(argv, {\n        verbose: false,\n        t: false,\n        _: ['moo']\n    });\n    \n    t.deepEqual(typeof argv.verbose, 'boolean');\n    t.deepEqual(typeof argv.t, 'boolean');\n    t.end();\n\n});\n\ntest('boolean groups', function (t) {\n    var argv = parse([ '-x', '-z', 'one', 'two', 'three' ], {\n        boolean: ['x','y','z']\n    });\n    \n    t.deepEqual(argv, {\n        x : true,\n        y : false,\n        z : true,\n        _ : [ 'one', 'two', 'three' ]\n    });\n    \n    t.deepEqual(typeof argv.x, 'boolean');\n    t.deepEqual(typeof argv.y, 'boolean');\n    t.deepEqual(typeof argv.z, 'boolean');\n    t.end();\n});\n\ntest('newlines in params' , function (t) {\n    var args = parse([ '-s', \"X\\nX\" ])\n    t.deepEqual(args, { _ : [], s : \"X\\nX\" });\n    \n    // reproduce in bash:\n    // VALUE=\"new\n    // line\"\n    // node program.js --s=\"$VALUE\"\n    args = parse([ \"--s=X\\nX\" ])\n    t.deepEqual(args, { _ : [], s : \"X\\nX\" });\n    t.end();\n});\n\ntest('strings' , function (t) {\n    var s = parse([ '-s', '0001234' ], { string: 's' }).s;\n    t.equal(s, '0001234');\n    t.equal(typeof s, 'string');\n    \n    var x = parse([ '-x', '56' ], { string: 'x' }).x;\n    t.equal(x, '56');\n    t.equal(typeof x, 'string');\n    t.end();\n});\n\ntest('stringArgs', function (t) {\n    var s = parse([ '  ', '  ' ], { string: '_' })._;\n    t.same(s.length, 2);\n    t.same(typeof s[0], 'string');\n    t.same(s[0], '  ');\n    t.same(typeof s[1], 'string');\n    t.same(s[1], '  ');\n    t.end();\n});\n\ntest('empty strings', function(t) {\n    var s = parse([ '-s' ], { string: 's' }).s;\n    t.equal(s, '');\n    t.equal(typeof s, 'string');\n\n    var str = parse([ '--str' ], { string: 'str' }).str;\n    t.equal(str, '');\n    t.equal(typeof str, 'string');\n\n    var letters = parse([ '-art' ], {\n        string: [ 'a', 't' ]\n    });\n\n    t.equal(letters.a, '');\n    t.equal(letters.r, true);\n    t.equal(letters.t, '');\n\n    t.end();\n});\n\n\ntest('slashBreak', function (t) {\n    t.same(\n        parse([ '-I/foo/bar/baz' ]),\n        { I : '/foo/bar/baz', _ : [] }\n    );\n    t.same(\n        parse([ '-xyz/foo/bar/baz' ]),\n        { x : true, y : true, z : '/foo/bar/baz', _ : [] }\n    );\n    t.end();\n});\n\ntest('alias', function (t) {\n    var argv = parse([ '-f', '11', '--zoom', '55' ], {\n        alias: { z: 'zoom' }\n    });\n    t.equal(argv.zoom, 55);\n    t.equal(argv.z, argv.zoom);\n    t.equal(argv.f, 11);\n    t.end();\n});\n\ntest('multiAlias', function (t) {\n    var argv = parse([ '-f', '11', '--zoom', '55' ], {\n        alias: { z: [ 'zm', 'zoom' ] }\n    });\n    t.equal(argv.zoom, 55);\n    t.equal(argv.z, argv.zoom);\n    t.equal(argv.z, argv.zm);\n    t.equal(argv.f, 11);\n    t.end();\n});\n\ntest('nested dotted objects', function (t) {\n    var argv = parse([\n        '--foo.bar', '3', '--foo.baz', '4',\n        '--foo.quux.quibble', '5', '--foo.quux.o_O',\n        '--beep.boop'\n    ]);\n    \n    t.same(argv.foo, {\n        bar : 3,\n        baz : 4,\n        quux : {\n            quibble : 5,\n            o_O : true\n        }\n    });\n    t.same(argv.beep, { boop : true });\n    t.end();\n});\n\ntest('boolean and alias with chainable api', function (t) {\n    var aliased = [ '-h', 'derp' ];\n    var regular = [ '--herp',  'derp' ];\n    var opts = {\n        herp: { alias: 'h', boolean: true }\n    };\n    var aliasedArgv = parse(aliased, {\n        boolean: 'herp',\n        alias: { h: 'herp' }\n    });\n    var propertyArgv = parse(regular, {\n        boolean: 'herp',\n        alias: { h: 'herp' }\n    });\n    var expected = {\n        herp: true,\n        h: true,\n        '_': [ 'derp' ]\n    };\n    \n    t.same(aliasedArgv, expected);\n    t.same(propertyArgv, expected); \n    t.end();\n});\n\ntest('boolean and alias with options hash', function (t) {\n    var aliased = [ '-h', 'derp' ];\n    var regular = [ '--herp', 'derp' ];\n    var opts = {\n        alias: { 'h': 'herp' },\n        boolean: 'herp'\n    };\n    var aliasedArgv = parse(aliased, opts);\n    var propertyArgv = parse(regular, opts);\n    var expected = {\n        herp: true,\n        h: true,\n        '_': [ 'derp' ]\n    };\n    t.same(aliasedArgv, expected);\n    t.same(propertyArgv, expected);\n    t.end();\n});\n\ntest('boolean and alias using explicit true', function (t) {\n    var aliased = [ '-h', 'true' ];\n    var regular = [ '--herp',  'true' ];\n    var opts = {\n        alias: { h: 'herp' },\n        boolean: 'h'\n    };\n    var aliasedArgv = parse(aliased, opts);\n    var propertyArgv = parse(regular, opts);\n    var expected = {\n        herp: true,\n        h: true,\n        '_': [ ]\n    };\n\n    t.same(aliasedArgv, expected);\n    t.same(propertyArgv, expected); \n    t.end();\n});\n\n// regression, see https://github.com/substack/node-optimist/issues/71\ntest('boolean and --x=true', function(t) {\n    var parsed = parse(['--boool', '--other=true'], {\n        boolean: 'boool'\n    });\n\n    t.same(parsed.boool, true);\n    t.same(parsed.other, 'true');\n\n    parsed = parse(['--boool', '--other=false'], {\n        boolean: 'boool'\n    });\n    \n    t.same(parsed.boool, true);\n    t.same(parsed.other, 'false');\n    t.end();\n});\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/test/short.js": "var parse = require('../');\nvar test = require('tape');\n\ntest('numeric short args', function (t) {\n    t.plan(2);\n    t.deepEqual(parse([ '-n123' ]), { n: 123, _: [] });\n    t.deepEqual(\n        parse([ '-123', '456' ]),\n        { 1: true, 2: true, 3: 456, _: [] }\n    );\n});\n\ntest('short', function (t) {\n    t.deepEqual(\n        parse([ '-b' ]),\n        { b : true, _ : [] },\n        'short boolean'\n    );\n    t.deepEqual(\n        parse([ 'foo', 'bar', 'baz' ]),\n        { _ : [ 'foo', 'bar', 'baz' ] },\n        'bare'\n    );\n    t.deepEqual(\n        parse([ '-cats' ]),\n        { c : true, a : true, t : true, s : true, _ : [] },\n        'group'\n    );\n    t.deepEqual(\n        parse([ '-cats', 'meow' ]),\n        { c : true, a : true, t : true, s : 'meow', _ : [] },\n        'short group next'\n    );\n    t.deepEqual(\n        parse([ '-h', 'localhost' ]),\n        { h : 'localhost', _ : [] },\n        'short capture'\n    );\n    t.deepEqual(\n        parse([ '-h', 'localhost', '-p', '555' ]),\n        { h : 'localhost', p : 555, _ : [] },\n        'short captures'\n    );\n    t.end();\n});\n \ntest('mixed short bool and capture', function (t) {\n    t.same(\n        parse([ '-h', 'localhost', '-fp', '555', 'script.js' ]),\n        {\n            f : true, p : 555, h : 'localhost',\n            _ : [ 'script.js' ]\n        }\n    );\n    t.end();\n});\n \ntest('short and long', function (t) {\n    t.deepEqual(\n        parse([ '-h', 'localhost', '-fp', '555', 'script.js' ]),\n        {\n            f : true, p : 555, h : 'localhost',\n            _ : [ 'script.js' ]\n        }\n    );\n    t.end();\n});\n",
  "node_modules/mocha/node_modules/mkdirp/node_modules/minimist/test/whitespace.js": "var parse = require('../');\nvar test = require('tape');\n\ntest('whitespace should be whitespace' , function (t) {\n    t.plan(1);\n    var x = parse([ '-x', '\\t' ]).x;\n    t.equal(x, '\\t');\n});\n",
  "node_modules/mocha/node_modules/mkdirp/package.json": "{\n  \"name\": \"mkdirp\",\n  \"description\": \"Recursively mkdir, like `mkdir -p`\",\n  \"version\": \"0.5.0\",\n  \"author\": {\n    \"name\": \"James Halliday\",\n    \"email\": \"mail@substack.net\",\n    \"url\": \"http://substack.net\"\n  },\n  \"main\": \"./index\",\n  \"keywords\": [\n    \"mkdir\",\n    \"directory\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/substack/node-mkdirp.git\"\n  },\n  \"scripts\": {\n    \"test\": \"tap test/*.js\"\n  },\n  \"dependencies\": {\n    \"minimist\": \"0.0.8\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"~0.4.0\",\n    \"mock-fs\": \"~2.2.0\"\n  },\n  \"bin\": {\n    \"mkdirp\": \"bin/cmd.js\"\n  },\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/substack/node-mkdirp/issues\"\n  },\n  \"homepage\": \"https://github.com/substack/node-mkdirp\",\n  \"_id\": \"mkdirp@0.5.0\",\n  \"dist\": {\n    \"shasum\": \"1d73076a6df986cd9344e15e71fcc05a4c9abf12\",\n    \"tarball\": \"http://registry.npmjs.org/mkdirp/-/mkdirp-0.5.0.tgz\"\n  },\n  \"_from\": \"mkdirp@0.5.0\",\n  \"_npmVersion\": \"1.4.3\",\n  \"_npmUser\": {\n    \"name\": \"substack\",\n    \"email\": \"mail@substack.net\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"substack\",\n      \"email\": \"mail@substack.net\"\n    }\n  ],\n  \"directories\": {},\n  \"_shasum\": \"1d73076a6df986cd9344e15e71fcc05a4c9abf12\",\n  \"_resolved\": \"https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.0.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/node_modules/mkdirp/test/chmod.js": "var mkdirp = require('../').mkdirp;\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\nvar ps = [ '', 'tmp' ];\n\nfor (var i = 0; i < 25; i++) {\n    var dir = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    ps.push(dir);\n}\n\nvar file = ps.join('/');\n\ntest('chmod-pre', function (t) {\n    var mode = 0744\n    mkdirp(file, mode, function (er) {\n        t.ifError(er, 'should not error');\n        fs.stat(file, function (er, stat) {\n            t.ifError(er, 'should exist');\n            t.ok(stat && stat.isDirectory(), 'should be directory');\n            t.equal(stat && stat.mode & 0777, mode, 'should be 0744');\n            t.end();\n        });\n    });\n});\n\ntest('chmod', function (t) {\n    var mode = 0755\n    mkdirp(file, mode, function (er) {\n        t.ifError(er, 'should not error');\n        fs.stat(file, function (er, stat) {\n            t.ifError(er, 'should exist');\n            t.ok(stat && stat.isDirectory(), 'should be directory');\n            t.end();\n        });\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/clobber.js": "var mkdirp = require('../').mkdirp;\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\nvar ps = [ '', 'tmp' ];\n\nfor (var i = 0; i < 25; i++) {\n    var dir = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    ps.push(dir);\n}\n\nvar file = ps.join('/');\n\n// a file in the way\nvar itw = ps.slice(0, 3).join('/');\n\n\ntest('clobber-pre', function (t) {\n    console.error(\"about to write to \"+itw)\n    fs.writeFileSync(itw, 'I AM IN THE WAY, THE TRUTH, AND THE LIGHT.');\n\n    fs.stat(itw, function (er, stat) {\n        t.ifError(er)\n        t.ok(stat && stat.isFile(), 'should be file')\n        t.end()\n    })\n})\n\ntest('clobber', function (t) {\n    t.plan(2);\n    mkdirp(file, 0755, function (err) {\n        t.ok(err);\n        t.equal(err.code, 'ENOTDIR');\n        t.end();\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/mkdirp.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar exists = fs.exists || path.exists;\nvar test = require('tap').test;\n\ntest('woo', function (t) {\n    t.plan(5);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/tmp/' + [x,y,z].join('/');\n    \n    mkdirp(file, 0755, function (err) {\n        t.ifError(err);\n        exists(file, function (ex) {\n            t.ok(ex, 'file created');\n            fs.stat(file, function (err, stat) {\n                t.ifError(err);\n                t.equal(stat.mode & 0777, 0755);\n                t.ok(stat.isDirectory(), 'target not a directory');\n            })\n        })\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/opts_fs_sync.js": "var mkdirp = require('../');\nvar path = require('path');\nvar test = require('tap').test;\nvar mockfs = require('mock-fs');\n\ntest('opts.fs sync', function (t) {\n    t.plan(4);\n    \n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/beep/boop/' + [x,y,z].join('/');\n    var xfs = mockfs.fs();\n    \n    mkdirp.sync(file, { fs: xfs, mode: 0755 });\n    xfs.exists(file, function (ex) {\n        t.ok(ex, 'created file');\n        xfs.stat(file, function (err, stat) {\n            t.ifError(err);\n            t.equal(stat.mode & 0777, 0755);\n            t.ok(stat.isDirectory(), 'target not a directory');\n        });\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/opts_fs.js": "var mkdirp = require('../');\nvar path = require('path');\nvar test = require('tap').test;\nvar mockfs = require('mock-fs');\n\ntest('opts.fs', function (t) {\n    t.plan(5);\n    \n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/beep/boop/' + [x,y,z].join('/');\n    var xfs = mockfs.fs();\n    \n    mkdirp(file, { fs: xfs, mode: 0755 }, function (err) {\n        t.ifError(err);\n        xfs.exists(file, function (ex) {\n            t.ok(ex, 'created file');\n            xfs.stat(file, function (err, stat) {\n                t.ifError(err);\n                t.equal(stat.mode & 0777, 0755);\n                t.ok(stat.isDirectory(), 'target not a directory');\n            });\n        });\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/perm_sync.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar exists = fs.exists || path.exists;\nvar test = require('tap').test;\n\ntest('sync perm', function (t) {\n    t.plan(4);\n    var file = '/tmp/' + (Math.random() * (1<<30)).toString(16) + '.json';\n    \n    mkdirp.sync(file, 0755);\n    exists(file, function (ex) {\n        t.ok(ex, 'file created');\n        fs.stat(file, function (err, stat) {\n            t.ifError(err);\n            t.equal(stat.mode & 0777, 0755);\n            t.ok(stat.isDirectory(), 'target not a directory');\n        });\n    });\n});\n\ntest('sync root perm', function (t) {\n    t.plan(3);\n    \n    var file = '/tmp';\n    mkdirp.sync(file, 0755);\n    exists(file, function (ex) {\n        t.ok(ex, 'file created');\n        fs.stat(file, function (err, stat) {\n            t.ifError(err);\n            t.ok(stat.isDirectory(), 'target not a directory');\n        })\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/perm.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar exists = fs.exists || path.exists;\nvar test = require('tap').test;\n\ntest('async perm', function (t) {\n    t.plan(5);\n    var file = '/tmp/' + (Math.random() * (1<<30)).toString(16);\n    \n    mkdirp(file, 0755, function (err) {\n        t.ifError(err);\n        exists(file, function (ex) {\n            t.ok(ex, 'file created');\n            fs.stat(file, function (err, stat) {\n                t.ifError(err);\n                t.equal(stat.mode & 0777, 0755);\n                t.ok(stat.isDirectory(), 'target not a directory');\n            })\n        })\n    });\n});\n\ntest('async root perm', function (t) {\n    mkdirp('/tmp', 0755, function (err) {\n        if (err) t.fail(err);\n        t.end();\n    });\n    t.end();\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/race.js": "var mkdirp = require('../').mkdirp;\nvar path = require('path');\nvar fs = require('fs');\nvar exists = fs.exists || path.exists;\nvar test = require('tap').test;\n\ntest('race', function (t) {\n    t.plan(6);\n    var ps = [ '', 'tmp' ];\n    \n    for (var i = 0; i < 25; i++) {\n        var dir = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n        ps.push(dir);\n    }\n    var file = ps.join('/');\n    \n    var res = 2;\n    mk(file, function () {\n        if (--res === 0) t.end();\n    });\n    \n    mk(file, function () {\n        if (--res === 0) t.end();\n    });\n    \n    function mk (file, cb) {\n        mkdirp(file, 0755, function (err) {\n            t.ifError(err);\n            exists(file, function (ex) {\n                t.ok(ex, 'file created');\n                fs.stat(file, function (err, stat) {\n                    t.ifError(err);\n                    t.equal(stat.mode & 0777, 0755);\n                    t.ok(stat.isDirectory(), 'target not a directory');\n                    if (cb) cb();\n                });\n            })\n        });\n    }\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/rel.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar exists = fs.exists || path.exists;\nvar test = require('tap').test;\n\ntest('rel', function (t) {\n    t.plan(5);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var cwd = process.cwd();\n    process.chdir('/tmp');\n    \n    var file = [x,y,z].join('/');\n    \n    mkdirp(file, 0755, function (err) {\n        t.ifError(err);\n        exists(file, function (ex) {\n            t.ok(ex, 'file created');\n            fs.stat(file, function (err, stat) {\n                t.ifError(err);\n                process.chdir(cwd);\n                t.equal(stat.mode & 0777, 0755);\n                t.ok(stat.isDirectory(), 'target not a directory');\n            })\n        })\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/return_sync.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('return value', function (t) {\n    t.plan(2);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n\n    var file = '/tmp/' + [x,y,z].join('/');\n\n    // should return the first dir created.\n    // By this point, it would be profoundly surprising if /tmp didn't\n    // already exist, since every other test makes things in there.\n    // Note that this will throw on failure, which will fail the test.\n    var made = mkdirp.sync(file);\n    t.equal(made, '/tmp/' + x);\n\n    // making the same file again should have no effect.\n    made = mkdirp.sync(file);\n    t.equal(made, null);\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/return.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('return value', function (t) {\n    t.plan(4);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n\n    var file = '/tmp/' + [x,y,z].join('/');\n\n    // should return the first dir created.\n    // By this point, it would be profoundly surprising if /tmp didn't\n    // already exist, since every other test makes things in there.\n    mkdirp(file, function (err, made) {\n        t.ifError(err);\n        t.equal(made, '/tmp/' + x);\n        mkdirp(file, function (err, made) {\n          t.ifError(err);\n          t.equal(made, null);\n        });\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/root.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar test = require('tap').test;\n\ntest('root', function (t) {\n    // '/' on unix, 'c:/' on windows.\n    var file = path.resolve('/');\n\n    mkdirp(file, 0755, function (err) {\n        if (err) throw err\n        fs.stat(file, function (er, stat) {\n            if (er) throw er\n            t.ok(stat.isDirectory(), 'target is a directory');\n            t.end();\n        })\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/sync.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar exists = fs.exists || path.exists;\nvar test = require('tap').test;\n\ntest('sync', function (t) {\n    t.plan(4);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n\n    var file = '/tmp/' + [x,y,z].join('/');\n\n    try {\n        mkdirp.sync(file, 0755);\n    } catch (err) {\n        t.fail(err);\n        return t.end();\n    }\n\n    exists(file, function (ex) {\n        t.ok(ex, 'file created');\n        fs.stat(file, function (err, stat) {\n            t.ifError(err);\n            t.equal(stat.mode & 0777, 0755);\n            t.ok(stat.isDirectory(), 'target not a directory');\n        });\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/umask_sync.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar exists = fs.exists || path.exists;\nvar test = require('tap').test;\n\ntest('umask sync modes', function (t) {\n    t.plan(4);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n\n    var file = '/tmp/' + [x,y,z].join('/');\n\n    try {\n        mkdirp.sync(file);\n    } catch (err) {\n        t.fail(err);\n        return t.end();\n    }\n\n    exists(file, function (ex) {\n        t.ok(ex, 'file created');\n        fs.stat(file, function (err, stat) {\n            t.ifError(err);\n            t.equal(stat.mode & 0777, (0777 & (~process.umask())));\n            t.ok(stat.isDirectory(), 'target not a directory');\n        });\n    });\n});\n",
  "node_modules/mocha/node_modules/mkdirp/test/umask.js": "var mkdirp = require('../');\nvar path = require('path');\nvar fs = require('fs');\nvar exists = fs.exists || path.exists;\nvar test = require('tap').test;\n\ntest('implicit mode from umask', function (t) {\n    t.plan(5);\n    var x = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var y = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    var z = Math.floor(Math.random() * Math.pow(16,4)).toString(16);\n    \n    var file = '/tmp/' + [x,y,z].join('/');\n    \n    mkdirp(file, function (err) {\n        t.ifError(err);\n        exists(file, function (ex) {\n            t.ok(ex, 'file created');\n            fs.stat(file, function (err, stat) {\n                t.ifError(err);\n                t.equal(stat.mode & 0777, 0777 & (~process.umask()));\n                t.ok(stat.isDirectory(), 'target not a directory');\n            });\n        })\n    });\n});\n",
  "node_modules/mocha/node_modules/supports-color/cli.js": "#!/usr/bin/env node\n'use strict';\nvar pkg = require('./package.json');\nvar supportsColor = require('./');\nvar argv = process.argv.slice(2);\n\nfunction help() {\n\tconsole.log([\n\t\t'',\n\t\t'  ' + pkg.description,\n\t\t'',\n\t\t'  Usage',\n\t\t'    supports-color',\n\t\t'',\n\t\t'  Exits with code 0 if color is supported and 1 if not'\n\t].join('\\n'));\n}\n\nif (argv.indexOf('--help') !== -1) {\n\thelp();\n\treturn;\n}\n\nif (argv.indexOf('--version') !== -1) {\n\tconsole.log(pkg.version);\n\treturn;\n}\n\nprocess.exit(supportsColor ? 0 : 1);\n",
  "node_modules/mocha/node_modules/supports-color/index.js": "'use strict';\nvar argv = process.argv;\n\nmodule.exports = (function () {\n\tif (argv.indexOf('--no-color') !== -1 ||\n\t\targv.indexOf('--no-colors') !== -1 ||\n\t\targv.indexOf('--color=false') !== -1) {\n\t\treturn false;\n\t}\n\n\tif (argv.indexOf('--color') !== -1 ||\n\t\targv.indexOf('--colors') !== -1 ||\n\t\targv.indexOf('--color=true') !== -1 ||\n\t\targv.indexOf('--color=always') !== -1) {\n\t\treturn true;\n\t}\n\n\tif (process.stdout && !process.stdout.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn true;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn false;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n})();\n",
  "node_modules/mocha/node_modules/supports-color/package.json": "{\n  \"name\": \"supports-color\",\n  \"version\": \"1.2.1\",\n  \"description\": \"Detect whether a terminal supports color\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/sindresorhus/supports-color.git\"\n  },\n  \"author\": {\n    \"name\": \"Sindre Sorhus\",\n    \"email\": \"sindresorhus@gmail.com\",\n    \"url\": \"http://sindresorhus.com\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"sindresorhus\",\n      \"email\": \"sindresorhus@gmail.com\"\n    },\n    {\n      \"name\": \"jbnicolai\",\n      \"email\": \"jappelman@xebia.com\"\n    }\n  ],\n  \"bin\": {\n    \"supports-color\": \"cli.js\"\n  },\n  \"engines\": {\n    \"node\": \">=0.8.0\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"cli.js\"\n  ],\n  \"keywords\": [\n    \"cli\",\n    \"bin\",\n    \"color\",\n    \"colour\",\n    \"colors\",\n    \"terminal\",\n    \"console\",\n    \"cli\",\n    \"ansi\",\n    \"styles\",\n    \"tty\",\n    \"rgb\",\n    \"256\",\n    \"shell\",\n    \"xterm\",\n    \"command-line\",\n    \"support\",\n    \"supports\",\n    \"capability\",\n    \"detect\"\n  ],\n  \"devDependencies\": {\n    \"mocha\": \"*\",\n    \"require-uncached\": \"^1.0.2\"\n  },\n  \"gitHead\": \"ffe5e224bd24dc0410787b94e192d240be025aec\",\n  \"bugs\": {\n    \"url\": \"https://github.com/sindresorhus/supports-color/issues\"\n  },\n  \"homepage\": \"https://github.com/sindresorhus/supports-color\",\n  \"_id\": \"supports-color@1.2.1\",\n  \"_shasum\": \"12ee21507086cd98c1058d9ec0f4ac476b7af3b2\",\n  \"_from\": \"supports-color@>=1.2.0 <1.3.0\",\n  \"_npmVersion\": \"2.1.16\",\n  \"_nodeVersion\": \"0.10.35\",\n  \"_npmUser\": {\n    \"name\": \"jbnicolai\",\n    \"email\": \"jappelman@xebia.com\"\n  },\n  \"dist\": {\n    \"shasum\": \"12ee21507086cd98c1058d9ec0f4ac476b7af3b2\",\n    \"tarball\": \"http://registry.npmjs.org/supports-color/-/supports-color-1.2.1.tgz\"\n  },\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-1.2.1.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n",
  "node_modules/mocha/package.json": "{\n  \"name\": \"mocha\",\n  \"version\": \"2.2.5\",\n  \"description\": \"simple, flexible, fun test framework\",\n  \"keywords\": [\n    \"mocha\",\n    \"test\",\n    \"bdd\",\n    \"tdd\",\n    \"tap\"\n  ],\n  \"author\": {\n    \"name\": \"TJ Holowaychuk\",\n    \"email\": \"tj@vision-media.ca\"\n  },\n  \"contributors\": [\n    {\n      \"name\": \"Joshua Appelman\",\n      \"email\": \"joshua@jbna.nl\"\n    },\n    {\n      \"name\": \"Christoffer Hallas\",\n      \"email\": \"christoffer.hallas@gmail.com\"\n    },\n    {\n      \"name\": \"Christopher Hiller\",\n      \"email\": \"chiller@badwing.com\"\n    },\n    {\n      \"name\": \"Travis Jeffery\",\n      \"email\": \"tj@travisjeffery.com\"\n    },\n    {\n      \"name\": \"Daniel St. Jules\",\n      \"email\": \"danielst.jules@gmail.com\"\n    },\n    {\n      \"name\": \"David da Silva Contín\",\n      \"email\": \"dasilvacontin@gmail.com\"\n    },\n    {\n      \"name\": \"Ariel Mashraki\",\n      \"email\": \"ariel@mashraki.co.il\"\n    },\n    {\n      \"name\": \"Pawel Kozlowski\",\n      \"email\": \"pkozlowski.opensource@gmail.com\"\n    }\n  ],\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/mochajs/mocha.git\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"tjholowaychuk\",\n      \"email\": \"tj@vision-media.ca\"\n    },\n    {\n      \"name\": \"travisjeffery\",\n      \"email\": \"tj@travisjeffery.com\"\n    },\n    {\n      \"name\": \"boneskull\",\n      \"email\": \"chiller@badwing.com\"\n    }\n  ],\n  \"main\": \"./index\",\n  \"browser\": \"./mocha.js\",\n  \"bin\": {\n    \"mocha\": \"./bin/mocha\",\n    \"_mocha\": \"./bin/_mocha\"\n  },\n  \"engines\": {\n    \"node\": \">= 0.8.x\"\n  },\n  \"scripts\": {\n    \"test\": \"make test-all\"\n  },\n  \"dependencies\": {\n    \"commander\": \"2.3.0\",\n    \"debug\": \"2.0.0\",\n    \"diff\": \"1.4.0\",\n    \"escape-string-regexp\": \"1.0.2\",\n    \"glob\": \"3.2.3\",\n    \"growl\": \"1.8.1\",\n    \"jade\": \"0.26.3\",\n    \"mkdirp\": \"0.5.0\",\n    \"supports-color\": \"~1.2.0\"\n  },\n  \"devDependencies\": {\n    \"coffee-script\": \"~1.8.0\",\n    \"should\": \"~4.0.0\"\n  },\n  \"files\": [\n    \"bin\",\n    \"images\",\n    \"lib\",\n    \"index.js\",\n    \"mocha.css\",\n    \"mocha.js\",\n    \"LICENSE\"\n  ],\n  \"licenses\": [\n    {\n      \"type\": \"MIT\",\n      \"url\": \"https://raw.github.com/mochajs/mocha/master/LICENSE\"\n    }\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/mochajs/mocha/issues\"\n  },\n  \"homepage\": \"https://github.com/mochajs/mocha\",\n  \"_id\": \"mocha@2.2.5\",\n  \"_shasum\": \"d3b72a4fe49ec9439353f1ac893dbc430d993140\",\n  \"_from\": \"mocha@*\",\n  \"_npmVersion\": \"1.4.9\",\n  \"_npmUser\": {\n    \"name\": \"travisjeffery\",\n    \"email\": \"tj@travisjeffery.com\"\n  },\n  \"dist\": {\n    \"shasum\": \"d3b72a4fe49ec9439353f1ac893dbc430d993140\",\n    \"tarball\": \"http://registry.npmjs.org/mocha/-/mocha-2.2.5.tgz\"\n  },\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/mocha/-/mocha-2.2.5.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n"
}