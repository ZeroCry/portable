{
  "_stream_duplex.js": "// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n        var keys = [];\n        for (var key in obj) keys.push(key);\n        return keys;\n    }\n/*</replacement>*/\n\n\n\nvar util = require('util');\nutil.inherits = require('inherits');\n\nvar Readable = require('_stream_readable');\nvar Writable = require('_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method])\n        Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n    if (!(this instanceof Duplex))\n        return new Duplex(options);\n\n    Readable.call(this, options);\n    Writable.call(this, options);\n\n    if (options && options.readable === false)\n        this.readable = false;\n\n    if (options && options.writable === false)\n        this.writable = false;\n\n    this.allowHalfOpen = true;\n    if (options && options.allowHalfOpen === false)\n        this.allowHalfOpen = false;\n\n    this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n    // if we allow half-open state, or if the writable side ended,\n    // then we're ok.\n    if (this.allowHalfOpen || this._writableState.ended)\n        return;\n\n    // no more data can be written.\n    // But allow more writes to happen in this tick.\n    process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n    for (var i = 0, l = xs.length; i < l; i++) {\n        f(xs[i], i);\n    }\n}\n",
  "_stream_passthrough.js": "// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('_stream_transform');\nvar util = require('util');\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n    if (!(this instanceof PassThrough))\n        return new PassThrough(options);\n\n    Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n    cb(null, chunk);\n};\n",
  "_stream_readable.js": "'use strict';\n\nmodule.exports = Readable;\n\nvar util = require('util');\nvar isArray = util.isArray;\nvar Buffer = require('buffer');\nReadable.ReadableState = ReadableState;\nvar EE = require('events');\nvar Stream = require('stream');\nvar StringDecoder;\n\n\n/*<replacement>*/\n// TODO: Do we need this?\nvar debug = require('util');\nif (debug && debug.debuglog) {\n    debug = debug.debuglog('stream');\n} else {\n    debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n    var Duplex = require('./_stream_duplex');\n\n    options = options || {};\n\n    // object stream flag. Used to make read(n) ignore n and to\n    // make all the buffer merging and length checks go away\n    this.objectMode = !!options.objectMode;\n\n    if (stream instanceof Duplex)\n        this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n    // the point at which it stops calling _read() to fill the buffer\n    // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n    var hwm = options.highWaterMark;\n    var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n    this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n    // cast to ints.\n    this.highWaterMark = ~~this.highWaterMark;\n\n    this.buffer = [];\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = null;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, because any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n\n    // whenever we return null, then we set a flag to say\n    // that we're awaiting a 'readable' event emission.\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n    // when piping, we only care about 'readable' events that happen\n    // after read()ing all the bytes and not getting any pushback.\n    this.ranOut = false;\n\n    // the number of writers that are awaiting a drain event in .pipe()s\n    this.awaitDrain = 0;\n\n    // if true, a maybeReadMore has been scheduled\n    this.readingMore = false;\n\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n        if (!StringDecoder)\n            StringDecoder = require('string_decoder/').StringDecoder;\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}\n\nfunction Readable(options) {\n    var Duplex = require('./_stream_duplex');\n\n    if (!(this instanceof Readable))\n        return new Readable(options);\n\n    this._readableState = new ReadableState(options, this);\n\n    // legacy\n    this.readable = true;\n\n    Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n    var state = this._readableState;\n\n    if (util.isString(chunk) && !state.objectMode) {\n        encoding = encoding || state.defaultEncoding;\n        if (encoding !== state.encoding) {\n            chunk = new Buffer(chunk, encoding);\n            encoding = '';\n        }\n    }\n\n    return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n    var state = this._readableState;\n    return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function() {\n    return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n    var er = chunkInvalid(state, chunk);\n    if (er) {\n        stream.emit('error', er);\n    } else if (chunk === null) {\n        state.reading = false;\n        if (!state.ended)\n            onEofChunk(stream, state);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n        if (state.ended && !addToFront) {\n            var e = new Error('stream.push() after EOF');\n            stream.emit('error', e);\n        } else if (state.endEmitted && addToFront) {\n            var e = new Error('stream.unshift() after end event');\n            stream.emit('error', e);\n        } else {\n            if (state.decoder && !addToFront && !encoding)\n                chunk = state.decoder.write(chunk);\n\n            if (!addToFront)\n                state.reading = false;\n\n            // if we want the data now, just emit it.\n            if (state.flowing && state.length === 0 && !state.sync) {\n                stream.emit('data', chunk);\n                stream.read(0);\n            } else {\n                // update the buffer info.\n                state.length += state.objectMode ? 1 : chunk.length;\n                if (addToFront)\n                    state.buffer.unshift(chunk);\n                else\n                    state.buffer.push(chunk);\n\n                if (state.needReadable)\n                    emitReadable(stream);\n            }\n\n            maybeReadMore(stream, state);\n        }\n    } else if (!addToFront) {\n        state.reading = false;\n    }\n\n    return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n    return !state.ended &&\n        (state.needReadable ||\n        state.length < state.highWaterMark ||\n        state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n    if (!StringDecoder)\n        StringDecoder = require('string_decoder/').StringDecoder;\n    this._readableState.decoder = new StringDecoder(enc);\n    this._readableState.encoding = enc;\n    return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n    if (n >= MAX_HWM) {\n        n = MAX_HWM;\n    } else {\n        // Get the next highest power of 2\n        n--;\n        for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n        n++;\n    }\n    return n;\n}\n\nfunction howMuchToRead(n, state) {\n    if (state.length === 0 && state.ended)\n        return 0;\n\n    if (state.objectMode)\n        return n === 0 ? 0 : 1;\n\n    if (util.isNull(n) || isNaN(n)) {\n        // only flow one buffer at a time\n        if (state.flowing && state.buffer.length)\n            return state.buffer[0].length;\n        else\n            return state.length;\n    }\n\n    if (n <= 0)\n        return 0;\n\n    // If we're asking for more than the target buffer level,\n    // then raise the water mark.  Bump up to the next highest\n    // power of 2, to prevent increasing it excessively in tiny\n    // amounts.\n    if (n > state.highWaterMark)\n        state.highWaterMark = roundUpToNextPowerOf2(n);\n\n    // don't have that much.  return null, unless we've ended.\n    if (n > state.length) {\n        if (!state.ended) {\n            state.needReadable = true;\n            return 0;\n        } else\n            return state.length;\n    }\n\n    return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n    debug('read', n);\n    var state = this._readableState;\n    var nOrig = n;\n\n    if (!util.isNumber(n) || n > 0)\n        state.emittedReadable = false;\n\n    // if we're doing read(0) to trigger a readable event, but we\n    // already have a bunch of data in the buffer, then just trigger\n    // the 'readable' event and move on.\n    if (n === 0 &&\n        state.needReadable &&\n        (state.length >= state.highWaterMark || state.ended)) {\n        debug('read: emitReadable', state.length, state.ended);\n        if (state.length === 0 && state.ended)\n            endReadable(this);\n        else\n            emitReadable(this);\n        return null;\n    }\n\n    n = howMuchToRead(n, state);\n\n    // if we've ended, and we're now clear, then finish it up.\n    if (n === 0 && state.ended) {\n        if (state.length === 0)\n            endReadable(this);\n        return null;\n    }\n\n    // All the actual chunk generation logic needs to be\n    // *below* the call to _read.  The reason is that in certain\n    // synthetic stream cases, such as passthrough streams, _read\n    // may be a completely synchronous operation which may change\n    // the state of the read buffer, providing enough data when\n    // before there was *not* enough.\n    //\n    // So, the steps are:\n    // 1. Figure out what the state of things will be after we do\n    // a read from the buffer.\n    //\n    // 2. If that resulting state will trigger a _read, then call _read.\n    // Note that this may be asynchronous, or synchronous.  Yes, it is\n    // deeply ugly to write APIs this way, but that still doesn't mean\n    // that the Readable class should behave improperly, as streams are\n    // designed to be sync/async agnostic.\n    // Take note if the _read call is sync or async (ie, if the read call\n    // has returned yet), so that we know whether or not it's safe to emit\n    // 'readable' etc.\n    //\n    // 3. Actually pull the requested chunks out of the buffer and return.\n\n    // if we need a readable event, then we need to do some reading.\n    var doRead = state.needReadable;\n    debug('need readable', doRead);\n\n    // if we currently have less than the highWaterMark, then also read some\n    if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        debug('length less than watermark', doRead);\n    }\n\n    // however, if we've ended, then there's no point, and if we're already\n    // reading, then it's unnecessary.\n    if (state.ended || state.reading) {\n        doRead = false;\n        debug('reading or ended', doRead);\n    }\n\n    if (doRead) {\n        debug('do read');\n        state.reading = true;\n        state.sync = true;\n        // if the length is currently zero, then we *need* a readable event.\n        if (state.length === 0)\n            state.needReadable = true;\n        // call internal read method\n        this._read(state.highWaterMark);\n        state.sync = false;\n    }\n\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (doRead && !state.reading)\n        n = howMuchToRead(nOrig, state);\n\n    var ret;\n    if (n > 0)\n        ret = fromList(n, state);\n    else\n        ret = null;\n\n    if (util.isNull(ret)) {\n        state.needReadable = true;\n        n = 0;\n    }\n\n    state.length -= n;\n\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (state.length === 0 && !state.ended)\n        state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended && state.length === 0)\n        endReadable(this);\n\n    if (!util.isNull(ret))\n        this.emit('data', ret);\n\n    return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n    var er = null;\n    if (!util.isBuffer(chunk) &&\n        !util.isString(chunk) &&\n        !util.isNullOrUndefined(chunk) &&\n        !state.objectMode) {\n        er = new TypeError('Invalid non-string/buffer chunk');\n    }\n    return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n    if (state.decoder && !state.ended) {\n        var chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n\n    // emit 'readable' now to make sure it gets picked up.\n    emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n    var state = stream._readableState;\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n        debug('emitReadable', state.flowing);\n        state.emittedReadable = true;\n        if (state.sync)\n            process.nextTick(function() {\n                emitReadable_(stream);\n            });\n        else\n            emitReadable_(stream);\n    }\n}\n\nfunction emitReadable_(stream) {\n    debug('emit readable');\n    stream.emit('readable');\n    flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n    if (!state.readingMore) {\n        state.readingMore = true;\n        process.nextTick(function() {\n            maybeReadMore_(stream, state);\n        });\n    }\n}\n\nfunction maybeReadMore_(stream, state) {\n    var len = state.length;\n    while (!state.reading && !state.flowing && !state.ended &&\n    state.length < state.highWaterMark) {\n        debug('maybeReadMore read 0');\n        stream.read(0);\n        if (len === state.length)\n        // didn't get any data, stop spinning.\n            break;\n        else\n            len = state.length;\n    }\n    state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n    this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n    var src = this;\n    var state = this._readableState;\n\n    switch (state.pipesCount) {\n        case 0:\n            state.pipes = dest;\n            break;\n        case 1:\n            state.pipes = [state.pipes, dest];\n            break;\n        default:\n            state.pipes.push(dest);\n            break;\n    }\n    state.pipesCount += 1;\n    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n    var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n        dest !== process.stdout &&\n        dest !== process.stderr;\n\n    var endFn = doEnd ? onend : cleanup;\n    if (state.endEmitted)\n        process.nextTick(endFn);\n    else\n        src.once('end', endFn);\n\n    dest.on('unpipe', onunpipe);\n    function onunpipe(readable) {\n        debug('onunpipe');\n        if (readable === src) {\n            cleanup();\n        }\n    }\n\n    function onend() {\n        debug('onend');\n        dest.end();\n    }\n\n    // when the dest drains, it reduces the awaitDrain counter\n    // on the source.  This would be more elegant with a .once()\n    // handler in flow(), but adding and removing repeatedly is\n    // too slow.\n    var ondrain = pipeOnDrain(src);\n    dest.on('drain', ondrain);\n\n    function cleanup() {\n        debug('cleanup');\n        // cleanup event handlers once the pipe is broken\n        dest.removeListener('close', onclose);\n        dest.removeListener('finish', onfinish);\n        dest.removeListener('drain', ondrain);\n        dest.removeListener('error', onerror);\n        dest.removeListener('unpipe', onunpipe);\n        src.removeListener('end', onend);\n        src.removeListener('end', cleanup);\n        src.removeListener('data', ondata);\n\n        // if the reader is waiting for a drain event from this\n        // specific writer, then it would cause it to never start\n        // flowing again.\n        // So, if this is awaiting a drain, then we just call it now.\n        // If we don't know, then assume that we are waiting for one.\n        if (state.awaitDrain &&\n            (!dest._writableState || dest._writableState.needDrain))\n            ondrain();\n    }\n\n    src.on('data', ondata);\n    function ondata(chunk) {\n        debug('ondata');\n        var ret = dest.write(chunk);\n        if (false === ret) {\n            debug('false write response, pause',\n                src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            src.pause();\n        }\n    }\n\n    // if the dest has an error, then stop piping into it.\n    // however, don't suppress the throwing behavior for this.\n    function onerror(er) {\n        debug('onerror', er);\n        unpipe();\n        dest.removeListener('error', onerror);\n        if (EE.listenerCount(dest, 'error') === 0)\n            dest.emit('error', er);\n    }\n    // This is a brutally ugly hack to make sure that our error handler\n    // is attached before any userland ones.  NEVER DO THIS.\n    if (!dest._events || !dest._events.error)\n        dest.on('error', onerror);\n    else if (isArray(dest._events.error))\n        dest._events.error.unshift(onerror);\n    else\n        dest._events.error = [onerror, dest._events.error];\n\n\n\n    // Both close and finish should trigger unpipe, but only once.\n    function onclose() {\n        dest.removeListener('finish', onfinish);\n        unpipe();\n    }\n    dest.once('close', onclose);\n    function onfinish() {\n        debug('onfinish');\n        dest.removeListener('close', onclose);\n        unpipe();\n    }\n    dest.once('finish', onfinish);\n\n    function unpipe() {\n        debug('unpipe');\n        src.unpipe(dest);\n    }\n\n    // tell the dest that it's being piped to\n    dest.emit('pipe', src);\n\n    // start the flow if it hasn't been started already.\n    if (!state.flowing) {\n        debug('pipe resume');\n        src.resume();\n    }\n\n    return dest;\n};\n\nfunction pipeOnDrain(src) {\n    return function() {\n        var state = src._readableState;\n        debug('pipeOnDrain', state.awaitDrain);\n        if (state.awaitDrain)\n            state.awaitDrain--;\n        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n            state.flowing = true;\n            flow(src);\n        }\n    };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n    var state = this._readableState;\n\n    // if we're not piping anywhere, then do nothing.\n    if (state.pipesCount === 0)\n        return this;\n\n    // just one destination.  most common case.\n    if (state.pipesCount === 1) {\n        // passed in one, but it's not the right one.\n        if (dest && dest !== state.pipes)\n            return this;\n\n        if (!dest)\n            dest = state.pipes;\n\n        // got a match.\n        state.pipes = null;\n        state.pipesCount = 0;\n        state.flowing = false;\n        if (dest)\n            dest.emit('unpipe', this);\n        return this;\n    }\n\n    // slow case. multiple pipe destinations.\n\n    if (!dest) {\n        // remove all.\n        var dests = state.pipes;\n        var len = state.pipesCount;\n        state.pipes = null;\n        state.pipesCount = 0;\n        state.flowing = false;\n\n        for (var i = 0; i < len; i++)\n            dests[i].emit('unpipe', this);\n        return this;\n    }\n\n    // try to find the right one.\n    var i = indexOf(state.pipes, dest);\n    if (i === -1)\n        return this;\n\n    state.pipes.splice(i, 1);\n    state.pipesCount -= 1;\n    if (state.pipesCount === 1)\n        state.pipes = state.pipes[0];\n\n    dest.emit('unpipe', this);\n\n    return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n    var res = Stream.prototype.on.call(this, ev, fn);\n\n    // If listening to data, and it has not explicitly been paused,\n    // then call resume to start the flow of data on the next tick.\n    if (ev === 'data' && false !== this._readableState.flowing) {\n        this.resume();\n    }\n\n    if (ev === 'readable' && this.readable) {\n        var state = this._readableState;\n        if (!state.readableListening) {\n            state.readableListening = true;\n            state.emittedReadable = false;\n            state.needReadable = true;\n            if (!state.reading) {\n                var self = this;\n                process.nextTick(function() {\n                    debug('readable nexttick read 0');\n                    self.read(0);\n                });\n            } else if (state.length) {\n                emitReadable(this, state);\n            }\n        }\n    }\n\n    return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n    var state = this._readableState;\n    if (!state.flowing) {\n        debug('resume');\n        state.flowing = true;\n        resume(this, state);\n    }\n    return this;\n};\n\nfunction resume(stream, state) {\n    if (!state.resumeScheduled) {\n        state.resumeScheduled = true;\n        process.nextTick(function() {\n            resume_(stream, state);\n        });\n    }\n}\n\nfunction resume_(stream, state) {\n    if (!state.reading) {\n        debug('resume read 0');\n        stream.read(0);\n    }\n\n    state.resumeScheduled = false;\n    stream.emit('resume');\n    flow(stream);\n    if (state.flowing && !state.reading)\n        stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n    debug('call pause flowing=%j', this._readableState.flowing);\n    if (false !== this._readableState.flowing) {\n        debug('pause');\n        this._readableState.flowing = false;\n        this.emit('pause');\n    }\n    return this;\n};\n\nfunction flow(stream) {\n    var state = stream._readableState;\n    debug('flow', state.flowing);\n    if (state.flowing) {\n        do {\n            var chunk = stream.read();\n        } while (null !== chunk && state.flowing);\n    }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n    var state = this._readableState;\n    var paused = false;\n\n    var self = this;\n    stream.on('end', function() {\n        debug('wrapped end');\n        if (state.decoder && !state.ended) {\n            var chunk = state.decoder.end();\n            if (chunk && chunk.length)\n                self.push(chunk);\n        }\n\n        self.push(null);\n    });\n\n    stream.on('data', function(chunk) {\n        debug('wrapped data');\n        if (state.decoder)\n            chunk = state.decoder.write(chunk);\n\n        // don't skip over falsy values in objectMode\n        //if (state.objectMode && util.isNullOrUndefined(chunk))\n        if (state.objectMode && (chunk === null || chunk === undefined))\n            return;\n        else if (!state.objectMode && (!chunk || !chunk.length))\n            return;\n\n        var ret = self.push(chunk);\n        if (!ret) {\n            paused = true;\n            stream.pause();\n        }\n    });\n\n    // proxy all the other methods.\n    // important when wrapping filters and duplexes.\n    for (var i in stream) {\n        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n            this[i] = function(method) { return function() {\n                return stream[method].apply(stream, arguments);\n            }}(i);\n        }\n    }\n\n    // proxy certain important events.\n    var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n    forEach(events, function(ev) {\n        stream.on(ev, self.emit.bind(self, ev));\n    });\n\n    // when we try to consume some more bytes, simply unpause the\n    // underlying stream.\n    self._read = function(n) {\n        debug('wrapped _read', n);\n        if (paused) {\n            paused = false;\n            stream.resume();\n        }\n    };\n\n    return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n    var list = state.buffer;\n    var length = state.length;\n    var stringMode = !!state.decoder;\n    var objectMode = !!state.objectMode;\n    var ret;\n\n    // nothing in the list, definitely empty.\n    if (list.length === 0)\n        return null;\n\n    if (length === 0)\n        ret = null;\n    else if (objectMode)\n        ret = list.shift();\n    else if (!n || n >= length) {\n        // read it all, truncate the array.\n        if (stringMode)\n            ret = list.join('');\n        else\n            ret = Buffer.concat(list, length);\n        list.length = 0;\n    } else {\n        // read just some of it.\n        if (n < list[0].length) {\n            // just take a part of the first list item.\n            // slice is the same for buffers and strings.\n            var buf = list[0];\n            ret = buf.slice(0, n);\n            list[0] = buf.slice(n);\n        } else if (n === list[0].length) {\n            // first list is a perfect match\n            ret = list.shift();\n        } else {\n            // complex case.\n            // we have enough to cover it, but it spans past the first buffer.\n            if (stringMode)\n                ret = '';\n            else\n                ret = new Buffer(n);\n\n            var c = 0;\n            for (var i = 0, l = list.length; i < l && c < n; i++) {\n                var buf = list[0];\n                var cpy = Math.min(n - c, buf.length);\n\n                if (stringMode)\n                    ret += buf.slice(0, cpy);\n                else\n                    buf.copy(ret, c, 0, cpy);\n\n                if (cpy < buf.length)\n                    list[0] = buf.slice(cpy);\n                else\n                    list.shift();\n\n                c += cpy;\n            }\n        }\n    }\n\n    return ret;\n}\n\nfunction endReadable(stream) {\n    var state = stream._readableState;\n\n    // If we get here before consuming all the bytes, then that is a\n    // bug in node.  Should never happen.\n    if (state.length > 0)\n        throw new Error('endReadable called on non-empty stream');\n\n    if (!state.endEmitted) {\n        state.ended = true;\n        process.nextTick(function() {\n            // Check that we didn't get one last unshift.\n            if (!state.endEmitted && state.length === 0) {\n                state.endEmitted = true;\n                stream.readable = false;\n                stream.emit('end');\n            }\n        });\n    }\n}\n\nfunction forEach (xs, f) {\n    for (var i = 0, l = xs.length; i < l; i++) {\n        f(xs[i], i);\n    }\n}\n\nfunction indexOf (xs, x) {\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) return i;\n    }\n    return -1;\n}\n",
  "_stream_transform.js": "// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('_stream_duplex');\nvar util = require('util');\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n    this.afterTransform = function(er, data) {\n        return afterTransform(stream, er, data);\n    };\n\n    this.needTransform = false;\n    this.transforming = false;\n    this.writecb = null;\n    this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n    var ts = stream._transformState;\n    ts.transforming = false;\n\n    var cb = ts.writecb;\n\n    if (!cb)\n        return stream.emit('error', new Error('no writecb in Transform class'));\n\n    ts.writechunk = null;\n    ts.writecb = null;\n\n    if (!util.isNullOrUndefined(data))\n        stream.push(data);\n\n    if (cb)\n        cb(er);\n\n    var rs = stream._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n        stream._read(rs.highWaterMark);\n    }\n}\n\n\nfunction Transform(options) {\n    if (!(this instanceof Transform))\n        return new Transform(options);\n\n    Duplex.call(this, options);\n\n    this._transformState = new TransformState(this);\n\n    // when the writable side finishes, then flush out anything remaining.\n    var stream = this;\n\n    // start out asking for a readable event once data is transformed.\n    this._readableState.needReadable = true;\n\n    // we have implemented the _read method, and done the other things\n    // that Readable wants before the first _read call, so unset the\n    // sync guard flag.\n    this._readableState.sync = false;\n\n    this.once('prefinish', function() {\n        if (util.isFunction(this._flush))\n            this._flush(function(er) {\n                done(stream, er);\n            });\n        else\n            done(stream);\n    });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n    this._transformState.needTransform = false;\n    return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n    throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n    var ts = this._transformState;\n    ts.writecb = cb;\n    ts.writechunk = chunk;\n    ts.writeencoding = encoding;\n    if (!ts.transforming) {\n        var rs = this._readableState;\n        if (ts.needTransform ||\n            rs.needReadable ||\n            rs.length < rs.highWaterMark)\n            this._read(rs.highWaterMark);\n    }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n    var ts = this._transformState;\n\n    if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n        ts.transforming = true;\n        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n    } else {\n        // mark that we need a transform, so that any data that comes in\n        // will get processed, now that we've asked for it.\n        ts.needTransform = true;\n    }\n};\n\n\nfunction done(stream, er) {\n    if (er)\n        return stream.emit('error', er);\n\n    // if there's nothing in the write buffer, then that means\n    // that nothing more will ever be provided\n    var ws = stream._writableState;\n    var ts = stream._transformState;\n\n    if (ws.length)\n        throw new Error('calling transform done when ws.length != 0');\n\n    if (ts.transforming)\n        throw new Error('calling transform done when still transforming');\n\n    return stream.push(null);\n}\n",
  "_stream_writable.js": "// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\nvar Buffer = require('buffer');\nWritable.WritableState = WritableState;\nvar util = require('util');\nvar Stream = require('stream');\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n    debug = debug.debuglog('stream');\n} else {\n    debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n    this.chunk = chunk;\n    this.encoding = encoding;\n    this.callback = cb;\n    this.next = null;\n}\n\nfunction WritableState(options, stream) {\n    var Duplex = require('./_stream_duplex');\n\n    options = options || {};\n\n    // object stream flag to indicate whether or not this stream\n    // contains buffers or objects.\n    this.objectMode = !!options.objectMode;\n\n    if (stream instanceof Duplex)\n        this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n    // the point at which write() starts returning false\n    // Note: 0 is a valid value, means that we always return false if\n    // the entire buffer is not flushed immediately on write()\n    var hwm = options.highWaterMark;\n    var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n    this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n    // cast to ints.\n    this.highWaterMark = ~~this.highWaterMark;\n\n    this.needDrain = false;\n    // at the start of calling end()\n    this.ending = false;\n    // when end() has been called, and returned\n    this.ended = false;\n    // when 'finish' is emitted\n    this.finished = false;\n\n    // should we decode strings into buffers before passing to _write?\n    // this is here so that some node-core streams can optimize string\n    // handling at a lower level.\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n    // not an actual buffer we keep track of, but a measurement\n    // of how much we're waiting to get pushed to some underlying\n    // socket or file.\n    this.length = 0;\n\n    // a flag to see when we're in the middle of a write.\n    this.writing = false;\n\n    // when true all writes will be buffered until .uncork() call\n    this.corked = 0;\n\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, because any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n\n    // a flag to know if we're processing previously buffered items, which\n    // may call the _write() callback in the same tick, so that we don't\n    // end up in an overlapped onwrite situation.\n    this.bufferProcessing = false;\n\n    // the callback that's passed to _write(chunk,cb)\n    this.onwrite = function(er) {\n        onwrite(stream, er);\n    };\n\n    // the callback that the user supplies to write(chunk,encoding,cb)\n    this.writecb = null;\n\n    // the amount that is being written when _write is called.\n    this.writelen = 0;\n\n    this.bufferedRequest = null;\n    this.lastBufferedRequest = null;\n\n    // number of pending user-supplied write callbacks\n    // this must be 0 before 'finish' can be emitted\n    this.pendingcb = 0;\n\n    // emit prefinish if the only thing we're waiting for is _write cbs\n    // This is relevant for synchronous Transform streams\n    this.prefinished = false;\n\n    // True if the error was already emitted and should not be thrown again\n    this.errorEmitted = false;\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n    var current = this.bufferedRequest;\n    var out = [];\n    while (current) {\n        out.push(current);\n        current = current.next;\n    }\n    return out;\n};\n\nObject.defineProperty(WritableState.prototype, 'buffer', {\n    get: require('util-deprecate')(function() {\n        return this.getBuffer();\n    }, '_writableState.buffer is deprecated. Use ' +\n        '_writableState.getBuffer() instead.')\n});\n\nfunction Writable(options) {\n    var Duplex = require('./_stream_duplex');\n\n    // Writable ctor is applied to Duplexes, though they're not\n    // instanceof Writable, they're instanceof Readable.\n    if (!(this instanceof Writable) && !(this instanceof Duplex))\n        return new Writable(options);\n\n    this._writableState = new WritableState(options, this);\n\n    // legacy.\n    this.writable = true;\n\n    Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n    this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n    var er = new Error('write after end');\n    // TODO: defer error events consistently everywhere, not just the cb\n    stream.emit('error', er);\n    process.nextTick(function() {\n        cb(er);\n    });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n    var valid = true;\n    if (!util.isBuffer(chunk) &&\n        !util.isString(chunk) &&\n        !util.isNullOrUndefined(chunk) &&\n        !state.objectMode) {\n        var er = new TypeError('Invalid non-string/buffer chunk');\n        stream.emit('error', er);\n        process.nextTick(function() {\n            cb(er);\n        });\n        valid = false;\n    }\n    return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n    var state = this._writableState;\n    var ret = false;\n\n    if (util.isFunction(encoding)) {\n        cb = encoding;\n        encoding = null;\n    }\n\n    if (util.isBuffer(chunk))\n        encoding = 'buffer';\n    else if (!encoding)\n        encoding = state.defaultEncoding;\n\n    if (!util.isFunction(cb))\n        cb = function() {};\n\n    if (state.ended)\n        writeAfterEnd(this, state, cb);\n    else if (validChunk(this, state, chunk, cb)) {\n        state.pendingcb++;\n        ret = writeOrBuffer(this, state, chunk, encoding, cb);\n    }\n\n    return ret;\n};\n\nWritable.prototype.cork = function() {\n    var state = this._writableState;\n\n    state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n    var state = this._writableState;\n\n    if (state.corked) {\n        state.corked--;\n\n        if (!state.writing &&\n            !state.corked &&\n            !state.finished &&\n            !state.bufferProcessing &&\n            state.bufferedRequest)\n            clearBuffer(this, state);\n    }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n    // node::ParseEncoding() requires lower case.\n    if (typeof encoding === 'string')\n        encoding = encoding.toLowerCase();\n    if (!Buffer.isEncoding(encoding))\n        throw new TypeError('Unknown encoding: ' + encoding);\n    this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n    if (!state.objectMode &&\n        state.decodeStrings !== false &&\n        util.isString(chunk)) {\n        chunk = new Buffer(chunk, encoding);\n    }\n    return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n    chunk = decodeChunk(state, chunk, encoding);\n    if (util.isBuffer(chunk))\n        encoding = 'buffer';\n    var len = state.objectMode ? 1 : chunk.length;\n\n    state.length += len;\n\n    var ret = state.length < state.highWaterMark;\n    // we must ensure that previous needDrain will not be reset to false.\n    if (!ret)\n        state.needDrain = true;\n\n    if (state.writing || state.corked) {\n        var last = state.lastBufferedRequest;\n        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n        if (last) {\n            last.next = state.lastBufferedRequest;\n        } else {\n            state.bufferedRequest = state.lastBufferedRequest;\n        }\n    }\n    else\n        doWrite(stream, state, false, len, chunk, encoding, cb);\n\n    return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    if (writev)\n        stream._writev(chunk, state.onwrite);\n    else\n        stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n    if (sync)\n        process.nextTick(function() {\n            state.pendingcb--;\n            cb(er);\n        });\n    else {\n        state.pendingcb--;\n        cb(er);\n    }\n\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n    var state = stream._writableState;\n    var sync = state.sync;\n    var cb = state.writecb;\n\n    onwriteStateUpdate(state);\n\n    if (er)\n        onwriteError(stream, state, sync, er, cb);\n    else {\n        // Check if we're actually ready to finish, but don't emit yet\n        var finished = needFinish(stream, state);\n\n        if (!finished &&\n            !state.corked &&\n            !state.bufferProcessing &&\n            state.bufferedRequest) {\n            clearBuffer(stream, state);\n        }\n\n        if (sync) {\n            process.nextTick(function() {\n                afterWrite(stream, state, finished, cb);\n            });\n        } else {\n            afterWrite(stream, state, finished, cb);\n        }\n    }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n    if (!finished)\n        onwriteDrain(stream, state);\n    state.pendingcb--;\n    cb();\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n    if (state.length === 0 && state.needDrain) {\n        state.needDrain = false;\n        stream.emit('drain');\n    }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n    state.bufferProcessing = true;\n    var entry = state.bufferedRequest;\n\n    if (stream._writev && entry && entry.next) {\n        // Fast case, write everything using _writev()\n        var buffer = [];\n        var cbs = [];\n        while (entry) {\n            cbs.push(entry.callback);\n            buffer.push(entry);\n            entry = entry.next;\n        }\n\n        // count the one we are adding, as well.\n        // TODO(isaacs) clean this up\n        state.pendingcb++;\n        state.lastBufferedRequest = null;\n        doWrite(stream, state, true, state.length, buffer, '', function(err) {\n            for (var i = 0; i < cbs.length; i++) {\n                state.pendingcb--;\n                cbs[i](err);\n            }\n        });\n\n        // Clear buffer\n    } else {\n        // Slow case, write chunks one-by-one\n        while (entry) {\n            var chunk = entry.chunk;\n            var encoding = entry.encoding;\n            var cb = entry.callback;\n            var len = state.objectMode ? 1 : chunk.length;\n\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n            entry = entry.next;\n            // if we didn't call the onwrite immediately, then\n            // it means that we need to wait until it does.\n            // also, that means that the chunk and cb are currently\n            // being processed, so move the buffer counter past them.\n            if (state.writing) {\n                break;\n            }\n        }\n\n        if (entry === null)\n            state.lastBufferedRequest = null;\n    }\n    state.bufferedRequest = entry;\n    state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n    cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n    var state = this._writableState;\n\n    if (util.isFunction(chunk)) {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n    } else if (util.isFunction(encoding)) {\n        cb = encoding;\n        encoding = null;\n    }\n\n    if (!util.isNullOrUndefined(chunk))\n        this.write(chunk, encoding);\n\n    // .end() fully uncorks\n    if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n    }\n\n    // ignore unnecessary end() calls.\n    if (!state.ending && !state.finished)\n        endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n    return (state.ending &&\n    state.length === 0 &&\n    state.bufferedRequest === null &&\n    !state.finished &&\n    !state.writing);\n}\n\nfunction prefinish(stream, state) {\n    if (!state.prefinished) {\n        state.prefinished = true;\n        stream.emit('prefinish');\n    }\n}\n\nfunction finishMaybe(stream, state) {\n    var need = needFinish(stream, state);\n    if (need) {\n        if (state.pendingcb === 0) {\n            prefinish(stream, state);\n            state.finished = true;\n            stream.emit('finish');\n        } else\n            prefinish(stream, state);\n    }\n    return need;\n}\n\nfunction endWritable(stream, state, cb) {\n    state.ending = true;\n    finishMaybe(stream, state);\n    if (cb) {\n        if (state.finished)\n            process.nextTick(cb);\n        else\n            stream.once('finish', cb);\n    }\n    state.ended = true;\n}\n",
  "assert.js": "// Adapted from: https://www.npmjs.com/package/assert\n\n// when used in node, this will actually load the util module we depend on\n// versus loading the builtin util module as happens otherwise\n// this is a bug in node module loading as far as I am concerned\nvar util = require('util');\n\nvar pSlice = Array.prototype.slice;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n    this.name = 'AssertionError';\n    this.actual = options.actual;\n    this.expected = options.expected;\n    this.operator = options.operator;\n    if (options.message) {\n        this.message = options.message;\n        this.generatedMessage = false;\n    } else {\n        this.message = getMessage(this);\n        this.generatedMessage = true;\n    }\n    var stackStartFunction = options.stackStartFunction || fail;\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, stackStartFunction);\n    }\n    else {\n        // non v8 browsers so we can have a stacktrace\n        var err = new Error();\n        if (err.stack) {\n            var out = err.stack;\n\n            // try to strip useless frames\n            var fn_name = stackStartFunction.name;\n            var idx = out.indexOf('\\n' + fn_name);\n            if (idx >= 0) {\n                // once we have located the function frame\n                // we need to strip out everything before it (and its line)\n                var next_line = out.indexOf('\\n', idx + 1);\n                out = out.substring(next_line + 1);\n            }\n\n            this.stack = out;\n        }\n    }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n    if (util.isUndefined(value)) {\n        return '' + value;\n    }\n    if (util.isNumber(value) && !isFinite(value)) {\n        return value.toString();\n    }\n    if (util.isFunction(value) || util.isRegExp(value)) {\n        return value.toString();\n    }\n    return value;\n}\n\nfunction truncate(s, n) {\n    if (util.isString(s)) {\n        return s.length < n ? s : s.slice(0, n);\n    } else {\n        return s;\n    }\n}\n\nfunction getMessage(self) {\n    return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\n        self.operator + ' ' +\n        truncate(JSON.stringify(self.expected, replacer), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n    throw new assert.AssertionError({\n        message: message,\n        actual: actual,\n        expected: expected,\n        operator: operator,\n        stackStartFunction: stackStartFunction\n    });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n    if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n    if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n    if (actual == expected) {\n        fail(actual, expected, message, '!=', assert.notEqual);\n    }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n    if (!_deepEqual(actual, expected)) {\n        fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n    }\n};\n\nfunction _deepEqual(actual, expected) {\n    // 7.1. All identical values are equivalent, as determined by ===.\n    if (actual === expected) {\n        return true;\n\n    } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\n        if (actual.length != expected.length) return false;\n\n        for (var i = 0; i < actual.length; i++) {\n            if (actual[i] !== expected[i]) return false;\n        }\n\n        return true;\n\n        // 7.2. If the expected value is a Date object, the actual value is\n        // equivalent if it is also a Date object that refers to the same time.\n    } else if (util.isDate(actual) && util.isDate(expected)) {\n        return actual.getTime() === expected.getTime();\n\n        // 7.3 If the expected value is a RegExp object, the actual value is\n        // equivalent if it is also a RegExp object with the same source and\n        // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n    } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n        return actual.source === expected.source &&\n            actual.global === expected.global &&\n            actual.multiline === expected.multiline &&\n            actual.lastIndex === expected.lastIndex &&\n            actual.ignoreCase === expected.ignoreCase;\n\n        // 7.4. Other pairs that do not both pass typeof value == 'object',\n        // equivalence is determined by ==.\n    } else if (!util.isObject(actual) && !util.isObject(expected)) {\n        return actual == expected;\n\n        // 7.5 For all other Object pairs, including Array objects, equivalence is\n        // determined by having the same number of owned properties (as verified\n        // with Object.prototype.hasOwnProperty.call), the same set of keys\n        // (although not necessarily the same order), equivalent values for every\n        // corresponding key, and an identical 'prototype' property. Note: this\n        // accounts for both named and indexed properties on Arrays.\n    } else {\n        return objEquiv(actual, expected);\n    }\n}\n\nfunction isArguments(object) {\n    return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n    if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\n        return false;\n    // an identical 'prototype' property.\n    if (a.prototype !== b.prototype) return false;\n    // if one is a primitive, the other must be same\n    if (util.isPrimitive(a) || util.isPrimitive(b)) {\n        return a === b;\n    }\n    var aIsArgs = isArguments(a),\n        bIsArgs = isArguments(b);\n    if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n        return false;\n    if (aIsArgs) {\n        a = pSlice.call(a);\n        b = pSlice.call(b);\n        return _deepEqual(a, b);\n    }\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n    // having the same number of owned properties (keys incorporates\n    // hasOwnProperty)\n    if (ka.length != kb.length)\n        return false;\n    //the same set of keys (although not necessarily the same order),\n    ka.sort();\n    kb.sort();\n    //~~~cheap key test\n    for (i = ka.length - 1; i >= 0; i--) {\n        if (ka[i] != kb[i])\n            return false;\n    }\n    //equivalent values for every corresponding key, and\n    //~~~possibly expensive deep test\n    for (i = ka.length - 1; i >= 0; i--) {\n        key = ka[i];\n        if (!_deepEqual(a[key], b[key])) return false;\n    }\n    return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n    if (_deepEqual(actual, expected)) {\n        fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n    }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n    if (actual !== expected) {\n        fail(actual, expected, message, '===', assert.strictEqual);\n    }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n    if (actual === expected) {\n        fail(actual, expected, message, '!==', assert.notStrictEqual);\n    }\n};\n\nfunction expectedException(actual, expected) {\n    if (!actual || !expected) {\n        return false;\n    }\n\n    if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n        return expected.test(actual);\n    } else if (actual instanceof expected) {\n        return true;\n    } else if (expected.call({}, actual) === true) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n    var actual;\n\n    if (util.isString(expected)) {\n        message = expected;\n        expected = null;\n    }\n\n    try {\n        block();\n    } catch (e) {\n        actual = e;\n    }\n\n    message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n        (message ? ' ' + message : '.');\n\n    if (shouldThrow && !actual) {\n        fail(actual, expected, 'Missing expected exception' + message);\n    }\n\n    if (!shouldThrow && expectedException(actual, expected)) {\n        fail(actual, expected, 'Got unwanted exception' + message);\n    }\n\n    if ((shouldThrow && actual && expected &&\n        !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n        throw actual;\n    }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n    _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/message) {\n    _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\nvar objectKeys = Object.keys || function (obj) {\n        var keys = [];\n        for (var key in obj) {\n            if (hasOwn.call(obj, key)) keys.push(key);\n        }\n        return keys;\n    };\n",
  "buffer.js": "// https://github.com/toots/buffer-browserify/blob/master/index.js\n\nvar assert;\nexports.Buffer = Buffer;\nexports.SlowBuffer = Buffer;\nBuffer.poolSize = 8192;\nexports.INSPECT_MAX_BYTES = 50;\n\nfunction stringtrim(str) {\n    if (str.trim) return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction Buffer(subject, encoding, offset) {\n    if(!assert) assert= require('assert');\n    if (!(this instanceof Buffer)) {\n        return new Buffer(subject, encoding, offset);\n    }\n    this.parent = this;\n    this.offset = 0;\n\n    // Work-around: node's base64 implementation\n    // allows for non-padded strings while base64-js\n    // does not..\n    if (encoding == \"base64\" && typeof subject == \"string\") {\n        subject = stringtrim(subject);\n        while (subject.length % 4 != 0) {\n            subject = subject + \"=\";\n        }\n    }\n\n    var type;\n\n    // Are we slicing?\n    if (typeof offset === 'number') {\n        this.length = coerce(encoding);\n        // slicing works, with limitations (no parent tracking/update)\n        // check https://github.com/toots/buffer-browserify/issues/19\n        for (var i = 0; i < this.length; i++) {\n            this[i] = subject.get(i+offset);\n        }\n    } else {\n        // Find the length\n        switch (type = typeof subject) {\n            case 'number':\n                this.length = coerce(subject);\n                break;\n\n            case 'string':\n                this.length = Buffer.byteLength(subject, encoding);\n                break;\n\n            case 'object': // Assume object is an array\n                this.length = coerce(subject.length);\n                break;\n\n            default:\n                throw new TypeError('First argument needs to be a number, ' +\n                    'array or string.');\n        }\n\n        // Treat array-ish objects as a byte array.\n        if (isArrayIsh(subject)) {\n            for (var i = 0; i < this.length; i++) {\n                if (subject instanceof Buffer) {\n                    this[i] = subject.readUInt8(i);\n                }\n                else {\n                    // Round-up subject[i] to a UInt8.\n                    // e.g.: ((-432 % 256) + 256) % 256 = (-176 + 256) % 256\n                    //                                  = 80\n                    this[i] = ((subject[i] % 256) + 256) % 256;\n                }\n            }\n        } else if (type == 'string') {\n            // We are a string\n            this.length = this.write(subject, 0, encoding);\n        } else if (type === 'number') {\n            for (var i = 0; i < this.length; i++) {\n                this[i] = 0;\n            }\n        }\n    }\n}\n\nBuffer.prototype.get = function get(i) {\n    if (i < 0 || i >= this.length) throw new Error('oob');\n    return this[i];\n};\n\nBuffer.prototype.set = function set(i, v) {\n    if (i < 0 || i >= this.length) throw new Error('oob');\n    return this[i] = v;\n};\n\nBuffer.byteLength = function (str, encoding) {\n    switch (encoding || \"utf8\") {\n        case 'hex':\n            return str.length / 2;\n\n        case 'utf8':\n        case 'utf-8':\n            return utf8ToBytes(str).length;\n\n        case 'ascii':\n        case 'binary':\n            return str.length;\n\n        case 'base64':\n            return base64ToBytes(str).length;\n\n        default:\n            throw new Error('Unknown encoding');\n    }\n};\n\nBuffer.prototype.utf8Write = function (string, offset, length) {\n    var bytes, pos;\n    return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.asciiWrite = function (string, offset, length) {\n    var bytes, pos;\n    return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;\n\nBuffer.prototype.base64Write = function (string, offset, length) {\n    var bytes, pos;\n    return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.base64Slice = function (start, end) {\n    var bytes = Array.prototype.slice.apply(this, arguments)\n    return require(\"base64-js\").fromByteArray(bytes);\n};\n\nBuffer.prototype.utf8Slice = function () {\n    var bytes = Array.prototype.slice.apply(this, arguments);\n    var res = \"\";\n    var tmp = \"\";\n    var i = 0;\n    while (i < bytes.length) {\n        if (bytes[i] <= 0x7F) {\n            res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n            tmp = \"\";\n        } else\n            tmp += \"%\" + bytes[i].toString(16);\n\n        i++;\n    }\n\n    return res + decodeUtf8Char(tmp);\n}\n\nBuffer.prototype.asciiSlice = function () {\n    var bytes = Array.prototype.slice.apply(this, arguments);\n    var ret = \"\";\n    for (var i = 0; i < bytes.length; i++)\n        ret += String.fromCharCode(bytes[i]);\n    return ret;\n}\n\nBuffer.prototype.binarySlice = Buffer.prototype.asciiSlice;\n\nBuffer.prototype.inspect = function() {\n    var out = [],\n        len = this.length;\n    for (var i = 0; i < len; i++) {\n        out[i] = toHex(this[i]);\n        if (i == exports.INSPECT_MAX_BYTES) {\n            out[i + 1] = '...';\n            break;\n        }\n    }\n    return '<Buffer ' + out.join(' ') + '>';\n};\n\n\nBuffer.prototype.hexSlice = function(start, end) {\n    var len = this.length;\n\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n\n    var out = '';\n    for (var i = start; i < end; i++) {\n        out += toHex(this[i]);\n    }\n    return out;\n};\n\n\nBuffer.prototype.toString = function(encoding, start, end) {\n    encoding = String(encoding || 'utf8').toLowerCase();\n    start = +start || 0;\n    if (typeof end == 'undefined') end = this.length;\n\n    // Fastpath empty strings\n    if (+end == start) {\n        return '';\n    }\n\n    switch (encoding) {\n        case 'hex':\n            return this.hexSlice(start, end);\n\n        case 'utf8':\n        case 'utf-8':\n            return this.utf8Slice(start, end);\n\n        case 'ascii':\n            return this.asciiSlice(start, end);\n\n        case 'binary':\n            return this.binarySlice(start, end);\n\n        case 'base64':\n            return this.base64Slice(start, end);\n\n        case 'ucs2':\n        case 'ucs-2':\n            return this.ucs2Slice(start, end);\n\n        default:\n            throw new Error('Unknown encoding');\n    }\n};\n\n\nBuffer.prototype.hexWrite = function(string, offset, length) {\n    offset = +offset || 0;\n    var remaining = this.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = +length;\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2) {\n        throw new Error('Invalid hex string');\n    }\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for (var i = 0; i < length; i++) {\n        var b = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(b)) throw new Error('Invalid hex string');\n        this[offset + i] = b;\n    }\n    Buffer._charsWritten = i * 2;\n    return i;\n};\n\n\nBuffer.prototype.write = function(string, offset, length, encoding) {\n    // Support both (string, offset, length, encoding)\n    // and the legacy (string, encoding, offset, length)\n    if (isFinite(offset)) {\n        if (!isFinite(length)) {\n            encoding = length;\n            length = undefined;\n        }\n    } else {  // legacy\n        var swap = encoding;\n        encoding = offset;\n        offset = length;\n        length = swap;\n    }\n\n    offset = +offset || 0;\n    var remaining = this.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = +length;\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    encoding = String(encoding || 'utf8').toLowerCase();\n\n    switch (encoding) {\n        case 'hex':\n            return this.hexWrite(string, offset, length);\n\n        case 'utf8':\n        case 'utf-8':\n            return this.utf8Write(string, offset, length);\n\n        case 'ascii':\n            return this.asciiWrite(string, offset, length);\n\n        case 'binary':\n            return this.binaryWrite(string, offset, length);\n\n        case 'base64':\n            return this.base64Write(string, offset, length);\n\n        case 'ucs2':\n        case 'ucs-2':\n            return this.ucs2Write(string, offset, length);\n\n        default:\n            throw new Error('Unknown encoding');\n    }\n};\n\n// slice(start, end)\nfunction clamp(index, len, defaultValue) {\n    if (typeof index !== 'number') return defaultValue;\n    index = ~~index;  // Coerce to integer.\n    if (index >= len) return len;\n    if (index >= 0) return index;\n    index += len;\n    if (index >= 0) return index;\n    return 0;\n}\n\nBuffer.prototype.slice = function(start, end) {\n    var len = this.length;\n    start = clamp(start, len, 0);\n    end = clamp(end, len, len);\n    return new Buffer(this, end - start, +start);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n    var source = this;\n    start || (start = 0);\n    if (end === undefined || isNaN(end)) {\n        end = this.length;\n    }\n    target_start || (target_start = 0);\n\n    if (end < start) throw new Error('sourceEnd < sourceStart');\n\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length == 0 || source.length == 0) return 0;\n\n    if (target_start < 0 || target_start >= target.length) {\n        throw new Error('targetStart out of bounds');\n    }\n\n    if (start < 0 || start >= source.length) {\n        throw new Error('sourceStart out of bounds');\n    }\n\n    if (end < 0 || end > source.length) {\n        throw new Error('sourceEnd out of bounds');\n    }\n\n    // Are we oob?\n    if (end > this.length) {\n        end = this.length;\n    }\n\n    if (target.length - target_start < end - start) {\n        end = target.length - target_start + start;\n    }\n\n    var temp = [];\n    for (var i=start; i<end; i++) {\n        assert.ok(typeof this[i] !== 'undefined', \"copying undefined buffer bytes!\");\n        temp.push(this[i]);\n    }\n\n    for (var i=target_start; i<target_start+temp.length; i++) {\n        target[i] = temp[i-target_start];\n    }\n};\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n    value || (value = 0);\n    start || (start = 0);\n    end || (end = this.length);\n\n    if (typeof value === 'string') {\n        value = value.charCodeAt(0);\n    }\n    if (!(typeof value === 'number') || isNaN(value)) {\n        throw new Error('value is not a number');\n    }\n\n    if (end < start) throw new Error('end < start');\n\n    // Fill 0 bytes; we're done\n    if (end === start) return 0;\n    if (this.length == 0) return 0;\n\n    if (start < 0 || start >= this.length) {\n        throw new Error('start out of bounds');\n    }\n\n    if (end < 0 || end > this.length) {\n        throw new Error('end out of bounds');\n    }\n\n    for (var i = start; i < end; i++) {\n        this[i] = value;\n    }\n}\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n    return b instanceof Buffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n    if (!isArray(list)) {\n        throw new Error(\"Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.\");\n    }\n\n    if (list.length === 0) {\n        return new Buffer(0);\n    } else if (list.length === 1) {\n        return list[0];\n    }\n\n    if (typeof totalLength !== 'number') {\n        totalLength = 0;\n        for (var i = 0; i < list.length; i++) {\n            var buf = list[i];\n            totalLength += buf.length;\n        }\n    }\n\n    var buffer = new Buffer(totalLength);\n    var pos = 0;\n    for (var i = 0; i < list.length; i++) {\n        var buf = list[i];\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\n\nBuffer.isEncoding = function(encoding) {\n    switch ((encoding + '').toLowerCase()) {\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n        case 'raw':\n            return true;\n\n        default:\n            return false;\n    }\n};\n\n// helpers\n\nfunction coerce(length) {\n    // Coerce length to a number (possibly NaN), round up\n    // in case it's fractional (e.g. 123.456) then do a\n    // double negate to coerce a NaN to 0. Easy, right?\n    length = ~~Math.ceil(+length);\n    return length < 0 ? 0 : length;\n}\n\nfunction isArray(subject) {\n    return (Array.isArray ||\n    function(subject){\n        return {}.toString.apply(subject) == '[object Array]'\n    })\n    (subject)\n}\n\nfunction isArrayIsh(subject) {\n    return isArray(subject) || Buffer.isBuffer(subject) ||\n        subject && typeof subject === 'object' &&\n        typeof subject.length === 'number';\n}\n\nfunction toHex(n) {\n    if (n < 16) return '0' + n.toString(16);\n    return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n    var byteArray = [];\n    for (var i = 0; i < str.length; i++)\n        if (str.charCodeAt(i) <= 0x7F)\n            byteArray.push(str.charCodeAt(i));\n        else {\n            var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n            for (var j = 0; j < h.length; j++)\n                byteArray.push(parseInt(h[j], 16));\n        }\n\n    return byteArray;\n}\n\nfunction asciiToBytes(str) {\n    var byteArray = []\n    for (var i = 0; i < str.length; i++ )\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push( str.charCodeAt(i) & 0xFF );\n\n    return byteArray;\n}\n\nfunction base64ToBytes(str) {\n    return require(\"base64-js\").toByteArray(str);\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n    var pos, i = 0;\n    while (i < length) {\n        if ((i+offset >= dst.length) || (i >= src.length))\n            break;\n\n        dst[i + offset] = src[i];\n        i++;\n    }\n    return i;\n}\n\nfunction decodeUtf8Char(str) {\n    try {\n        return decodeURIComponent(str);\n    } catch (err) {\n        return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n    }\n}\n\n// read/write bit-twiddling\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n    var buffer = this;\n\n    if (!noAssert) {\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset < buffer.length,\n            'Trying to read beyond buffer length');\n    }\n\n    if (offset >= buffer.length) return;\n\n    return buffer[offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n    var val = 0;\n\n\n    if (!noAssert) {\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 1 < buffer.length,\n            'Trying to read beyond buffer length');\n    }\n\n    if (offset >= buffer.length) return 0;\n\n    if (isBigEndian) {\n        val = buffer[offset] << 8;\n        if (offset + 1 < buffer.length) {\n            val |= buffer[offset + 1];\n        }\n    } else {\n        val = buffer[offset];\n        if (offset + 1 < buffer.length) {\n            val |= buffer[offset + 1] << 8;\n        }\n    }\n\n    return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n    return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n    return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n    var val = 0;\n\n    if (!noAssert) {\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 3 < buffer.length,\n            'Trying to read beyond buffer length');\n    }\n\n    if (offset >= buffer.length) return 0;\n\n    if (isBigEndian) {\n        if (offset + 1 < buffer.length)\n            val = buffer[offset + 1] << 16;\n        if (offset + 2 < buffer.length)\n            val |= buffer[offset + 2] << 8;\n        if (offset + 3 < buffer.length)\n            val |= buffer[offset + 3];\n        val = val + (buffer[offset] << 24 >>> 0);\n    } else {\n        if (offset + 2 < buffer.length)\n            val = buffer[offset + 2] << 16;\n        if (offset + 1 < buffer.length)\n            val |= buffer[offset + 1] << 8;\n        val |= buffer[offset];\n        if (offset + 3 < buffer.length)\n            val = val + (buffer[offset + 3] << 24 >>> 0);\n    }\n\n    return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n    return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n    return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two's complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two's complement value is\n * positive, then we're done, as it's equivalent to the unsigned representation.\n *\n * Now if the number is positive, you're pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren't quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two's\n * complement. (Though it doesn't quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn't quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that's not quite right. But wait, according to\n * Javascript that's perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we've input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we're going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I'm glad we don't support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn't make sense for 8-bit numbers\n * (really it isn't necessary for them). However, when you get 16-bit numbers,\n * you do. Let's go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n    var buffer = this;\n    var neg;\n\n    if (!noAssert) {\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset < buffer.length,\n            'Trying to read beyond buffer length');\n    }\n\n    if (offset >= buffer.length) return;\n\n    neg = buffer[offset] & 0x80;\n    if (!neg) {\n        return (buffer[offset]);\n    }\n\n    return ((0xff - buffer[offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n    var neg, val;\n\n    if (!noAssert) {\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 1 < buffer.length,\n            'Trying to read beyond buffer length');\n    }\n\n    val = readUInt16(buffer, offset, isBigEndian, noAssert);\n    neg = val & 0x8000;\n    if (!neg) {\n        return val;\n    }\n\n    return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n    return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n    return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n    var neg, val;\n\n    if (!noAssert) {\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 3 < buffer.length,\n            'Trying to read beyond buffer length');\n    }\n\n    val = readUInt32(buffer, offset, isBigEndian, noAssert);\n    neg = val & 0x80000000;\n    if (!neg) {\n        return (val);\n    }\n\n    return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n    return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n    return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n    if (!noAssert) {\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset + 3 < buffer.length,\n            'Trying to read beyond buffer length');\n    }\n\n    return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n        23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n    return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n    return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n    if (!noAssert) {\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset + 7 < buffer.length,\n            'Trying to read beyond buffer length');\n    }\n\n    return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n        52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n    return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n    return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n    assert.ok(typeof (value) == 'number',\n        'cannot write a non-number as a number');\n\n    assert.ok(value >= 0,\n        'specified a negative value for writing an unsigned value');\n\n    assert.ok(value <= max, 'value is larger than maximum value for type');\n\n    assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n    var buffer = this;\n\n    if (!noAssert) {\n        assert.ok(value !== undefined && value !== null,\n            'missing value');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset < buffer.length,\n            'trying to write beyond buffer length');\n\n        verifuint(value, 0xff);\n    }\n\n    if (offset < buffer.length) {\n        buffer[offset] = value;\n    }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n    if (!noAssert) {\n        assert.ok(value !== undefined && value !== null,\n            'missing value');\n\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 1 < buffer.length,\n            'trying to write beyond buffer length');\n\n        verifuint(value, 0xffff);\n    }\n\n    for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n        buffer[offset + i] =\n            (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n    }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n    writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n    writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n    if (!noAssert) {\n        assert.ok(value !== undefined && value !== null,\n            'missing value');\n\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 3 < buffer.length,\n            'trying to write beyond buffer length');\n\n        verifuint(value, 0xffffffff);\n    }\n\n    for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n        buffer[offset + i] =\n            (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n    }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n    writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n    writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we're going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we're in\n * slightly better shape. Unfortunately, we really can't do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren't treated as a signed number. Ultimately a bad thing.\n *\n * What we're going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we're going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n    assert.ok(typeof (value) == 'number',\n        'cannot write a non-number as a number');\n\n    assert.ok(value <= max, 'value larger than maximum allowed value');\n\n    assert.ok(value >= min, 'value smaller than minimum allowed value');\n\n    assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nfunction verifIEEE754(value, max, min) {\n    assert.ok(typeof (value) == 'number',\n        'cannot write a non-number as a number');\n\n    assert.ok(value <= max, 'value larger than maximum allowed value');\n\n    assert.ok(value >= min, 'value smaller than minimum allowed value');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n    var buffer = this;\n\n    if (!noAssert) {\n        assert.ok(value !== undefined && value !== null,\n            'missing value');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset < buffer.length,\n            'Trying to write beyond buffer length');\n\n        verifsint(value, 0x7f, -0x80);\n    }\n\n    if (value >= 0) {\n        buffer.writeUInt8(value, offset, noAssert);\n    } else {\n        buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n    }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n    if (!noAssert) {\n        assert.ok(value !== undefined && value !== null,\n            'missing value');\n\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 1 < buffer.length,\n            'Trying to write beyond buffer length');\n\n        verifsint(value, 0x7fff, -0x8000);\n    }\n\n    if (value >= 0) {\n        writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n    } else {\n        writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n    }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n    writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n    writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n    if (!noAssert) {\n        assert.ok(value !== undefined && value !== null,\n            'missing value');\n\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 3 < buffer.length,\n            'Trying to write beyond buffer length');\n\n        verifsint(value, 0x7fffffff, -0x80000000);\n    }\n\n    if (value >= 0) {\n        writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n    } else {\n        writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n    }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n    writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n    writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n    if (!noAssert) {\n        assert.ok(value !== undefined && value !== null,\n            'missing value');\n\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 3 < buffer.length,\n            'Trying to write beyond buffer length');\n\n        verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n    }\n\n    require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n        23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n    writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n    writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n    if (!noAssert) {\n        assert.ok(value !== undefined && value !== null,\n            'missing value');\n\n        assert.ok(typeof (isBigEndian) === 'boolean',\n            'missing or invalid endian');\n\n        assert.ok(offset !== undefined && offset !== null,\n            'missing offset');\n\n        assert.ok(offset + 7 < buffer.length,\n            'Trying to write beyond buffer length');\n\n        verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n    }\n\n    require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n        52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n    writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n    writeDouble(this, value, offset, true, noAssert);\n};\n",
  "events.js": "'use strict';\n\nvar domain;\nvar util = require('util');\n\nfunction EventEmitter() {\n    EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\n//EventEmitter.usingDomains = false;\n\n//EventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\n\nEventEmitter.init = function() {\n    if (!this._events) this._events = {};\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n    var er, handler, len, args, i, listeners;\n\n    if (!this._events)\n        this._events = {};\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error' && !this._events.error) {\n        er = arguments[1];\n        if (er instanceof Error) {\n            throw er; // Unhandled 'error' event\n        } else {\n            throw Error('Uncaught, unspecified \"error\" event.');\n        }\n        return false;\n    }\n\n    handler = this._events[type];\n\n    if (util.isUndefined(handler))\n        return false;\n\n    if (util.isFunction(handler)) {\n        switch (arguments.length) {\n            // fast cases\n            case 1:\n                handler.call(this);\n                break;\n            case 2:\n                handler.call(this, arguments[1]);\n                break;\n            case 3:\n                handler.call(this, arguments[1], arguments[2]);\n                break;\n            // slower\n            default:\n                len = arguments.length;\n                args = new Array(len - 1);\n                for (i = 1; i < len; i++)\n                    args[i - 1] = arguments[i];\n                handler.apply(this, args);\n        }\n    } else if (util.isObject(handler)) {\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n            args[i - 1] = arguments[i];\n\n        listeners = handler.slice();\n        len = listeners.length;\n        for (i = 0; i < len; i++)\n            listeners[i].apply(this, args);\n    }\n\n    return true;\n};\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n    var m;\n\n    if (!util.isFunction(listener))\n        throw TypeError('listener must be a function');\n\n    if (!this._events)\n        this._events = {};\n\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (this._events.newListener)\n        this.emit('newListener', type,\n            util.isFunction(listener.listener) ?\n                listener.listener : listener);\n\n    if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n        this._events[type] = listener;\n    else if (util.isObject(this._events[type]))\n    // If we've already got an array, just append.\n        this._events[type].push(listener);\n    else\n    // Adding the second element, need to change to array.\n        this._events[type] = [this._events[type], listener];\n\n\n    return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function once(type, listener) {\n    if (!util.isFunction(listener))\n        throw TypeError('listener must be a function');\n\n    var fired = false;\n\n    function g() {\n        this.removeListener(type, g);\n\n        if (!fired) {\n            fired = true;\n            listener.apply(this, arguments);\n        }\n    }\n\n    g.listener = listener;\n    this.on(type, g);\n\n    return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n        var list, position, length, i;\n\n        if (!util.isFunction(listener))\n            throw TypeError('listener must be a function');\n\n        if (!this._events || !this._events[type])\n            return this;\n\n        list = this._events[type];\n        length = list.length;\n        position = -1;\n\n        if (list === listener ||\n            (util.isFunction(list.listener) && list.listener === listener)) {\n            delete this._events[type];\n            if (this._events.removeListener)\n                this.emit('removeListener', type, listener);\n\n        } else if (util.isObject(list)) {\n            for (i = length; i-- > 0;) {\n                if (list[i] === listener ||\n                    (list[i].listener && list[i].listener === listener)) {\n                    position = i;\n                    break;\n                }\n            }\n\n            if (position < 0)\n                return this;\n\n            if (list.length === 1) {\n                list.length = 0;\n                delete this._events[type];\n            } else {\n                list.splice(position, 1);\n            }\n\n            if (this._events.removeListener)\n                this.emit('removeListener', type, listener);\n        }\n\n        return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n        var key, listeners;\n\n        if (!this._events)\n            return this;\n\n        // not listening for removeListener, no need to emit\n        if (!this._events.removeListener) {\n            if (arguments.length === 0)\n                this._events = {};\n            else if (this._events[type])\n                delete this._events[type];\n            return this;\n        }\n\n        // emit removeListener for all listeners on all events\n        if (arguments.length === 0) {\n            for (key in this._events) {\n                if (key === 'removeListener') continue;\n                this.removeAllListeners(key);\n            }\n            this.removeAllListeners('removeListener');\n            this._events = {};\n            return this;\n        }\n\n        listeners = this._events[type];\n\n        if (util.isFunction(listeners)) {\n            this.removeListener(type, listeners);\n        } else if (Array.isArray(listeners)) {\n            // LIFO order\n            while (listeners.length)\n                this.removeListener(type, listeners[listeners.length - 1]);\n        }\n        delete this._events[type];\n\n        return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n    var ret;\n    if (!this._events || !this._events[type])\n        ret = [];\n    else if (util.isFunction(this._events[type]))\n        ret = [this._events[type]];\n    else\n        ret = this._events[type].slice();\n    return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n    var ret;\n    if (!emitter._events || !emitter._events[type])\n        ret = 0;\n    else if (util.isFunction(emitter._events[type]))\n        ret = 1;\n    else\n        ret = emitter._events[type].length;\n    return ret;\n};\n",
  "fs.js": "var path = require('path');\n\n\nvar LS = typeof localStorage != 'undefined' ? localStorage : {};\nLS['/tmp'] = null; // `null` means it is a directory.\n\nfunction pathAbsolute(p) {\n    return p;\n}\n\nvar fs = exports;\n\n// Static method to set the stats properties on a Stats object.\nfs.Stats = function(\n    dev,\n    mode,\n    nlink,\n    uid,\n    gid,\n    rdev,\n    blksize,\n    ino,\n    size,\n    blocks,\n    atim_msec,\n    mtim_msec,\n    ctim_msec,\n    birthtim_msec) {\n    this.dev = dev;\n    this.mode = mode;\n    this.nlink = nlink;\n    this.uid = uid;\n    this.gid = gid;\n    this.rdev = rdev;\n    this.blksize = blksize;\n    this.ino = ino;\n    this.size = size;\n    this.blocks = blocks;\n    this.atime = new Date(atim_msec);\n    this.mtime = new Date(mtim_msec);\n    this.ctime = new Date(ctim_msec);\n    this.birthtime = new Date(birthtim_msec);\n};\n\nfs.Stats.prototype.isDirectory = function() {\n    return this._checkModeProperty(constants.S_IFDIR);\n};\n\nfs.Stats.prototype.isFile = function() {\n    return this._checkModeProperty(constants.S_IFREG);\n};\n\nfs.Stats.prototype.isBlockDevice = function() {\n    return this._checkModeProperty(constants.S_IFBLK);\n};\n\nfs.Stats.prototype.isCharacterDevice = function() {\n    return this._checkModeProperty(constants.S_IFCHR);\n};\n\nfs.Stats.prototype.isSymbolicLink = function() {\n    return this._checkModeProperty(constants.S_IFLNK);\n};\n\nfs.Stats.prototype.isFIFO = function() {\n    return this._checkModeProperty(constants.S_IFIFO);\n};\n\nfs.Stats.prototype.isSocket = function() {\n    return this._checkModeProperty(constants.S_IFSOCK);\n};\n\n\nfs.writeFileSync = function(p, data) {\n    LS[p] = data;\n};\n\nfs.writeFile = function(p, data, callback) {\n    try {\n        fs.writeFileSync(p, data);\n        callack();\n    } catch(e) {\n        callback(e);\n    }\n};\n\nfs.readFileSync = function(p, encoding) {\n\n};\n\nfs.existsSync = function(p) {\n\n};\n\n",
  "http.js": "var http = module.exports;\nvar EventEmitter = require('events');\nvar Stream = require('stream');\nvar inherits = require('util').inherits;\nvar url = require('url');\nvar Base64 = require('shim/Base64');\n\n\nvar Response = function (res) {\n    this.offset = 0;\n    this.readable = true;\n};\n\nutil.inherits(Response, Stream);\n\nvar capable = {\n    streaming : true,\n    status2 : true\n};\n\nfunction parseHeaders (res) {\n    var lines = res.getAllResponseHeaders().split(/\\r?\\n/);\n    var headers = {};\n    for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        if (line === '') continue;\n\n        var m = line.match(/^([^:]+):\\s*(.*)/);\n        if (m) {\n            var key = m[1].toLowerCase(), value = m[2];\n\n            if (headers[key] !== undefined) {\n\n                if (isArray(headers[key])) {\n                    headers[key].push(value);\n                }\n                else {\n                    headers[key] = [ headers[key], value ];\n                }\n            }\n            else {\n                headers[key] = value;\n            }\n        }\n        else {\n            headers[line] = true;\n        }\n    }\n    return headers;\n}\n\nResponse.prototype.getResponse = function (xhr) {\n    var respType = String(xhr.responseType).toLowerCase();\n    if (respType === 'blob') return xhr.responseBlob || xhr.response;\n    if (respType === 'arraybuffer') return xhr.response;\n    return xhr.responseText;\n}\n\nResponse.prototype.getHeader = function (key) {\n    return this.headers[key.toLowerCase()];\n};\n\nResponse.prototype.handle = function (res) {\n    if (res.readyState === 2 && capable.status2) {\n        try {\n            this.statusCode = res.status;\n            this.headers = parseHeaders(res);\n        }\n        catch (err) {\n            capable.status2 = false;\n        }\n\n        if (capable.status2) {\n            this.emit('ready');\n        }\n    }\n    else if (capable.streaming && res.readyState === 3) {\n        try {\n            if (!this.statusCode) {\n                this.statusCode = res.status;\n                this.headers = parseHeaders(res);\n                this.emit('ready');\n            }\n        }\n        catch (err) {}\n\n        try {\n            this._emitData(res);\n        }\n        catch (err) {\n            capable.streaming = false;\n        }\n    }\n    else if (res.readyState === 4) {\n        if (!this.statusCode) {\n            this.statusCode = res.status;\n            this.emit('ready');\n        }\n        this._emitData(res);\n\n        if (res.error) {\n            this.emit('error', this.getResponse(res));\n        }\n        else this.emit('end');\n\n        this.emit('close');\n    }\n};\n\nResponse.prototype._emitData = function (res) {\n    var respBody = this.getResponse(res);\n    if (respBody.toString().match(/ArrayBuffer/)) {\n        this.emit('data', new Uint8Array(respBody, this.offset));\n        this.offset = respBody.byteLength;\n        return;\n    }\n    if (respBody.length > this.offset) {\n        this.emit('data', respBody.slice(this.offset));\n        this.offset = respBody.length;\n    }\n};\n\nvar isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n    };\n\n\n\nvar Request = function (xhr, params) {\n    var self = this;\n    self.writable = true;\n    self.xhr = xhr;\n    self.body = [];\n\n    self.uri = (params.protocol || 'http:') + '//'\n        + params.host\n        + (params.port ? ':' + params.port : '')\n        + (params.path || '/')\n    ;\n\n    if (typeof params.withCredentials === 'undefined') {\n        params.withCredentials = true;\n    }\n\n    try { xhr.withCredentials = params.withCredentials }\n    catch (e) {}\n\n    if (params.responseType) try { xhr.responseType = params.responseType }\n    catch (e) {}\n\n    xhr.open(\n        params.method || 'GET',\n        self.uri,\n        true\n    );\n\n    xhr.onerror = function(event) {\n        self.emit('error', new Error('Network error'));\n    };\n\n    self._headers = {};\n\n    if (params.headers) {\n        var keys = objectKeys(params.headers);\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (!self.isSafeRequestHeader(key)) continue;\n            var value = params.headers[key];\n            self.setHeader(key, value);\n        }\n    }\n\n    if (params.auth) {\n        //basic auth\n        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));\n    }\n\n    var res = new Response;\n    res.on('close', function () {\n        self.emit('close');\n    });\n\n    res.on('ready', function () {\n        self.emit('response', res);\n    });\n\n    res.on('error', function (err) {\n        self.emit('error', err);\n    });\n\n    xhr.onreadystatechange = function () {\n        // Fix for IE9 bug\n        // SCRIPT575: Could not complete the operation due to error c00c023f\n        // It happens when a request is aborted, calling the success callback anyway with readyState === 4\n        if (xhr.__aborted) return;\n        res.handle(xhr);\n    };\n};\n\ninherits(Request, Stream);\n\nRequest.prototype.setHeader = function (key, value) {\n    this._headers[key.toLowerCase()] = value\n};\n\nRequest.prototype.getHeader = function (key) {\n    return this._headers[key.toLowerCase()]\n};\n\nRequest.prototype.removeHeader = function (key) {\n    delete this._headers[key.toLowerCase()]\n};\n\nRequest.prototype.write = function (s) {\n    this.body.push(s);\n};\n\nRequest.prototype.destroy = function (s) {\n    this.xhr.__aborted = true;\n    this.xhr.abort();\n    this.emit('close');\n};\n\nRequest.prototype.end = function (s) {\n    if (s !== undefined) this.body.push(s);\n\n    var keys = objectKeys(this._headers);\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = this._headers[key];\n        if (isArray(value)) {\n            for (var j = 0; j < value.length; j++) {\n                this.xhr.setRequestHeader(key, value[j]);\n            }\n        }\n        else this.xhr.setRequestHeader(key, value)\n    }\n\n    if (this.body.length === 0) {\n        this.xhr.send('');\n    }\n    else if (typeof this.body[0] === 'string') {\n        this.xhr.send(this.body.join(''));\n    }\n    else if (isArray(this.body[0])) {\n        var body = [];\n        for (var i = 0; i < this.body.length; i++) {\n            body.push.apply(body, this.body[i]);\n        }\n        this.xhr.send(body);\n    }\n    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {\n        var len = 0;\n        for (var i = 0; i < this.body.length; i++) {\n            len += this.body[i].length;\n        }\n        var body = new(this.body[0].constructor)(len);\n        var k = 0;\n\n        for (var i = 0; i < this.body.length; i++) {\n            var b = this.body[i];\n            for (var j = 0; j < b.length; j++) {\n                body[k++] = b[j];\n            }\n        }\n        this.xhr.send(body);\n    }\n    else if (isXHR2Compatible(this.body[0])) {\n        this.xhr.send(this.body[0]);\n    }\n    else {\n        var body = '';\n        for (var i = 0; i < this.body.length; i++) {\n            body += this.body[i].toString();\n        }\n        this.xhr.send(body);\n    }\n};\n\n// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html\nRequest.unsafeHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"cookie\",\n    \"cookie2\",\n    \"content-transfer-encoding\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"user-agent\",\n    \"via\"\n];\n\nRequest.prototype.isSafeRequestHeader = function (headerName) {\n    if (!headerName) return false;\n    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;\n};\n\nvar objectKeys = Object.keys || function (obj) {\n        var keys = [];\n        for (var key in obj) keys.push(key);\n        return keys;\n    };\n\nvar isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n    };\n\nvar indexOf = function (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (xs[i] === x) return i;\n    }\n    return -1;\n};\n\nvar isXHR2Compatible = function (obj) {\n    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;\n    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;\n    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;\n};\n\n\nhttp.request = function (params, cb) {\n    if (typeof params === 'string') {\n        params = url.parse(params)\n    }\n    if (!params) params = {};\n    if (!params.host && !params.port) {\n        params.port = parseInt(window.location.port, 10);\n    }\n    if (!params.host && params.hostname) {\n        params.host = params.hostname;\n    }\n\n    if (!params.protocol) {\n        if (params.scheme) {\n            params.protocol = params.scheme + ':';\n        } else {\n            params.protocol = window.location.protocol;\n        }\n    }\n\n    if (!params.host) {\n        params.host = window.location.hostname || window.location.host;\n    }\n    if (/:/.test(params.host)) {\n        if (!params.port) {\n            params.port = params.host.split(':')[1];\n        }\n        params.host = params.host.split(':')[0];\n    }\n    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;\n\n    var req = new Request(new xhrHttp, params);\n    if (cb) req.on('response', cb);\n    return req;\n};\n\nhttp.get = function (params, cb) {\n    params.method = 'GET';\n    var req = http.request(params, cb);\n    req.end();\n    return req;\n};\n\nhttp.Agent = function () {};\nhttp.Agent.defaultMaxSockets = 4;\n\nvar xhrHttp = (function () {\n    if (typeof window === 'undefined') {\n        throw new Error('no window object present');\n    }\n    else if (window.XMLHttpRequest) {\n        return window.XMLHttpRequest;\n    }\n    else if (window.ActiveXObject) {\n        var axs = [\n            'Msxml2.XMLHTTP.6.0',\n            'Msxml2.XMLHTTP.3.0',\n            'Microsoft.XMLHTTP'\n        ];\n        for (var i = 0; i < axs.length; i++) {\n            try {\n                var ax = new(window.ActiveXObject)(axs[i]);\n                return function () {\n                    if (ax) {\n                        var ax_ = ax;\n                        ax = null;\n                        return ax_;\n                    }\n                    else {\n                        return new(window.ActiveXObject)(axs[i]);\n                    }\n                };\n            }\n            catch (e) {}\n        }\n        throw new Error('ajax not supported in this browser')\n    }\n    else {\n        throw new Error('ajax not supported in this browser');\n    }\n})();\n\nhttp.STATUS_CODES = {\n    100 : 'Continue',\n    101 : 'Switching Protocols',\n    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918\n    200 : 'OK',\n    201 : 'Created',\n    202 : 'Accepted',\n    203 : 'Non-Authoritative Information',\n    204 : 'No Content',\n    205 : 'Reset Content',\n    206 : 'Partial Content',\n    207 : 'Multi-Status',               // RFC 4918\n    300 : 'Multiple Choices',\n    301 : 'Moved Permanently',\n    302 : 'Moved Temporarily',\n    303 : 'See Other',\n    304 : 'Not Modified',\n    305 : 'Use Proxy',\n    307 : 'Temporary Redirect',\n    400 : 'Bad Request',\n    401 : 'Unauthorized',\n    402 : 'Payment Required',\n    403 : 'Forbidden',\n    404 : 'Not Found',\n    405 : 'Method Not Allowed',\n    406 : 'Not Acceptable',\n    407 : 'Proxy Authentication Required',\n    408 : 'Request Time-out',\n    409 : 'Conflict',\n    410 : 'Gone',\n    411 : 'Length Required',\n    412 : 'Precondition Failed',\n    413 : 'Request Entity Too Large',\n    414 : 'Request-URI Too Large',\n    415 : 'Unsupported Media Type',\n    416 : 'Requested Range Not Satisfiable',\n    417 : 'Expectation Failed',\n    418 : 'I\\'m a teapot',              // RFC 2324\n    422 : 'Unprocessable Entity',       // RFC 4918\n    423 : 'Locked',                     // RFC 4918\n    424 : 'Failed Dependency',          // RFC 4918\n    425 : 'Unordered Collection',       // RFC 4918\n    426 : 'Upgrade Required',           // RFC 2817\n    428 : 'Precondition Required',      // RFC 6585\n    429 : 'Too Many Requests',          // RFC 6585\n    431 : 'Request Header Fields Too Large',// RFC 6585\n    500 : 'Internal Server Error',\n    501 : 'Not Implemented',\n    502 : 'Bad Gateway',\n    503 : 'Service Unavailable',\n    504 : 'Gateway Time-out',\n    505 : 'HTTP Version Not Supported',\n    506 : 'Variant Also Negotiates',    // RFC 2295\n    507 : 'Insufficient Storage',       // RFC 4918\n    509 : 'Bandwidth Limit Exceeded',\n    510 : 'Not Extended',               // RFC 2774\n    511 : 'Network Authentication Required' // RFC 6585\n};\n",
  "module.js": "'use strict';\nvar NM = require('nm');\nvar util = require('util');\nvar assert = require('assert').ok;\nvar fs = require('fs');\nvar path = require('path');\n\n\n// `var runInThisContext = require('vm').runInThisContext;`\n// For now we do it like this, since the `vm` implements it with `eval` anyways. The benefit is that\n// this makes `vm` module no required for our minimal build.\nvar runInThisContext = eval;\n\n// Folder where `node_modules` are stored.\nvar node_modules_folder = 'node_modules';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\nfunction Module(id, parent) {\n    this.id = id;\n    this.exports = {};\n    this.parent = parent;\n    if(parent && parent.children) {\n        parent.children.push(this);\n    }\n    this.filename = null;\n    this.loaded = false;\n    this.children = [];\n}\nmodule.exports = Module;\n\nModule._cache = {};\nModule._pathCache = {};\nModule._extensions = {};\nvar modulePaths = [];\nModule.globalPaths = [];\n\nModule.wrapper = NM.wrapper;\nModule.wrap = NM.wrap;\n\n\n// Wrap `debug()` calls into this variable, so that minifier removes them altogether.\nvar __DEBUG__ = false;\n\n// TODO: Remove in mini-version.\nModule._debug = util.debuglog('module');\n\n// We use this alias for the preprocessor that filters it out\n// TODO: Remove in mini-version.\nvar debug = Module._debug;\n\n\n// given a module name, and a list of paths to test, returns the first\n// matching file in the following precedence.\n//\n// require(\"a.<ext>\")\n//   -> a.<ext>\n//\n// require(\"a\")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\nfunction statPath(path) {\n    try {\n        return fs.statSync(path);\n    } catch (ex) {}\n    return false;\n}\n\n// check if the directory is a package.json dir\nvar packageMainCache = {};\n\nfunction readPackage(requestPath) {\n    if (hasOwnProperty(packageMainCache, requestPath)) {\n        return packageMainCache[requestPath];\n    }\n\n    try {\n        var jsonPath = path.resolve(requestPath, 'package.json');\n        var json = fs.readFileSync(jsonPath, 'utf8');\n    } catch (e) {\n        return false;\n    }\n\n    try {\n        var pkg = packageMainCache[requestPath] = JSON.parse(json).main;\n    } catch (e) {\n        e.path = jsonPath;\n        e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n        throw e;\n    }\n    return pkg;\n}\n\nfunction tryPackage(requestPath, exts) {\n    // TODO: Shall we just assume `index.js`, if no package.json available, so that we don't have to include those.\n    var pkg = readPackage(requestPath);\n\n    if (!pkg) return false;\n\n    var filename = path.resolve(requestPath, pkg);\n    return tryFile(filename) || tryExtensions(filename, exts) ||\n        tryExtensions(path.resolve(filename, 'index'), exts);\n}\n\n// In order to minimize unnecessary lstat() calls,\n// this cache is a list of known-real paths.\n// Set to an empty object to reset.\n// TODO: Don't need that since our `fs` is in-memory anyways.\n//Module._realpathCache = {};\n\n// check if the file exists and is not a directory\nfunction tryFile(requestPath) {\n    var stats = statPath(requestPath);\n    if (stats && !stats.isDirectory()) {\n        //return fs.realpathSync(requestPath, Module._realpathCache);\n        return fs.realpathSync(requestPath);\n    }\n    return false;\n}\n\n// given a path check a the file exists with any of the set extensions\nfunction tryExtensions(p, exts) {\n    for (var i = 0, EL = exts.length; i < EL; i++) {\n        var filename = tryFile(p + exts[i]);\n\n        if (filename) {\n            return filename;\n        }\n    }\n    return false;\n}\n\n\nModule._findPath = function(request, paths) {\n    var exts = Object.keys(Module._extensions);\n\n    if (request.charAt(0) === '/') {\n        paths = [''];\n    }\n\n    var trailingSlash = (request.slice(-1) === '/');\n\n    var cacheKey = JSON.stringify({request: request, paths: paths});\n    if (Module._pathCache[cacheKey]) {\n        return Module._pathCache[cacheKey];\n    }\n\n    // For each path\n    for (var i = 0, PL = paths.length; i < PL; i++) {\n        var basePath = path.resolve(paths[i], request);\n\n        var filename;\n\n        if (!trailingSlash) {\n            // try to join the request to the path\n            filename = tryFile(basePath);\n\n            if (!filename && !trailingSlash) {\n                // try it with each of the extensions\n                filename = tryExtensions(basePath, exts);\n            }\n        }\n\n        if (!filename) {\n            filename = tryPackage(basePath, exts);\n        }\n\n        if (!filename) {\n            // try it with each of the extensions at \"index\"\n            filename = tryExtensions(path.resolve(basePath, 'index'), exts);\n        }\n\n        if (filename) {\n            Module._pathCache[cacheKey] = filename;\n            return filename;\n        }\n    }\n    return false;\n};\n\n// 'from' is the __dirname of the module.\nModule._nodeModulePaths = function(from) {\n    // guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    // TODO: process.platform = 'browser'\n    //var splitRe = process.platform === 'win32' ? /[\\/\\\\]/ : /\\//;\n    var splitRe = /\\//;\n    var paths = [];\n    var parts = from.split(splitRe);\n\n    for (var tip = parts.length - 1; tip >= 0; tip--) {\n        // don't search in .../node_modules/node_modules\n        if (parts[tip] === node_modules_folder) continue;\n        var dir = parts.slice(0, tip + 1).concat(node_modules_folder).join(path.sep);\n        paths.push(dir);\n    }\n\n    return paths;\n};\n\n\nModule._resolveLookupPaths = function(request, parent) {\n\n    if (NM.exists(request)) {\n        return [request, []];\n    }\n\n    var start = request.substring(0, 2);\n    if (start !== './' && start !== '..') {\n        var paths = modulePaths;\n        if (parent) {\n            if (!parent.paths) parent.paths = [];\n            paths = parent.paths.concat(paths);\n        }\n        return [request, paths];\n    }\n\n    // with --eval, parent.id is not set and parent.filename is null\n    if (!parent || !parent.id || !parent.filename) {\n        // make require('./path/to/foo') work - normally the path is taken\n        // from realpath(__filename) but with eval there is no filename\n        var mainPaths = ['.'].concat(modulePaths);\n        mainPaths = Module._nodeModulePaths('.').concat(mainPaths);\n        return [request, mainPaths];\n    }\n\n    // Is the parent an index module?\n    // We can assume the parent has a valid extension,\n    // as it already has been accepted as a module.\n    var isIndex = /^index\\.\\w+?$/.test(path.basename(parent.filename));\n    var parentIdPath = isIndex ? parent.id : path.dirname(parent.id);\n    var id = path.resolve(parentIdPath, request);\n\n    // make sure require('./path') and require('path') get distinct ids, even\n    // when called from the toplevel js file\n    if (parentIdPath === '.' && id.indexOf('/') === -1) {\n        id = './' + id;\n    }\n\n    if(__DEBUG__) {\n        debug('RELATIVE: requested:' + request +\n            ' set ID to: ' + id + ' from ' + parent.id);\n    }\n\n    return [id, [path.dirname(parent.filename)]];\n};\n\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call `NM.require()` with the\n//    filename and return the result.\n// 3. Otherwise, create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request, parent, isMain) {\n    if(parent) {\n        if(__DEBUG__) {\n            debug('Module._load REQUEST  ' + (request) + ' parent: ' + parent.id);\n        }\n    }\n\n    var filename = Module._resolveFilename(request, parent);\n\n    var cachedModule = Module._cache[filename];\n    if(cachedModule) {\n        return cachedModule.exports;\n    }\n\n    if (NM.exists(filename)) {\n        // REPL is a special case, because it needs the real require.\n        // TODO: We don't have `repl`.\n        //if (filename == 'repl') {\n        //    var replModule = new Module('repl');\n        //    replModule._compile(NM.getSource('repl'), 'repl.js');\n        //    NM._cache.repl = replModule;\n        //    return replModule.exports;\n        //}\n\n        if(__DEBUG__) {\n            debug('load native module ' + request);\n        }\n        return NM.require(filename);\n    }\n\n    var module = new Module(filename, parent);\n\n    if (isMain) {\n        process.mainModule = module;\n        module.id = '.';\n    }\n\n    Module._cache[filename] = module;\n\n    var hadException = true;\n\n    try {\n        module.load(filename);\n        hadException = false;\n    } finally {\n        if (hadException) {\n            delete Module._cache[filename];\n        }\n    }\n\n    return module.exports;\n};\n\nModule._resolveFilename = function(request, parent) {\n    if (NM.exists(request)) {\n        return request;\n    }\n\n    var resolvedModule = Module._resolveLookupPaths(request, parent);\n    var id = resolvedModule[0];\n    var paths = resolvedModule[1];\n\n    // look up the filename first, since that's the cache key.\n    if(__DEBUG__) {\n        debug('looking for ' + JSON.stringify(id) +\n            ' in ' + JSON.stringify(paths));\n    }\n\n    var filename = Module._findPath(request, paths);\n\n    if (!filename) {\n        var err = new Error(\"Cannot find module '\" + request + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n    }\n    return filename;\n};\n\n\n// Given a file name, pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n    if(__DEBUG__) {\n        debug('load ' + JSON.stringify(filename) +\n            ' for module ' + JSON.stringify(this.id));\n    }\n\n    assert(!this.loaded);\n    this.filename = filename;\n    this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n    var extension = path.extname(filename) || '.js';\n    if (!Module._extensions[extension]) extension = '.js';\n    Module._extensions[extension](this, filename);\n    this.loaded = true;\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(path) {\n    assert(path, 'missing path');\n    assert(util.isString(path), 'path must be a string');\n    return Module._load(path, this);\n};\n\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require, module, exports) to\n// the file.\n// Returns exception, if any.\nModule.prototype._compile = function(content, filename) {\n    var self = this;\n    // remove shebang\n    content = content.replace(/^\\#\\!.*/, '');\n\n    function require(path) {\n        return self.require(path);\n    }\n\n    require.resolve = function(request) {\n        return Module._resolveFilename(request, self);\n    };\n\n    Object.defineProperty(require, 'paths', { get: function() {\n        throw new Error('require.paths is removed. Use ' +\n            'node_modules folders, or the NODE_PATH ' +\n            'environment variable instead.');\n    }});\n\n    require.main = process.mainModule;\n\n    // Enable support to add extra extension types\n    require.extensions = Module._extensions;\n    require.registerExtension = function() {\n        throw new Error('require.registerExtension() removed. Use ' +\n            'require.extensions instead.');\n    };\n\n    require.cache = Module._cache;\n\n    var dirname = path.dirname(filename);\n\n    // create wrapper function\n    var wrapper = Module.wrap(content);\n\n    var compiledWrapper = runInThisContext(wrapper);\n    var args = [self.exports, require, self, filename, dirname];\n    return compiledWrapper.apply(self.exports, args);\n};\n\n\nfunction stripBOM(content) {\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    // TODO: We need this?\n    if (content.charCodeAt(0) === 0xFEFF) {\n        content = content.slice(1);\n    }\n    return content;\n}\n\n\n// Native extension for .js\nModule._extensions['.js'] = function(module, filename) {\n    var content = fs.readFileSync(filename, 'utf8');\n    module._compile(stripBOM(content), filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module, filename) {\n    var content = fs.readFileSync(filename, 'utf8');\n    try {\n        module.exports = JSON.parse(stripBOM(content));\n    } catch (err) {\n        err.message = filename + ': ' + err.message;\n        throw err;\n    }\n};\n\n\n//Native extension for .node\n//Module._extensions['.node'] = process.dlopen;\n\n\n// bootstrap main module.\nModule.runMain = function() {\n    // Load the main module--the command line argument.\n\n    // Should it be `process.argv[1]` instead.\n    //Module._load(process.argv[1], null, true);\n    Module._load(process.argv[0], null, true);\n\n    // Handle any nextTicks added in the first tick of the program\n    //process._tickCallback();\n};\n\nModule._initPaths = function() {\n    var paths = [path.resolve('..', '..', 'lib', 'portable')];\n    //var paths = [path.resolve(process.execPath, '..', '..', 'lib', 'node')];\n\n    //var homeDir = process.env.HOME;\n    //if(homeDir) {\n    //    paths.unshift(path.resolve(homeDir, '.node_libraries'));\n    //    paths.unshift(path.resolve(homeDir, '.node_modules'));\n    //}\n\n    //var nodePath = process.env['NODE_PATH'];\n    //if (nodePath) {\n    //    paths = nodePath.split(path.delimiter).concat(paths);\n    //}\n\n    modulePaths = paths;\n\n    // clone as a read-only copy, for introspection.\n    Module.globalPaths = modulePaths.slice(0);\n};\n\nModule._initPaths();\n\n// backwards compatibility\n// TODO: Do we need this? Will be removed, if not.\nModule.Module = Module;\n",
  "nodefs.js": "/// <reference path=\"typings/tsd.d.ts\" />\nvar __extends = this.__extends || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        __.prototype = b.prototype;\n        d.prototype = new __();\n    };\n// We should not have a dependency on `fs` module. Rather the correct `fs` module is injected into `Drive.attach()`.\n//var fs = require('fs');\n/**\n * path.resolve\n * path.sep\n * path.relative\n */\nvar path = require('path');\nvar time = new Date;\nvar LNode = (function () {\n    function LNode(layer, path) {\n        // File descriptor, negative, because a real file descriptors cannot be negative.\n        this.fd = LNode.fd--;\n        this.layer = layer;\n        this.path = path;\n    }\n    LNode.prototype.getData = function () {\n        return '';\n    };\n    LNode.prototype.setData = function (data) {\n    };\n    LNode.prototype.getPath = function () {\n        return this.layer.mountpoint + this.path;\n    };\n    LNode.prototype.stats = function () {\n        return this.layer.drive.Stats.build(this);\n    };\n    LNode.prototype.rename = function (new_name) {\n        new_name = this.layer.getRelativePath(new_name);\n        var old_name = this.path;\n        this.path = new_name;\n        this.layer.nodes[new_name] = this;\n        delete this.layer.nodes[old_name];\n        return new_name;\n    };\n    LNode.fd = -1;\n    return LNode;\n})();\nvar LFile = (function (_super) {\n    __extends(LFile, _super);\n    function LFile() {\n        _super.apply(this, arguments);\n    }\n    LFile.prototype.getData = function () {\n        return this.layer.files[this.path];\n    };\n    LFile.prototype.setData = function (data) {\n        this.layer.files[this.path] = data.toString();\n    };\n    LFile.prototype.rename = function (new_name) {\n        var old_name = this.path;\n        new_name = _super.prototype.rename.call(this, new_name);\n        this.layer.files[new_name] = this.layer.files[old_name];\n        delete this.layer.files[old_name];\n    };\n    return LFile;\n})(LNode);\nvar LDirectory = (function (_super) {\n    __extends(LDirectory, _super);\n    function LDirectory() {\n        _super.apply(this, arguments);\n    }\n    return LDirectory;\n})(LNode);\n/**\n * A single `JSON` file of data mounted to a single mount point.\n */\nvar Layer = (function () {\n    function Layer(mountpoint) {\n        /**\n         * Array of directory steps to the `mountpoint`.\n         */\n        this.steps = [];\n        /**\n         * A map of relative file names to file contents 'string'.\n         * {\n         *  \"test.txt\": \"....\"\n         *  \"some/path/hello.txt\": \"world ...\"\n         * }\n         */\n        this.files = {};\n        /**\n         * Relative path mapping to `LNode` objects.\n         */\n        this.nodes = {};\n        /**\n         * A map of pseudo 'file descriptors' to LNodes.\n         */\n        this.fds = {};\n        this.mountpoint = path.resolve(mountpoint);\n        this.steps = this.mountpoint.split(path.sep);\n        this.mountpoint += path.sep;\n    }\n    Layer.prototype.getRelativePath = function (filepath) {\n        return path.relative(this.mountpoint, filepath);\n    };\n    Layer.prototype.getNode = function (p) {\n        var relative = this.getRelativePath(p);\n        if (this.nodes[relative])\n            return this.nodes[relative];\n        else\n            return null;\n    };\n    Layer.prototype.getFile = function (p) {\n        var node = this.getNode(p);\n        return node instanceof LFile ? node : null;\n    };\n    Layer.prototype.getDirectory = function (p) {\n        var node = this.getNode(p);\n        return node instanceof LDirectory ? node : null;\n    };\n    Layer.prototype.getByFd = function (fd) {\n        return this.fds[fd];\n    };\n    Layer.prototype.addNode = function (node) {\n        if (node instanceof LFile) {\n            this.nodes[node.path] = node;\n        }\n        this.fds[node.fd] = node;\n        var parts = node.path.split(path.sep);\n        if (parts.length > 1) {\n            var p = parts[0];\n            for (var i = 1; i < parts.length; i++) {\n                this.nodes[p] = new LDirectory(this, p);\n                p += path.sep + parts[i];\n            }\n        }\n    };\n    Layer.prototype.generateNodes = function (archive) {\n        if (archive === void 0) { archive = {}; }\n        this.files = archive;\n        for (var filepath in this.files) {\n            var node = new LFile(this, filepath);\n            this.addNode(node);\n        }\n    };\n    /**\n     * Return relative path if the path is insided the mounting point of this layer.\n     * @param p\n     */\n    Layer.prototype.relativePathIfInMp = function (p) {\n        var rel = path.relative(this.mountpoint, p);\n        console.log(rel);\n        if ((rel[0] == '.') && (rel[1] == '.'))\n            return false;\n        else\n            return rel;\n    };\n    /**\n     * Path points to above or to mount point.\n     * @param abs_path\n     * @returns {boolean}\n     */\n    Layer.prototype.isAboveMp = function (abs_path) {\n        return abs_path == this.mountpoint.substr(0, abs_path.length);\n    };\n    /**\n     * Path points inside or to mount point.\n     * @param abs_path\n     * @returns {boolean}\n     */\n    Layer.prototype.isInMp = function (abs_path) {\n        return this.mountpoint == abs_path.substr(0, this.mountpoint.length);\n    };\n    Layer.prototype.stepsMatch = function (steps) {\n        var min = Math.min(steps.length, this.steps.length);\n        for (var i = 0; i < min; i++) {\n            if (steps[i] != this.steps[i])\n                break;\n        }\n        return i;\n    };\n    Layer.prototype.readdir = function (abs_path) {\n        if (!abs_path)\n            return [];\n        // Edge case when we have '/'.\n        if (abs_path[abs_path.length - 1] == path.sep)\n            abs_path = abs_path.substr(0, abs_path.length - 1);\n        var steps = abs_path.split(path.sep);\n        var steps_match = this.stepsMatch(steps);\n        var points_to_mountpoint = this.steps.length == steps_match;\n        // Is not pointing to or inside the mount point.\n        if (!points_to_mountpoint) {\n            if (steps_match == steps.length) {\n                return this.steps[steps_match];\n            }\n            else {\n                return [];\n            }\n        }\n        // Points to or inside the mount point.\n        var rel = path.relative(this.mountpoint, abs_path);\n        var expr = \"^\" + (rel ? rel + path.sep : '') + \"([^\" + path.sep + \"]*)(\" + path.sep + \")?\";\n        var files = [];\n        var regex = new RegExp(expr);\n        for (var npath in this.nodes) {\n            var match = npath.match(regex);\n            if (match) {\n                files.push(match[1]);\n            }\n        }\n        return files;\n    };\n    return Layer;\n})();\n/**\n * A collection of layers, we have this, so that we override functions with `.attach()` only once.\n */\nvar Drive = (function () {\n    function Drive() {\n        /**\n         * Collection of file layers, where the top ones owerride the bottom ones.\n         */\n        this.layers = [];\n        /**\n         * `fs` overrides already attached.\n         */\n        this.attached = false;\n    }\n    /**\n     * Create our `Stats` class that extends (or does not) the `fs.Stats`.\n     * @param fs\n     */\n    Drive.prototype.createStatsClass = function (fs) {\n        function Stats() {\n            this.uid = process.getuid();\n            this.gid = process.getgid();\n            this.rdev = 0;\n            this.blksize = 4096;\n            this.ino = 0;\n            this.size = 0;\n            this.blocks = 1;\n            this.atime = time;\n            this.mtime = time;\n            this.ctime = time;\n            this.birthtime = time;\n            this.dev = 0;\n            this.mode = 0;\n            this.nlink = 0;\n            this._isFile = false;\n            this._isDirectory = false;\n        }\n        if (fs) {\n            var tmp = function () {\n            };\n            tmp.prototype = fs.Stats.prototype;\n            Stats.prototype = new tmp();\n            Stats.prototype.constructor = Stats;\n        }\n        Stats.prototype.isFile = function () {\n            return this._isFile;\n        };\n        Stats.prototype.isDirectory = function () {\n            return this._isDirectory;\n        };\n        Stats.prototype.isSymbolicLink = function () {\n            return false;\n        };\n        Stats.build = function (node) {\n            var stats = new Stats;\n            if (node instanceof LDirectory) {\n                stats._isDirectory = true;\n            }\n            else if (node instanceof LFile) {\n                var data = node.getData();\n                stats.size = data.length;\n                stats._isFile = true;\n            }\n            return stats;\n        };\n        this.Stats = Stats;\n    };\n    /**\n     * Attach this drive to `fs`.\n     */\n    Drive.prototype.attach = function (fs) {\n        if (!arguments.length)\n            fs = require('fs');\n        this.createStatsClass(fs);\n        var self = this;\n        fs = fs || {};\n        // fs.readFileSync(filename[, options])\n        var readFileSync = fs.readFileSync;\n        this.readFileSync = fs.readFileSync = function (file, opts) {\n            var f = self.getFile(file);\n            if (f)\n                return opts ? f.getData() : new Buffer(f.getData());\n            else\n                return readFileSync.apply(fs, arguments);\n        };\n        // fs.readFile(filename[, options], callback)\n        var readFile = fs.readFile;\n        this.readFile = fs.readFile = function (file, opts, cb) {\n            if (typeof opts == \"function\") {\n                cb = opts;\n                opts = {};\n            }\n            var f = self.getFile(file);\n            if (f) {\n                process.nextTick(function () {\n                    if ((typeof opts == \"object\") && opts.encoding) {\n                        cb(null, f.getData());\n                    }\n                    else {\n                        cb(null, new Buffer(f.getData()));\n                    }\n                });\n            }\n            else\n                return readFile.apply(fs, arguments);\n        };\n        // fs.realpathSync(path[, cache])\n        var realpathSync = fs.realpathSync;\n        this.realpathSync = fs.realpathSync = function (file, opts) {\n            var node = self.getNode(file);\n            if (node)\n                return node.getPath();\n            else\n                return realpathSync.apply(fs, arguments);\n        };\n        // fs.realpath(path[, cache], callback)\n        var realpath = fs.realpath;\n        this.realpath = fs.realpath = function (filepath, cache, callback) {\n            if (typeof cache == \"function\")\n                callback = cache;\n            var node = self.getNode(filepath);\n            if (node) {\n                process.nextTick(function () {\n                    callback(null, node.getPath());\n                });\n            }\n            else\n                realpath.apply(fs, arguments);\n        };\n        // fs.statSync(path)\n        var statSync = fs.statSync;\n        this.statSync = fs.statSync = function (p) {\n            //console.log('statSync', p);\n            var f = self.getNode(p);\n            return f ? f.stats() : statSync.apply(fs, arguments);\n        };\n        // fs.lstatSync(path)\n        var lstatSync = fs.lstatSync;\n        this.lstatSync = fs.lstatSync = function (p) {\n            var f = self.getNode(p);\n            return f ? f.stats() : lstatSync.apply(fs, arguments);\n        };\n        //fs.renameSync(oldPath, newPath)\n        var renameSync = fs.renameSync;\n        this.renameSync = fs.renameSync = function (oldPath, newPath) {\n            var n = self.getNode(oldPath);\n            if (n)\n                n.rename(newPath);\n            else\n                return renameSync.apply(fs, arguments);\n        };\n        //fs.renameSync(oldPath, newPath)\n        var rename = fs.rename;\n        this.rename = fs.rename = function (oldPath, newPath, cb) {\n            var n = self.getNode(oldPath);\n            if (n) {\n                n.rename(newPath);\n                process.nextTick(cb);\n            }\n            else\n                return rename.apply(fs, arguments);\n        };\n        //fs.fstatSync(fd)\n        var fstatSync = fs.fstatSync;\n        this.fstatSync = fs.fstatSync = function (fd) {\n            var n = self.getByFd(fd);\n            return n ? n.stats() : fstatSync.apply(fs, arguments);\n        };\n        // fs.fstat(fd, callback)\n        var fstat = fs.fstat;\n        this.fstat = fs.fstat = function (fd, callback) {\n            var n = self.getByFd(fd);\n            if (n)\n                process.nextTick(function () {\n                    callback(null, n.stats());\n                });\n            else\n                fstat.apply(fs, arguments);\n        };\n        // fs.writeFileSync(filename, data[, options])\n        var writeFileSync = fs.writeFileSync;\n        this.writeFileSync = fs.writeFileSync = function (filename, data, options) {\n            var n = self.getFile(filename);\n            if (n) {\n                n.setData(data);\n                return undefined;\n            }\n            else {\n                return writeFileSync.apply(fs, arguments);\n            }\n        };\n        // fs.writeFile(filename, data[, options], callback)\n        var writeFile = fs.writeFile;\n        this.writeFile = fs.writeFile = function (filename, data, options, callback) {\n            if (typeof options == \"function\") {\n                callback = options;\n            }\n            var n = self.getFile(filename);\n            if (n) {\n                n.setData(data);\n                if (callback)\n                    process.nextTick(callback);\n            }\n            else {\n                writeFile.apply(fs, arguments);\n            }\n        };\n        // fs.existsSync(filename)\n        var existsSync = fs.existsSync;\n        this.existsSync = fs.existsSync = function (filename) {\n            var n = self.getFile(filename);\n            return n ? true : existsSync.apply(fs, filename);\n        };\n        // fs.exists(filename, callback)\n        var exists = fs.exists;\n        this.exists = fs.exists = function (filename, callback) {\n            var n = self.getFile(filename);\n            if (n) {\n                if (callback)\n                    process.nextTick(function () {\n                        callback(true);\n                    });\n            }\n            else {\n                writeFile.apply(fs, arguments);\n            }\n        };\n        // Remove duplicates.\n        function removeDupes(arr) {\n            return arr.sort().filter(function (item, pos, ary) {\n                return !pos || item != ary[pos - 1];\n            });\n        }\n        // fs.readdirSync(path)\n        var _readdirSync = function (p) {\n            var files = [];\n            p = path.resolve(p);\n            for (var i = 0; i < this.layers.length; i++) {\n                var layer = this.layers[i];\n                files = files.concat(layer.readdir(p));\n            }\n            return files;\n        }.bind(this);\n        var readdirSync = fs.readdirSync;\n        this.readdirSync = fs.readdirSync = function (p) {\n            var files = _readdirSync(p);\n            if (readdirSync) {\n                try {\n                    files = files.concat(readdirSync.apply(fs, arguments));\n                }\n                catch (e) {\n                    if (!files.length)\n                        throw e;\n                }\n            }\n            return removeDupes(files);\n        };\n        // fs.readdir(path, callback)\n        var readdir = fs.readdir;\n        this.readdir = fs.readdir = function (p, callback) {\n            var files = _readdirSync(p);\n            if (readdir) {\n                readdir.call(fs, p, function (err, more_files) {\n                    if (err) {\n                        if (!files.length) {\n                            return callback(err);\n                        }\n                        else {\n                            callback(null, files);\n                        }\n                    }\n                    files = files.concat(more_files);\n                    callback(null, removeDupes(files));\n                });\n            }\n            else {\n                process.nextTick(function () {\n                    callback(null, removeDupes(files));\n                });\n            }\n        };\n        // fs.appendFileSync(filename, data[, options])\n        var appendFileSync = fs.appendFileSync;\n        this.appendFileSync = fs.appendFileSync = function (file, data) {\n            var f = self.getFile(file);\n            if (f)\n                f.setData(f.getData() + data.toString());\n            else\n                appendFileSync.apply(fs, arguments);\n            return undefined;\n        };\n        //fs.appendFile(filename, data[, options], callback)\n        var appendFile = fs.appendFile;\n        // TODO: This should  create file in mounted drive if path resolves to inside the mounting point.\n        this.appendFile = fs.appendFile = function (file, data, opts, callback) {\n            if (typeof opts == 'function') {\n                callback = opts;\n            }\n            var f = self.getFile(file);\n            if (f) {\n                process.nextTick(function () {\n                    f.setData(f.getData() + data.toString());\n                    if (callback)\n                        callback();\n                });\n            }\n            else\n                appendFile.apply(fs, arguments);\n        };\n        //fs.unlink(path, callback)\n        //fs.unlinkSync(path)\n        //fs.ftruncate(fd, len, callback)\n        //fs.ftruncateSync(fd, len)\n        //fs.truncate(path, len, callback)\n        //fs.truncateSync(path, len)\n        //fs.chown(path, uid, gid, callback)\n        //fs.chownSync(path, uid, gid)\n        //fs.fchown(fd, uid, gid, callback)\n        //fs.fchownSync(fd, uid, gid)\n        //fs.lchown(path, uid, gid, callback)\n        //fs.lchownSync(path, uid, gid)\n        //fs.chmod(path, mode, callback)\n        //fs.chmodSync(path, mode)\n        //fs.fchmod(fd, mode, callback)\n        //fs.fchmodSync(fd, mode)\n        //fs.lchmod(path, mode, callback)\n        //fs.lchmodSync(path, mode)\n        //fs.stat(path, callback)\n        //fs.lstat(path, callback)\n        //fs.link(srcpath, dstpath, callback)\n        //fs.linkSync(srcpath, dstpath)\n        //fs.symlink(srcpath, dstpath[, type], callback)\n        //fs.symlinkSync(srcpath, dstpath[, type])\n        //fs.readlink(path, callback)\n        //fs.readlinkSync(path)\n        //fs.rmdir(path, callback)\n        //fs.rmdirSync(path)\n        //fs.mkdir(path[, mode], callback)\n        //fs.mkdirSync(path[, mode])\n        //fs.close(fd, callback)\n        //fs.closeSync(fd)\n        //fs.open(path, flags[, mode], callback)\n        //fs.openSync(path, flags[, mode])\n        //fs.utimes(path, atime, mtime, callback)\n        //fs.utimesSync(path, atime, mtime)\n        //fs.futimes(fd, atime, mtime, callback)\n        //fs.futimesSync(fd, atime, mtime)\n        //fs.fsync(fd, callback)\n        //fs.fsyncSync(fd)\n        //fs.write(fd, buffer, offset, length[, position], callback)\n        //fs.write(fd, data[, position[, encoding]], callback)\n        //fs.writeSync(fd, buffer, offset, length[, position])\n        //fs.writeSync(fd, data[, position[, encoding]])\n        //fs.read(fd, buffer, offset, length, position, callback)\n        //fs.readSync(fd, buffer, offset, length, position)\n        //fs.watchFile(filename[, options], listener)\n        //fs.unwatchFile(filename[, listener])\n        //fs.watch(filename[, options][, listener])\n        //fs.access(path[, mode], callback)\n        //fs.accessSync(path[, mode])\n        //fs.createReadStream(path[, options])\n        //fs.createWriteStream(path[, options])\n    };\n    Drive.prototype.addLayer = function (layer) {\n        this.layers.push(layer);\n        layer.drive = this;\n    };\n    Drive.prototype.getFilePath = function (p) {\n        var filepath = path.resolve(p);\n        var node = this.getNode(filepath);\n        return node ? node : null;\n    };\n    Drive.prototype.getNode = function (p) {\n        var filepath = path.resolve(p);\n        for (var i = 0; i < this.layers.length; i++) {\n            var n = this.layers[i].getNode(filepath);\n            if (n)\n                return n;\n        }\n        return null;\n    };\n    Drive.prototype.getFile = function (p) {\n        var node = this.getNode(p);\n        return node instanceof LFile ? node : null;\n    };\n    Drive.prototype.getDirectory = function (p) {\n        var node = this.getNode(p);\n        return node instanceof LFile ? node : null;\n    };\n    Drive.prototype.getByFd = function (fd) {\n        for (var i = 0; i < this.layers.length; i++) {\n            var n = this.layers[i].getByFd(fd);\n            if (n)\n                return n;\n        }\n        return null;\n    };\n    // TODO: Mount from URL:\n    // TODO: `mount('/usr/lib', 'http://example.com/volumes/usr/lib.json', callback)`\n    // TODO: ...also cache that it has been loaded...\n    Drive.prototype.mount = function (mountpoint, archive, fs) {\n        if (archive === void 0) { archive = {}; }\n        var layer = new Layer(mountpoint);\n        layer.generateNodes(archive);\n        this.addLayer(layer);\n        if (!this.attached) {\n            this.attach(fs || (fs === null) ? fs : require('fs'));\n            this.attached = true;\n        }\n    };\n    return Drive;\n})();\nvar nodefs = function nodefs() {\n};\nnodefs.LNode = LNode;\nnodefs.LFile = LFile;\nnodefs.LDirectory = LDirectory;\nnodefs.Layer = Layer;\nnodefs.Drive = Drive;\nnodefs.volume = new Drive;\nnodefs.mount = function (mountpoint, archive, fs) {\n    if (archive === void 0) { archive = {}; }\n    if (fs === void 0) { fs = null; }\n    var drive = new Drive;\n    drive.mount(mountpoint, archive, fs);\n    return drive;\n};\nmodule.exports = nodefs;\n",
  "os.js": "\nfunction r(val) {\n    return function() { return val; };\n}\n\nrequire('util').extend(exports, {\n    endianness: r('LE'),\n    hostname: function () {\n        if (typeof location !== 'undefined') {\n            return location.hostname\n        }\n        else return '';\n    },\n    loadavg: r([]),\n    uptime: r(0),\n    freemem: r(Number.MAX_VALUE),\n    totalmem: r(Number.MAX_VALUE),\n    cpus: r([{model: '', speed: 1, times: {user: 0, nice: 0, sys: 0, idle: 0, irq: 0}}]), // We must have at least on CPU.\n    type: r('Browser'),\n    release: function () {\n        if (typeof navigator !== 'undefined') {\n            return navigator.appVersion;\n        }\n        return '';\n    },\n    networkInterfaces: exports.getNetworkInterfaces = r({}),\n    arch: r('javascript'),\n    platform: r('browser'),\n    tmpdir: r('/tmp'),\n    EOL: '\\n'\n});\n",
  "path.js": "'use strict';\n\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n    var res = [];\n    for (var i = 0; i < parts.length; i++) {\n        var p = parts[i];\n\n        // ignore empty parts\n        if (!p || p === '.')\n            continue;\n\n        if (p === '..') {\n            if (res.length && res[res.length - 1] !== '..') {\n                res.pop();\n            } else if (allowAboveRoot) {\n                res.push('..');\n            }\n        } else {\n            res.push(p);\n        }\n    }\n\n    return res;\n}\n\n// returns an array with empty elements removed from either end of the input\n// array or the original array if no elements need to be removed\nfunction trimArray(arr) {\n    var lastIndex = arr.length - 1;\n    var start = 0;\n    for (; start <= lastIndex; start++) {\n        if (arr[start])\n            break;\n    }\n\n    var end = lastIndex;\n    for (; end >= 0; end--) {\n        if (arr[end])\n            break;\n    }\n\n    if (start === 0 && end === lastIndex)\n        return arr;\n    if (start > end)\n        return [];\n    return arr.slice(start, end + 1);\n}\n\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\n\nfunction posixSplitPath(filename) {\n    return splitPathRe.exec(filename).slice(1);\n}\n\n\nexports.resolve = function() {\n    var resolvedPath = '',\n        resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n        var path = (i >= 0) ? arguments[i] : process.cwd();\n\n        // Skip empty and invalid entries\n        if (typeof path != 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n        } else if (!path) {\n            continue;\n        }\n\n        resolvedPath = path + '/' + resolvedPath;\n        resolvedAbsolute = path[0] === '/';\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeArray(resolvedPath.split('/'),\n        !resolvedAbsolute).join('/');\n\n    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n\nexports.normalize = function(path) {\n    var isAbsolute = exports.isAbsolute(path),\n        trailingSlash = path && path[path.length - 1] === '/';\n\n    // Normalize the path\n    path = normalizeArray(path.split('/'), !isAbsolute).join('/');\n\n    if (!path && !isAbsolute) {\n        path = '.';\n    }\n    if (path && trailingSlash) {\n        path += '/';\n    }\n\n    return (isAbsolute ? '/' : '') + path;\n};\n\n\nexports.isAbsolute = function(path) {\n    return path.charAt(0) === '/';\n};\n\n\nexports.join = function() {\n    var path = '';\n    for (var i = 0; i < arguments.length; i++) {\n        var segment = arguments[i];\n        if (typeof segment != 'string') {\n            throw new TypeError('Arguments to path.join must be strings');\n        }\n        if (segment) {\n            if (!path) {\n                path += segment;\n            } else {\n                path += '/' + segment;\n            }\n        }\n    }\n    return exports.normalize(path);\n};\n\n\nexports.relative = function(from, to) {\n    from = exports.resolve(from).substr(1);\n    to = exports.resolve(to).substr(1);\n\n    var fromParts = trimArray(from.split('/'));\n    var toParts = trimArray(to.split('/'));\n\n    var length = Math.min(fromParts.length, toParts.length);\n    var samePartsLength = length;\n    for (var i = 0; i < length; i++) {\n        if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n        }\n    }\n\n    var outputParts = [];\n    for (var i = samePartsLength; i < fromParts.length; i++) {\n        outputParts.push('..');\n    }\n\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n    return outputParts.join('/');\n};\n\n\nexports._makeLong = function(path) {\n    return path;\n};\n\n\nexports.dirname = function(path) {\n    var result = posixSplitPath(path),\n        root = result[0],\n        dir = result[1];\n\n    if (!root && !dir) {\n        // No dirname whatsoever\n        return '.';\n    }\n\n    if (dir) {\n        // It has a dirname, strip trailing slash\n        dir = dir.substr(0, dir.length - 1);\n    }\n\n    return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n    var f = posixSplitPath(path)[2];\n    // TODO: make this comparison case-insensitive on windows?\n    if (ext && f.substr(-1 * ext.length) === ext) {\n        f = f.substr(0, f.length - ext.length);\n    }\n    return f;\n};\n\n\nexports.extname = function(path) {\n    return posixSplitPath(path)[3];\n};\n\n\nexports.format = function(pathObject) {\n    if (typeof pathObject != 'object') {\n        throw new TypeError(\n            \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\n        );\n    }\n\n    var root = pathObject.root || '';\n\n    if (typeof root != 'string') {\n        throw new TypeError(\n            \"'pathObject.root' must be a string or undefined, not \" +\n            typeof pathObject.root\n        );\n    }\n\n    var dir = pathObject.dir ? pathObject.dir + exports.sep : '';\n    var base = pathObject.base || '';\n    return dir + base;\n};\n\n\nexports.parse = function(pathString) {\n    if (typeof pathString != 'string') {\n        throw new TypeError(\n            \"Parameter 'pathString' must be a string, not \" + typeof pathString\n        );\n    }\n    var allParts = posixSplitPath(pathString);\n    if (!allParts || allParts.length !== 4) {\n        throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n    }\n    allParts[1] = allParts[1] || '';\n    allParts[2] = allParts[2] || '';\n    allParts[3] = allParts[3] || '';\n\n    return {\n        root: allParts[0],\n        dir: allParts[0] + allParts[1].slice(0, -1),\n        base: allParts[2],\n        ext: allParts[3],\n        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n    };\n};\n\n\nexports.sep = '/';\nexports.delimiter = ':';\n",
  "portable.js": "//\"use strict\";\n\n\n(function(process) {\n    process.global = this.global = this;\n\n    function startup(require) {\n\n        require('polyfill');\n        require('process');\n\n        // Mount the /lib drive and any user drives to `fs`.\n        var nodefs = require('nodefs');\n        for(var mp in process.drives) nodefs.volume.mount(mp, process.drives[mp]);\n\n        //startup.globals();\n\n        var Module = require('module');\n        process.require = Module._load;\n\n        Module.runMain();\n    }\n\n    // TODO: Do we need this?\n    //startup.globals = function() {\n        //global.process = process;\n        //global.global = global;\n        //global.GLOBAL = global;\n        //global.root = global;\n        // Normally we don't need buffer on the web... TODO: Shim it? Make users require it explicitly if they need it?\n        //global.Buffer = core_require('buffer').Buffer;\n    //};\n\n    var runInThisContext = eval;\n    var libVolume = '/lib';\n\n    // `NM` for `NativeModule`.\n    function NM(id) {\n        this.filename = id + '.js';\n        this.id = id;\n        this.exports = {};\n        this.loaded = false;\n    }\n\n    NM._cache = {};\n\n    NM.require = function(id) {\n        if(id == 'nm') return NM;\n\n        var cached = NM.getCached(id);\n        if(cached) return cached.exports;\n\n        if(!NM.exists(id)) throw Error('Not found: \"' + id + '\"');\n        //if(!NM.exists(id)) throw new Error('No such native module ' + id);\n\n        var nm = new NM(id);\n        nm.cache();\n        nm.compile();\n        return nm.exports;\n    };\n\n    NM.getCached = function(id) {\n        return NM._cache[id];\n    };\n\n    NM.getSource = function(id) {\n        return process.drives[libVolume][id + '.js'];\n    };\n\n    NM.wrap = function(script) {\n        return NM.wrapper[0] + script + NM.wrapper[1];\n    };\n\n    NM.exists = function(id) {\n        return !!NM.getSource(id);\n    };\n\n    NM.wrapper = [\n        '(function (exports, require, module, __filename, __dirname, process) { ',\n        '\\n});'\n    ];\n\n    NM.prototype.compile = function() {\n        var source = NM.getSource(this.id);\n        source = NM.wrap(source);\n        var fn = runInThisContext(source);\n        fn(this.exports, NM.require, this, this.filename, libVolume, process);\n        this.loaded = true;\n    };\n\n    NM.prototype.cache = function() {\n        NM._cache[this.id] = this;\n    };\n\n    startup(NM.require);\n\n});\n\n",
  "process.js": "var util = require('util');\nvar EventEmitter = require('events');\n\n\n// Make process to be an `EventEmitter`.\nvar EEp = EventEmitter.prototype;\nfor(var prop in EEp)\n    if(typeof EEp[prop] == 'function') process[prop] = EEp[prop].bind(process);\nEventEmitter.init.call(process);\n\n\n// If explicitly requested by user, `process` is exposed to some global variable.\nif(process.expose) {\n    process.global['process'] = process;\n}\n\n\nutil.extend(process, {\n    pwd: process.env.PWD || '/',\n    cwd: function() {\n        return process.pwd;\n    },\n    chdir: function(dir) {\n        process.pwd = dir;\n    },\n\n    nextTick:   function(callback) { setTimeout(callback, 0); },\n    assert:     function(x, msg) { if(!x) throw Error(msg || 'assertion error'); },\n\n    // This is used in `fs`. Do we need it?\n    getuid:     function() { return 0; },\n    getgid:     function() { return 0; }\n\n    //umask: function() { return 0; }\n});\n\n// io.js also has `process.js`.\nmodule.exports = process;\n",
  "punycode.js": "/*! http://mths.be/punycode v1.2.3 by @mathias */\n;(function(root) {\n\n    /** Detect free variables */\n    var freeExports = typeof exports == 'object' && exports;\n    var freeModule = typeof module == 'object' && module &&\n        module.exports == freeExports && module;\n    var freeGlobal = typeof global == 'object' && global;\n    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n        root = freeGlobal;\n    }\n\n    /**\n     * The `punycode` object.\n     * @name punycode\n     * @type Object\n     */\n    var punycode,\n\n        /** Highest positive signed 32-bit float value */\n        maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n        /** Bootstring parameters */\n        base = 36,\n        tMin = 1,\n        tMax = 26,\n        skew = 38,\n        damp = 700,\n        initialBias = 72,\n        initialN = 128, // 0x80\n        delimiter = '-', // '\\x2D'\n\n        /** Regular expressions */\n        regexPunycode = /^xn--/,\n        regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars\n        regexSeparators = /\\x2E|\\u3002|\\uFF0E|\\uFF61/g, // RFC 3490 separators\n\n        /** Error messages */\n        errors = {\n            'overflow': 'Overflow: input needs wider integers to process',\n            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n            'invalid-input': 'Invalid input'\n        },\n\n        /** Convenience shortcuts */\n        baseMinusTMin = base - tMin,\n        floor = Math.floor,\n        stringFromCharCode = String.fromCharCode,\n\n        /** Temporary variable */\n        key;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * A generic error utility function.\n     * @private\n     * @param {String} type The error type.\n     * @returns {Error} Throws a `RangeError` with the applicable error message.\n     */\n    function error(type) {\n        throw RangeError(errors[type]);\n    }\n\n    /**\n     * A generic `Array#map` utility function.\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} callback The function that gets called for every array\n     * item.\n     * @returns {Array} A new array of values returned by the callback function.\n     */\n    function map(array, fn) {\n        var length = array.length;\n        while (length--) {\n            array[length] = fn(array[length]);\n        }\n        return array;\n    }\n\n    /**\n     * A simple `Array#map`-like wrapper to work with domain name strings.\n     * @private\n     * @param {String} domain The domain name.\n     * @param {Function} callback The function that gets called for every\n     * character.\n     * @returns {Array} A new string of characters returned by the callback\n     * function.\n     */\n    function mapDomain(string, fn) {\n        return map(string.split(regexSeparators), fn).join('.');\n    }\n\n    /**\n     * Creates an array containing the numeric code points of each Unicode\n     * character in the string. While JavaScript uses UCS-2 internally,\n     * this function will convert a pair of surrogate halves (each of which\n     * UCS-2 exposes as separate characters) into a single code point,\n     * matching UTF-16.\n     * @see `punycode.ucs2.encode`\n     * @see <http://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode.ucs2\n     * @name decode\n     * @param {String} string The Unicode input string (UCS-2).\n     * @returns {Array} The new array of code points.\n     */\n    function ucs2decode(string) {\n        var output = [],\n            counter = 0,\n            length = string.length,\n            value,\n            extra;\n        while (counter < length) {\n            value = string.charCodeAt(counter++);\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // high surrogate, and there is a next character\n                extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) { // low surrogate\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                    // unmatched surrogate; only append this code unit, in case the next\n                    // code unit is the high surrogate of a surrogate pair\n                    output.push(value);\n                    counter--;\n                }\n            } else {\n                output.push(value);\n            }\n        }\n        return output;\n    }\n\n    /**\n     * Creates a string based on an array of numeric code points.\n     * @see `punycode.ucs2.decode`\n     * @memberOf punycode.ucs2\n     * @name encode\n     * @param {Array} codePoints The array of numeric code points.\n     * @returns {String} The new Unicode string (UCS-2).\n     */\n    function ucs2encode(array) {\n        return map(array, function(value) {\n            var output = '';\n            if (value > 0xFFFF) {\n                value -= 0x10000;\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                value = 0xDC00 | value & 0x3FF;\n            }\n            output += stringFromCharCode(value);\n            return output;\n        }).join('');\n    }\n\n    /**\n     * Converts a basic code point into a digit/integer.\n     * @see `digitToBasic()`\n     * @private\n     * @param {Number} codePoint The basic numeric code point value.\n     * @returns {Number} The numeric value of a basic code point (for use in\n     * representing integers) in the range `0` to `base - 1`, or `base` if\n     * the code point does not represent a value.\n     */\n    function basicToDigit(codePoint) {\n        if (codePoint - 48 < 10) {\n            return codePoint - 22;\n        }\n        if (codePoint - 65 < 26) {\n            return codePoint - 65;\n        }\n        if (codePoint - 97 < 26) {\n            return codePoint - 97;\n        }\n        return base;\n    }\n\n    /**\n     * Converts a digit/integer into a basic code point.\n     * @see `basicToDigit()`\n     * @private\n     * @param {Number} digit The numeric value of a basic code point.\n     * @returns {Number} The basic code point whose value (when used for\n     * representing integers) is `digit`, which needs to be in the range\n     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n     * used; else, the lowercase form is used. The behavior is undefined\n     * if `flag` is non-zero and `digit` has no uppercase form.\n     */\n    function digitToBasic(digit, flag) {\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    }\n\n    /**\n     * Bias adaptation function as per section 3.4 of RFC 3492.\n     * http://tools.ietf.org/html/rfc3492#section-3.4\n     * @private\n     */\n    function adapt(delta, numPoints, firstTime) {\n        var k = 0;\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\n        delta += floor(delta / numPoints);\n        for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n            delta = floor(delta / baseMinusTMin);\n        }\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    }\n\n    /**\n     * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n     * symbols.\n     * @memberOf punycode\n     * @param {String} input The Punycode string of ASCII-only symbols.\n     * @returns {String} The resulting string of Unicode symbols.\n     */\n    function decode(input) {\n        // Don't use UCS-2\n        var output = [],\n            inputLength = input.length,\n            out,\n            i = 0,\n            n = initialN,\n            bias = initialBias,\n            basic,\n            j,\n            index,\n            oldi,\n            w,\n            k,\n            digit,\n            t,\n            /** Cached calculation results */\n            baseMinusT;\n\n        // Handle the basic code points: let `basic` be the number of input code\n        // points before the last delimiter, or `0` if there is none, then copy\n        // the first basic code points to the output.\n\n        basic = input.lastIndexOf(delimiter);\n        if (basic < 0) {\n            basic = 0;\n        }\n\n        for (j = 0; j < basic; ++j) {\n            // if it's not a basic code point\n            if (input.charCodeAt(j) >= 0x80) {\n                error('not-basic');\n            }\n            output.push(input.charCodeAt(j));\n        }\n\n        // Main decoding loop: start just after the last delimiter if any basic code\n        // points were copied; start at the beginning otherwise.\n\n        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n            // `index` is the index of the next character to be consumed.\n            // Decode a generalized variable-length integer into `delta`,\n            // which gets added to `i`. The overflow checking is easier\n            // if we increase `i` as we go, then subtract off its starting\n            // value at the end to obtain `delta`.\n            for (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n                if (index >= inputLength) {\n                    error('invalid-input');\n                }\n\n                digit = basicToDigit(input.charCodeAt(index++));\n\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error('overflow');\n                }\n\n                i += digit * w;\n                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n                if (digit < t) {\n                    break;\n                }\n\n                baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                    error('overflow');\n                }\n\n                w *= baseMinusT;\n\n            }\n\n            out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi == 0);\n\n            // `i` was supposed to wrap around from `out` to `0`,\n            // incrementing `n` each time, so we'll fix that now:\n            if (floor(i / out) > maxInt - n) {\n                error('overflow');\n            }\n\n            n += floor(i / out);\n            i %= out;\n\n            // Insert `n` at position `i` of the output\n            output.splice(i++, 0, n);\n\n        }\n\n        return ucs2encode(output);\n    }\n\n    /**\n     * Converts a string of Unicode symbols to a Punycode string of ASCII-only\n     * symbols.\n     * @memberOf punycode\n     * @param {String} input The string of Unicode symbols.\n     * @returns {String} The resulting Punycode string of ASCII-only symbols.\n     */\n    function encode(input) {\n        var n,\n            delta,\n            handledCPCount,\n            basicLength,\n            bias,\n            j,\n            m,\n            q,\n            k,\n            t,\n            currentValue,\n            output = [],\n            /** `inputLength` will hold the number of code points in `input`. */\n            inputLength,\n            /** Cached calculation results */\n            handledCPCountPlusOne,\n            baseMinusT,\n            qMinusT;\n\n        // Convert the input in UCS-2 to Unicode\n        input = ucs2decode(input);\n\n        // Cache the length\n        inputLength = input.length;\n\n        // Initialize the state\n        n = initialN;\n        delta = 0;\n        bias = initialBias;\n\n        // Handle the basic code points\n        for (j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n            if (currentValue < 0x80) {\n                output.push(stringFromCharCode(currentValue));\n            }\n        }\n\n        handledCPCount = basicLength = output.length;\n\n        // `handledCPCount` is the number of code points that have been handled;\n        // `basicLength` is the number of basic code points.\n\n        // Finish the basic string - if it is not empty - with a delimiter\n        if (basicLength) {\n            output.push(delimiter);\n        }\n\n        // Main encoding loop:\n        while (handledCPCount < inputLength) {\n\n            // All non-basic code points < n have been handled already. Find the next\n            // larger one:\n            for (m = maxInt, j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n                if (currentValue >= n && currentValue < m) {\n                    m = currentValue;\n                }\n            }\n\n            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n            // but guard against overflow\n            handledCPCountPlusOne = handledCPCount + 1;\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error('overflow');\n            }\n\n            delta += (m - n) * handledCPCountPlusOne;\n            n = m;\n\n            for (j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n\n                if (currentValue < n && ++delta > maxInt) {\n                    error('overflow');\n                }\n\n                if (currentValue == n) {\n                    // Represent delta as a generalized variable-length integer\n                    for (q = delta, k = base; /* no condition */; k += base) {\n                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n                        if (q < t) {\n                            break;\n                        }\n                        qMinusT = q - t;\n                        baseMinusT = base - t;\n                        output.push(\n                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n                        );\n                        q = floor(qMinusT / baseMinusT);\n                    }\n\n                    output.push(stringFromCharCode(digitToBasic(q, 0)));\n                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                    delta = 0;\n                    ++handledCPCount;\n                }\n            }\n\n            ++delta;\n            ++n;\n\n        }\n        return output.join('');\n    }\n\n    /**\n     * Converts a Punycode string representing a domain name to Unicode. Only the\n     * Punycoded parts of the domain name will be converted, i.e. it doesn't\n     * matter if you call it on a string that has already been converted to\n     * Unicode.\n     * @memberOf punycode\n     * @param {String} domain The Punycode domain name to convert to Unicode.\n     * @returns {String} The Unicode representation of the given Punycode\n     * string.\n     */\n    function toUnicode(domain) {\n        return mapDomain(domain, function(string) {\n            return regexPunycode.test(string)\n                ? decode(string.slice(4).toLowerCase())\n                : string;\n        });\n    }\n\n    /**\n     * Converts a Unicode string representing a domain name to Punycode. Only the\n     * non-ASCII parts of the domain name will be converted, i.e. it doesn't\n     * matter if you call it with a domain that's already in ASCII.\n     * @memberOf punycode\n     * @param {String} domain The domain name to convert, as a Unicode string.\n     * @returns {String} The Punycode representation of the given domain name.\n     */\n    function toASCII(domain) {\n        return mapDomain(domain, function(string) {\n            return regexNonASCII.test(string)\n                ? 'xn--' + encode(string)\n                : string;\n        });\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /** Define the public API */\n    punycode = {\n        /**\n         * A string representing the current Punycode.js version number.\n         * @memberOf punycode\n         * @type String\n         */\n        'version': '1.2.3',\n        /**\n         * An object of methods to convert from JavaScript's internal character\n         * representation (UCS-2) to Unicode code points, and back.\n         * @see <http://mathiasbynens.be/notes/javascript-encoding>\n         * @memberOf punycode\n         * @type Object\n         */\n        'ucs2': {\n            'decode': ucs2decode,\n            'encode': ucs2encode\n        },\n        'decode': decode,\n        'encode': encode,\n        'toASCII': toASCII,\n        'toUnicode': toUnicode\n    };\n\n    /** Expose `punycode` */\n    // Some AMD build optimizers, like r.js, check for specific condition patterns\n    // like the following:\n    if (\n        typeof define == 'function' &&\n        typeof define.amd == 'object' &&\n        define.amd\n    ) {\n        define(function() {\n            return punycode;\n        });\n    }\telse if (freeExports && !freeExports.nodeType) {\n        if (freeModule) { // in Node.js or RingoJS v0.8.0+\n            freeModule.exports = punycode;\n        } else { // in Narwhal or RingoJS v0.7.0-\n            for (key in punycode) {\n                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n            }\n        }\n    } else { // in Rhino or a web browser\n        root.punycode = punycode;\n    }\n\n}(this));\n",
  "shim-base64.js": ";(function () {\n\n    var object = typeof exports != 'undefined' ? exports : this; // #8: web workers\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n    function InvalidCharacterError(message) {\n        this.message = message;\n    }\n    InvalidCharacterError.prototype = new Error;\n    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n    // encoder\n    // [https://gist.github.com/999166] by [https://github.com/nignag]\n    object.btoa || (\n        object.btoa = function (input) {\n            for (\n                // initialize result and counter\n                var block, charCode, idx = 0, map = chars, output = '';\n                // if the next input index does not exist:\n                //   change the mapping table to \"=\"\n                //   check if d has no fractional digits\n                input.charAt(idx | 0) || (map = '=', idx % 1);\n                // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n                output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n            ) {\n                charCode = input.charCodeAt(idx += 3/4);\n                if (charCode > 0xFF) {\n                    throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n                }\n                block = block << 8 | charCode;\n            }\n            return output;\n        });\n\n    // decoder\n    // [https://gist.github.com/1020396] by [https://github.com/atk]\n    object.atob || (\n        object.atob = function (input) {\n            input = input.replace(/=+$/, '');\n            if (input.length % 4 == 1) {\n                throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n            }\n            for (\n                // initialize result and counters\n                var bc = 0, bs, buffer, idx = 0, output = '';\n                // get next character\n                buffer = input.charAt(idx++);\n                // character found in table? initialize bit storage and add its ascii value;\n                ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                    // and if not first of each 4 characters,\n                    // convert the first 8 bits to one ascii character\n                bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n            ) {\n                // try to find character in table (0-63, not found => -1)\n                buffer = chars.indexOf(buffer);\n            }\n            return output;\n        });\n\n}());\n",
  "shim-object-keys.js": "// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\nif (!Object.keys) {\n    Object.keys = (function() {\n        'use strict';\n        var hasOwnProperty = Object.prototype.hasOwnProperty,\n            hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n            dontEnums = [\n                'toString',\n                'toLocaleString',\n                'valueOf',\n                'hasOwnProperty',\n                'isPrototypeOf',\n                'propertyIsEnumerable',\n                'constructor'\n            ],\n            dontEnumsLength = dontEnums.length;\n\n        return function(obj) {\n            if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n                throw new TypeError('Object.keys called on non-object');\n            }\n\n            var result = [], prop, i;\n\n            for (prop in obj) {\n                if (hasOwnProperty.call(obj, prop)) {\n                    result.push(prop);\n                }\n            }\n\n            if (hasDontEnumBug) {\n                for (i = 0; i < dontEnumsLength; i++) {\n                    if (hasOwnProperty.call(obj, dontEnums[i])) {\n                        result.push(dontEnums[i]);\n                    }\n                }\n            }\n            return result;\n        };\n    }());\n}\n",
  "stream.js": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events');\nvar util = require('util');\n\nutil.inherits(Stream, EE);\nStream.Readable = require('_stream_readable');\nStream.Writable = require('_stream_writable');\nStream.Duplex = require('_stream_duplex');\nStream.Transform = require('_stream_transform');\nStream.PassThrough = require('_stream_passthrough');\n\n// Backwards-compat with node 0.4.x\n//Stream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n    EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n    var source = this;\n\n    function ondata(chunk) {\n        if (dest.writable) {\n            if (false === dest.write(chunk) && source.pause) {\n                source.pause();\n            }\n        }\n    }\n\n    source.on('data', ondata);\n\n    function ondrain() {\n        if (source.readable && source.resume) {\n            source.resume();\n        }\n    }\n\n    dest.on('drain', ondrain);\n\n    // If the 'end' option is not supplied, dest.end() will be called when\n    // source gets the 'end' or 'close' events.  Only dest.end() once.\n    if (!dest._isStdio && (!options || options.end !== false)) {\n        source.on('end', onend);\n        source.on('close', onclose);\n    }\n\n    var didOnEnd = false;\n    function onend() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n\n        dest.end();\n    }\n\n\n    function onclose() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n\n        if (typeof dest.destroy === 'function') dest.destroy();\n    }\n\n    // don't leave dangling pipes when there are errors.\n    function onerror(er) {\n        cleanup();\n        if (EE.listenerCount(this, 'error') === 0) {\n            throw er; // Unhandled stream error in pipe.\n        }\n    }\n\n    source.on('error', onerror);\n    dest.on('error', onerror);\n\n    // remove all the event listeners that were added.\n    function cleanup() {\n        source.removeListener('data', ondata);\n        dest.removeListener('drain', ondrain);\n\n        source.removeListener('end', onend);\n        source.removeListener('close', onclose);\n\n        source.removeListener('error', onerror);\n        dest.removeListener('error', onerror);\n\n        source.removeListener('end', cleanup);\n        source.removeListener('close', cleanup);\n\n        dest.removeListener('close', cleanup);\n    }\n\n    source.on('end', cleanup);\n    source.on('close', cleanup);\n\n    dest.on('close', cleanup);\n\n    dest.emit('pipe', source);\n\n    // Allow for unix-like usage: A.pipe(B).pipe(C)\n    return dest;\n};\n",
  "url.js": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n    this.protocol = null;\n    this.slashes = null;\n    this.auth = null;\n    this.host = null;\n    this.port = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.query = null;\n    this.pathname = null;\n    this.path = null;\n    this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n// Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n// RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n// RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n// Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n// protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n        'javascript': true,\n        'javascript:': true\n    },\n// protocols that never have a hostname.\n    hostlessProtocol = {\n        'javascript': true,\n        'javascript:': true\n    },\n// protocols that always contain a // bit.\n    slashedProtocol = {\n        'http': true,\n        'https': true,\n        'ftp': true,\n        'gopher': true,\n        'file': true,\n        'http:': true,\n        'https:': true,\n        'ftp:': true,\n        'gopher:': true,\n        'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n    if (url && util.isObject(url) && url instanceof Url) return url;\n\n    var u = new Url;\n    u.parse(url, parseQueryString, slashesDenoteHost);\n    return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n    if (!util.isString(url)) {\n        throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n    }\n\n    // Copy chrome, IE, opera backslash-handling behavior.\n    // Back slashes before the query string get converted to forward slashes\n    // See: https://code.google.com/p/chromium/issues/detail?id=25916\n    var queryIndex = url.indexOf('?'),\n        splitter =\n            (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n        uSplit = url.split(splitter),\n        slashRegex = /\\\\/g;\n    uSplit[0] = uSplit[0].replace(slashRegex, '/');\n    url = uSplit.join(splitter);\n\n    var rest = url;\n\n    // trim before proceeding.\n    // This is to support parse stuff like \"  http://foo.com  \\n\"\n    rest = rest.trim();\n\n    if (!slashesDenoteHost && url.split('#').length === 1) {\n        // Try fast path regexp\n        var simplePath = simplePathPattern.exec(rest);\n        if (simplePath) {\n            this.path = rest;\n            this.href = rest;\n            this.pathname = simplePath[1];\n            if (simplePath[2]) {\n                this.search = simplePath[2];\n                if (parseQueryString) {\n                    this.query = querystring.parse(this.search.substr(1));\n                } else {\n                    this.query = this.search.substr(1);\n                }\n            } else if (parseQueryString) {\n                this.search = '';\n                this.query = {};\n            }\n            return this;\n        }\n    }\n\n    var proto = protocolPattern.exec(rest);\n    if (proto) {\n        proto = proto[0];\n        var lowerProto = proto.toLowerCase();\n        this.protocol = lowerProto;\n        rest = rest.substr(proto.length);\n    }\n\n    // figure out if it's got a host\n    // user@server is *always* interpreted as a hostname, and url\n    // resolution will treat //foo/bar as host=foo,path=bar because that's\n    // how the browser resolves relative URLs.\n    if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n        var slashes = rest.substr(0, 2) === '//';\n        if (slashes && !(proto && hostlessProtocol[proto])) {\n            rest = rest.substr(2);\n            this.slashes = true;\n        }\n    }\n\n    if (!hostlessProtocol[proto] &&\n        (slashes || (proto && !slashedProtocol[proto]))) {\n\n        // there's a hostname.\n        // the first instance of /, ?, ;, or # ends the host.\n        //\n        // If there is an @ in the hostname, then non-host chars *are* allowed\n        // to the left of the last @ sign, unless some host-ending character\n        // comes *before* the @-sign.\n        // URLs are obnoxious.\n        //\n        // ex:\n        // http://a@b@c/ => user:a@b host:c\n        // http://a@b?@c => user:a host:c path:/?@c\n\n        // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n        // Review our test case against browsers more comprehensively.\n\n        // find the first instance of any hostEndingChars\n        var hostEnd = -1;\n        for (var i = 0; i < hostEndingChars.length; i++) {\n            var hec = rest.indexOf(hostEndingChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n                hostEnd = hec;\n        }\n\n        // at this point, either we have an explicit point where the\n        // auth portion cannot go past, or the last @ char is the decider.\n        var auth, atSign;\n        if (hostEnd === -1) {\n            // atSign can be anywhere.\n            atSign = rest.lastIndexOf('@');\n        } else {\n            // atSign must be in auth portion.\n            // http://a@b/c@d => host:b auth:a path:/c@d\n            atSign = rest.lastIndexOf('@', hostEnd);\n        }\n\n        // Now we have a portion which is definitely the auth.\n        // Pull that off.\n        if (atSign !== -1) {\n            auth = rest.slice(0, atSign);\n            rest = rest.slice(atSign + 1);\n            this.auth = decodeURIComponent(auth);\n        }\n\n        // the host is the remaining to the left of the first non-host char\n        hostEnd = -1;\n        for (var i = 0; i < nonHostChars.length; i++) {\n            var hec = rest.indexOf(nonHostChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n                hostEnd = hec;\n        }\n        // if we still have not hit it, then the entire thing is a host.\n        if (hostEnd === -1)\n            hostEnd = rest.length;\n\n        this.host = rest.slice(0, hostEnd);\n        rest = rest.slice(hostEnd);\n\n        // pull out port.\n        this.parseHost();\n\n        // we've indicated that there is a hostname,\n        // so even if it's empty, it has to be present.\n        this.hostname = this.hostname || '';\n\n        // if hostname begins with [ and ends with ]\n        // assume that it's an IPv6 address.\n        var ipv6Hostname = this.hostname[0] === '[' &&\n            this.hostname[this.hostname.length - 1] === ']';\n\n        // validate a little.\n        if (!ipv6Hostname) {\n            var hostparts = this.hostname.split(/\\./);\n            for (var i = 0, l = hostparts.length; i < l; i++) {\n                var part = hostparts[i];\n                if (!part) continue;\n                if (!part.match(hostnamePartPattern)) {\n                    var newpart = '';\n                    for (var j = 0, k = part.length; j < k; j++) {\n                        if (part.charCodeAt(j) > 127) {\n                            // we replace non-ASCII char with a temporary placeholder\n                            // we need this to make sure size of hostname is not\n                            // broken by replacing non-ASCII by nothing\n                            newpart += 'x';\n                        } else {\n                            newpart += part[j];\n                        }\n                    }\n                    // we test again with ASCII char only\n                    if (!newpart.match(hostnamePartPattern)) {\n                        var validParts = hostparts.slice(0, i);\n                        var notHost = hostparts.slice(i + 1);\n                        var bit = part.match(hostnamePartStart);\n                        if (bit) {\n                            validParts.push(bit[1]);\n                            notHost.unshift(bit[2]);\n                        }\n                        if (notHost.length) {\n                            rest = '/' + notHost.join('.') + rest;\n                        }\n                        this.hostname = validParts.join('.');\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (this.hostname.length > hostnameMaxLen) {\n            this.hostname = '';\n        } else {\n            // hostnames are always lower case.\n            this.hostname = this.hostname.toLowerCase();\n        }\n\n        if (!ipv6Hostname) {\n            // IDNA Support: Returns a punycoded representation of \"domain\".\n            // It only converts parts of the domain name that\n            // have non-ASCII characters, i.e. it doesn't matter if\n            // you call it with a domain that already is ASCII-only.\n            this.hostname = punycode.toASCII(this.hostname);\n        }\n\n        var p = this.port ? ':' + this.port : '';\n        var h = this.hostname || '';\n        this.host = h + p;\n        this.href += this.host;\n\n        // strip [ and ] from the hostname\n        // the host field still retains them, though\n        if (ipv6Hostname) {\n            this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n            if (rest[0] !== '/') {\n                rest = '/' + rest;\n            }\n        }\n    }\n\n    // now rest is set to the post-host stuff.\n    // chop off any delim chars.\n    if (!unsafeProtocol[lowerProto]) {\n\n        // First, make 100% sure that any \"autoEscape\" chars get\n        // escaped, even if encodeURIComponent doesn't think they\n        // need to be.\n        for (var i = 0, l = autoEscape.length; i < l; i++) {\n            var ae = autoEscape[i];\n            if (rest.indexOf(ae) === -1)\n                continue;\n            var esc = encodeURIComponent(ae);\n            if (esc === ae) {\n                esc = escape(ae);\n            }\n            rest = rest.split(ae).join(esc);\n        }\n    }\n\n\n    // chop off from the tail first.\n    var hash = rest.indexOf('#');\n    if (hash !== -1) {\n        // got a fragment string.\n        this.hash = rest.substr(hash);\n        rest = rest.slice(0, hash);\n    }\n    var qm = rest.indexOf('?');\n    if (qm !== -1) {\n        this.search = rest.substr(qm);\n        this.query = rest.substr(qm + 1);\n        if (parseQueryString) {\n            this.query = querystring.parse(this.query);\n        }\n        rest = rest.slice(0, qm);\n    } else if (parseQueryString) {\n        // no query string, but parseQueryString still requested\n        this.search = '';\n        this.query = {};\n    }\n    if (rest) this.pathname = rest;\n    if (slashedProtocol[lowerProto] &&\n        this.hostname && !this.pathname) {\n        this.pathname = '/';\n    }\n\n    //to support http.request\n    if (this.pathname || this.search) {\n        var p = this.pathname || '';\n        var s = this.search || '';\n        this.path = p + s;\n    }\n\n    // finally, reconstruct the href based on what has been validated.\n    this.href = this.format();\n    return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n    // ensure it's an object, and not a string url.\n    // If it's an obj, this is a no-op.\n    // this way, you can call url_format() on strings\n    // to clean up potentially wonky urls.\n    if (util.isString(obj)) obj = urlParse(obj);\n    if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n    return obj.format();\n}\n\nUrl.prototype.format = function() {\n    var auth = this.auth || '';\n    if (auth) {\n        auth = encodeURIComponent(auth);\n        auth = auth.replace(/%3A/i, ':');\n        auth += '@';\n    }\n\n    var protocol = this.protocol || '',\n        pathname = this.pathname || '',\n        hash = this.hash || '',\n        host = false,\n        query = '';\n\n    if (this.host) {\n        host = auth + this.host;\n    } else if (this.hostname) {\n        host = auth + (this.hostname.indexOf(':') === -1 ?\n                this.hostname :\n            '[' + this.hostname + ']');\n        if (this.port) {\n            host += ':' + this.port;\n        }\n    }\n\n    if (this.query &&\n        util.isObject(this.query) &&\n        Object.keys(this.query).length) {\n        query = querystring.stringify(this.query);\n    }\n\n    var search = this.search || (query && ('?' + query)) || '';\n\n    if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n    // unless they had them to begin with.\n    if (this.slashes ||\n        (!protocol || slashedProtocol[protocol]) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n\n    if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n    if (search && search.charAt(0) !== '?') search = '?' + search;\n\n    pathname = pathname.replace(/[?#]/g, function(match) {\n        return encodeURIComponent(match);\n    });\n    search = search.replace('#', '%23');\n\n    return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n    return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n    return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n    if (!source) return relative;\n    return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n    if (util.isString(relative)) {\n        var rel = new Url();\n        rel.parse(relative, false, true);\n        relative = rel;\n    }\n\n    var result = new Url();\n    var tkeys = Object.keys(this);\n    for (var tk = 0; tk < tkeys.length; tk++) {\n        var tkey = tkeys[tk];\n        result[tkey] = this[tkey];\n    }\n\n    // hash is always overridden, no matter what.\n    // even href=\"\" will remove it.\n    result.hash = relative.hash;\n\n    // if the relative url is empty, then there's nothing left to do here.\n    if (relative.href === '') {\n        result.href = result.format();\n        return result;\n    }\n\n    // hrefs like //foo/bar always cut to the protocol.\n    if (relative.slashes && !relative.protocol) {\n        // take everything except the protocol from relative\n        var rkeys = Object.keys(relative);\n        for (var rk = 0; rk < rkeys.length; rk++) {\n            var rkey = rkeys[rk];\n            if (rkey !== 'protocol')\n                result[rkey] = relative[rkey];\n        }\n\n        //urlParse appends trailing / to urls like http://www.example.com\n        if (slashedProtocol[result.protocol] &&\n            result.hostname && !result.pathname) {\n            result.path = result.pathname = '/';\n        }\n\n        result.href = result.format();\n        return result;\n    }\n\n    if (relative.protocol && relative.protocol !== result.protocol) {\n        // if it's a known url protocol, then changing\n        // the protocol does weird things\n        // first, if it's not file:, then we MUST have a host,\n        // and if there was a path\n        // to begin with, then we MUST have a path.\n        // if it is file:, then the host is dropped,\n        // because that's known to be hostless.\n        // anything else is assumed to be absolute.\n        if (!slashedProtocol[relative.protocol]) {\n            var keys = Object.keys(relative);\n            for (var v = 0; v < keys.length; v++) {\n                var k = keys[v];\n                result[k] = relative[k];\n            }\n            result.href = result.format();\n            return result;\n        }\n\n        result.protocol = relative.protocol;\n        if (!relative.host && !hostlessProtocol[relative.protocol]) {\n            var relPath = (relative.pathname || '').split('/');\n            while (relPath.length && !(relative.host = relPath.shift()));\n            if (!relative.host) relative.host = '';\n            if (!relative.hostname) relative.hostname = '';\n            if (relPath[0] !== '') relPath.unshift('');\n            if (relPath.length < 2) relPath.unshift('');\n            result.pathname = relPath.join('/');\n        } else {\n            result.pathname = relative.pathname;\n        }\n        result.search = relative.search;\n        result.query = relative.query;\n        result.host = relative.host || '';\n        result.auth = relative.auth;\n        result.hostname = relative.hostname || relative.host;\n        result.port = relative.port;\n        // to support http.request\n        if (result.pathname || result.search) {\n            var p = result.pathname || '';\n            var s = result.search || '';\n            result.path = p + s;\n        }\n        result.slashes = result.slashes || relative.slashes;\n        result.href = result.format();\n        return result;\n    }\n\n    var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n        isRelAbs = (\n        relative.host ||\n        relative.pathname && relative.pathname.charAt(0) === '/'\n        ),\n        mustEndAbs = (isRelAbs || isSourceAbs ||\n        (result.host && relative.pathname)),\n        removeAllDots = mustEndAbs,\n        srcPath = result.pathname && result.pathname.split('/') || [],\n        relPath = relative.pathname && relative.pathname.split('/') || [],\n        psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n    // if the url is a non-slashed url, then relative\n    // links like ../.. should be able\n    // to crawl up to the hostname, as well.  This is strange.\n    // result.protocol has already been set by now.\n    // Later on, put the first path part into the host field.\n    if (psychotic) {\n        result.hostname = '';\n        result.port = null;\n        if (result.host) {\n            if (srcPath[0] === '') srcPath[0] = result.host;\n            else srcPath.unshift(result.host);\n        }\n        result.host = '';\n        if (relative.protocol) {\n            relative.hostname = null;\n            relative.port = null;\n            if (relative.host) {\n                if (relPath[0] === '') relPath[0] = relative.host;\n                else relPath.unshift(relative.host);\n            }\n            relative.host = null;\n        }\n        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n    }\n\n    if (isRelAbs) {\n        // it's absolute.\n        result.host = (relative.host || relative.host === '') ?\n            relative.host : result.host;\n        result.hostname = (relative.hostname || relative.hostname === '') ?\n            relative.hostname : result.hostname;\n        result.search = relative.search;\n        result.query = relative.query;\n        srcPath = relPath;\n        // fall through to the dot-handling below.\n    } else if (relPath.length) {\n        // it's relative\n        // throw away the existing file, and take the new path instead.\n        if (!srcPath) srcPath = [];\n        srcPath.pop();\n        srcPath = srcPath.concat(relPath);\n        result.search = relative.search;\n        result.query = relative.query;\n    } else if (!util.isNullOrUndefined(relative.search)) {\n        // just pull out the search.\n        // like href='?foo'.\n        // Put this after the other two cases because it simplifies the booleans\n        if (psychotic) {\n            result.hostname = result.host = srcPath.shift();\n            //occationaly the auth can get stuck only in host\n            //this especialy happens in cases like\n            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n            var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                result.host.split('@') : false;\n            if (authInHost) {\n                result.auth = authInHost.shift();\n                result.host = result.hostname = authInHost.shift();\n            }\n        }\n        result.search = relative.search;\n        result.query = relative.query;\n        //to support http.request\n        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n            result.path = (result.pathname ? result.pathname : '') +\n                (result.search ? result.search : '');\n        }\n        result.href = result.format();\n        return result;\n    }\n\n    if (!srcPath.length) {\n        // no path at all.  easy.\n        // we've already handled the other stuff above.\n        result.pathname = null;\n        //to support http.request\n        if (result.search) {\n            result.path = '/' + result.search;\n        } else {\n            result.path = null;\n        }\n        result.href = result.format();\n        return result;\n    }\n\n    // if a url ENDs in . or .., then it must get a trailing slash.\n    // however, if it ends in anything else non-slashy,\n    // then it must NOT get a trailing slash.\n    var last = srcPath.slice(-1)[0];\n    var hasTrailingSlash = (\n    (result.host || relative.host || srcPath.length > 1) &&\n    (last === '.' || last === '..') || last === '');\n\n    // strip single dots, resolve double dots to parent dir\n    // if the path tries to go above the root, `up` ends up > 0\n    var up = 0;\n    for (var i = srcPath.length; i >= 0; i--) {\n        last = srcPath[i];\n        if (last === '.') {\n            srcPath.splice(i, 1);\n        } else if (last === '..') {\n            srcPath.splice(i, 1);\n            up++;\n        } else if (up) {\n            srcPath.splice(i, 1);\n            up--;\n        }\n    }\n\n    // if the path is allowed to go above the root, restore leading ..s\n    if (!mustEndAbs && !removeAllDots) {\n        for (; up--; up) {\n            srcPath.unshift('..');\n        }\n    }\n\n    if (mustEndAbs && srcPath[0] !== '' &&\n        (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n        srcPath.unshift('');\n    }\n\n    if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n        srcPath.push('');\n    }\n\n    var isAbsolute = srcPath[0] === '' ||\n        (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n    // put the host back\n    if (psychotic) {\n        result.hostname = result.host = isAbsolute ? '' :\n            srcPath.length ? srcPath.shift() : '';\n        //occationaly the auth can get stuck only in host\n        //this especialy happens in cases like\n        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n        var authInHost = result.host && result.host.indexOf('@') > 0 ?\n            result.host.split('@') : false;\n        if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n        }\n    }\n\n    mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n    if (mustEndAbs && !isAbsolute) {\n        srcPath.unshift('');\n    }\n\n    if (!srcPath.length) {\n        result.pathname = null;\n        result.path = null;\n    } else {\n        result.pathname = srcPath.join('/');\n    }\n\n    //to support request.http\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n        result.path = (result.pathname ? result.pathname : '') +\n            (result.search ? result.search : '');\n    }\n    result.auth = relative.auth || result.auth;\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n};\n\nUrl.prototype.parseHost = function() {\n    var host = this.host;\n    var port = portPattern.exec(host);\n    if (port) {\n        port = port[0];\n        if (port !== ':') {\n            this.port = port.substr(1);\n        }\n        host = host.substr(0, host.length - port.length);\n    }\n    if (host) this.hostname = host;\n};\n",
  "util.js": "'use strict';\n\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n    if (!isString(f)) {\n        var objects = [];\n        for (var i = 0; i < arguments.length; i++) {\n            objects.push(inspect(arguments[i]));\n        }\n        return objects.join(' ');\n    }\n\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    var str = String(f).replace(formatRegExp, function(x) {\n        if (x === '%%') return '%';\n        if (i >= len) return x;\n        switch (x) {\n            case '%s': return String(args[i++]);\n            case '%d': return Number(args[i++]);\n            case '%j':\n                try {\n                    return JSON.stringify(args[i++]);\n                } catch (_) {\n                    return '[Circular]';\n                }\n            default:\n                return x;\n        }\n    });\n    for (var x = args[i]; i < len; x = args[++i]) {\n        if (isNull(x) || !isObject(x)) {\n            str += ' ' + x;\n        } else {\n            str += ' ' + inspect(x);\n        }\n    }\n    return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n    // Allow for deprecating things in the process of starting up.\n    if (isUndefined(global.process)) {\n        return function() {\n            return exports.deprecate(fn, msg).apply(this, arguments);\n        };\n    }\n\n    if (process.noDeprecation === true) {\n        return fn;\n    }\n\n    var warned = false;\n    function deprecated() {\n        if (!warned) {\n            if (process.throwDeprecation) {\n                throw new Error(msg);\n            } else if (process.traceDeprecation) {\n                console.trace(msg);\n            } else {\n                console.error(msg);\n            }\n            warned = true;\n        }\n        return fn.apply(this, arguments);\n    }\n\n    return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n    if (isUndefined(debugEnviron))\n        debugEnviron = process.env.NODE_DEBUG || '';\n    set = set.toUpperCase();\n    if (!debugs[set]) {\n        if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n            var pid = process.pid;\n            debugs[set] = function() {\n                var msg = exports.format.apply(exports, arguments);\n                console.error('%s %d: %s', set, pid, msg);\n            };\n        } else {\n            debugs[set] = function() {};\n        }\n    }\n    return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n    // default options\n    var ctx = {\n        seen: [],\n        stylize: stylizeNoColor\n    };\n    // legacy...\n    if (arguments.length >= 3) ctx.depth = arguments[2];\n    if (arguments.length >= 4) ctx.colors = arguments[3];\n    if (isBoolean(opts)) {\n        // legacy...\n        ctx.showHidden = opts;\n    } else if (opts) {\n        // got an \"options\" object\n        exports._extend(ctx, opts);\n    }\n    // set default options\n    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n    if (isUndefined(ctx.depth)) ctx.depth = 2;\n    if (isUndefined(ctx.colors)) ctx.colors = false;\n    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n    'bold' : [1, 22],\n    'italic' : [3, 23],\n    'underline' : [4, 24],\n    'inverse' : [7, 27],\n    'white' : [37, 39],\n    'grey' : [90, 39],\n    'black' : [30, 39],\n    'blue' : [34, 39],\n    'cyan' : [36, 39],\n    'green' : [32, 39],\n    'magenta' : [35, 39],\n    'red' : [31, 39],\n    'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n    'special': 'cyan',\n    'number': 'yellow',\n    'boolean': 'yellow',\n    'undefined': 'grey',\n    'null': 'bold',\n    'string': 'green',\n    'symbol': 'green',\n    'date': 'magenta',\n    // \"name\": intentionally not styling\n    'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n    var style = inspect.styles[styleType];\n\n    if (style) {\n        return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n            '\\u001b[' + inspect.colors[style][1] + 'm';\n    } else {\n        return str;\n    }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n    return str;\n}\n\n\nfunction arrayToHash(array) {\n    var hash = {};\n\n    array.forEach(function(val, idx) {\n        hash[val] = true;\n    });\n\n    return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (ctx.customInspect &&\n        value &&\n        isFunction(value.inspect) &&\n            // Filter out the util module, it's inspect function is special\n        value.inspect !== exports.inspect &&\n            // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes, ctx);\n        if (!isString(ret)) {\n            ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n    }\n\n    // Primitive types cannot have properties\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n        return primitive;\n    }\n\n    // Look up the keys of the object.\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n\n    if (ctx.showHidden) {\n        keys = Object.getOwnPropertyNames(value);\n    }\n\n    // This could be a boxed primitive (new String(), etc.), check valueOf()\n    // NOTE: Avoid calling `valueOf` on `Date` instance because it will return\n    // a number which, when object has some additional user-stored `keys`,\n    // will be printed out.\n    var formatted;\n    var raw = value;\n    try {\n        // the .valueOf() call can fail for a multitude of reasons\n        if (!isDate(value))\n            raw = value.valueOf();\n    } catch (e) {\n        // ignore...\n    }\n\n    if (isString(raw)) {\n        // for boxed Strings, we have to remove the 0-n indexed entries,\n        // since they just noisey up the output and are redundant\n        keys = keys.filter(function(key) {\n            return !(key >= 0 && key < raw.length);\n        });\n    }\n\n    // Some type of object without properties can be shortcutted.\n    if (keys.length === 0) {\n        if (isFunction(value)) {\n            var name = value.name ? ': ' + value.name : '';\n            return ctx.stylize('[Function' + name + ']', 'special');\n        }\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        }\n        if (isDate(value)) {\n            return ctx.stylize(Date.prototype.toString.call(value), 'date');\n        }\n        if (isError(value)) {\n            return formatError(value);\n        }\n        // now check the `raw` value to handle boxed primitives\n        if (isString(raw)) {\n            formatted = formatPrimitiveNoColor(ctx, raw);\n            return ctx.stylize('[String: ' + formatted + ']', 'string');\n        }\n        if (isNumber(raw)) {\n            formatted = formatPrimitiveNoColor(ctx, raw);\n            return ctx.stylize('[Number: ' + formatted + ']', 'number');\n        }\n        if (isBoolean(raw)) {\n            formatted = formatPrimitiveNoColor(ctx, raw);\n            return ctx.stylize('[Boolean: ' + formatted + ']', 'boolean');\n        }\n    }\n\n    var base = '', array = false, braces = ['{', '}'];\n\n    // Make Array say that they are Array\n    if (isArray(value)) {\n        array = true;\n        braces = ['[', ']'];\n    }\n\n    // Make functions say that they are functions\n    if (isFunction(value)) {\n        var n = value.name ? ': ' + value.name : '';\n        base = ' [Function' + n + ']';\n    }\n\n    // Make RegExps say that they are RegExps\n    if (isRegExp(value)) {\n        base = ' ' + RegExp.prototype.toString.call(value);\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n        base = ' ' + Date.prototype.toUTCString.call(value);\n    }\n\n    // Make error with message first say the error\n    if (isError(value)) {\n        base = ' ' + formatError(value);\n    }\n\n    // Make boxed primitive Strings look like such\n    if (isString(raw)) {\n        formatted = formatPrimitiveNoColor(ctx, raw);\n        base = ' ' + '[String: ' + formatted + ']';\n    }\n\n    // Make boxed primitive Numbers look like such\n    if (isNumber(raw)) {\n        formatted = formatPrimitiveNoColor(ctx, raw);\n        base = ' ' + '[Number: ' + formatted + ']';\n    }\n\n    // Make boxed primitive Booleans look like such\n    if (isBoolean(raw)) {\n        formatted = formatPrimitiveNoColor(ctx, raw);\n        base = ' ' + '[Boolean: ' + formatted + ']';\n    }\n\n    if (keys.length === 0 && (!array || value.length === 0)) {\n        return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        } else {\n            return ctx.stylize('[Object]', 'special');\n        }\n    }\n\n    ctx.seen.push(value);\n\n    var output;\n    if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n        output = keys.map(function(key) {\n            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n    }\n\n    ctx.seen.pop();\n\n    return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n    if (isUndefined(value))\n        return ctx.stylize('undefined', 'undefined');\n    if (isString(value)) {\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                .replace(/'/g, \"\\\\'\")\n                .replace(/\\\\\"/g, '\"') + '\\'';\n        return ctx.stylize(simple, 'string');\n    }\n    if (isNumber(value)) {\n        // Format -0 as '-0'. Strict equality won't distinguish 0 from -0,\n        // so instead we use the fact that 1 / -0 < 0 whereas 1 / 0 > 0 .\n        if (value === 0 && 1 / value < 0)\n            return ctx.stylize('-0', 'number');\n        return ctx.stylize('' + value, 'number');\n    }\n    if (isBoolean(value))\n        return ctx.stylize('' + value, 'boolean');\n    // For some reason typeof null is \"object\", so special case here.\n    if (isNull(value))\n        return ctx.stylize('null', 'null');\n    // es6 symbol primitive\n    if (isSymbol(value))\n        return ctx.stylize(value.toString(), 'symbol');\n}\n\n\nfunction formatPrimitiveNoColor(ctx, value) {\n    var stylize = ctx.stylize;\n    ctx.stylize = stylizeNoColor;\n    var str = formatPrimitive(ctx, value);\n    ctx.stylize = stylize;\n    return str;\n}\n\n\nfunction formatError(value) {\n    return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n        if (hasOwnProperty(value, String(i))) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                String(i), true));\n        } else {\n            output.push('');\n        }\n    }\n    keys.forEach(function(key) {\n        if (!key.match(/^\\d+$/)) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                key, true));\n        }\n    });\n    return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n    if (desc.get) {\n        if (desc.set) {\n            str = ctx.stylize('[Getter/Setter]', 'special');\n        } else {\n            str = ctx.stylize('[Getter]', 'special');\n        }\n    } else {\n        if (desc.set) {\n            str = ctx.stylize('[Setter]', 'special');\n        }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n        name = '[' + key + ']';\n    }\n    if (!str) {\n        if (ctx.seen.indexOf(desc.value) < 0) {\n            if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n            } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n            }\n            if (str.indexOf('\\n') > -1) {\n                if (array) {\n                    str = str.split('\\n').map(function(line) {\n                        return '  ' + line;\n                    }).join('\\n').substr(2);\n                } else {\n                    str = '\\n' + str.split('\\n').map(function(line) {\n                            return '   ' + line;\n                        }).join('\\n');\n                }\n            }\n        } else {\n            str = ctx.stylize('[Circular]', 'special');\n        }\n    }\n    if (isUndefined(name)) {\n        if (array && key.match(/^\\d+$/)) {\n            return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            name = name.substr(1, name.length - 2);\n            name = ctx.stylize(name, 'name');\n        } else {\n            name = name.replace(/'/g, \"\\\\'\")\n                .replace(/\\\\\"/g, '\"')\n                .replace(/(^\"|\"$)/g, \"'\")\n                .replace(/\\\\\\\\/g, '\\\\');\n            name = ctx.stylize(name, 'string');\n        }\n    }\n\n    return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n    var length = output.reduce(function(prev, cur) {\n        return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n    }, 0);\n\n    if (length > 60) {\n        return braces[0] +\n            (base === '' ? '' : base + '\\n ') +\n            ' ' +\n            output.join(',\\n  ') +\n            ' ' +\n            braces[1];\n    }\n\n    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nvar isArray = exports.isArray = Array.isArray;\n\nfunction isBoolean(arg) {\n    return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n    return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n    return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n    return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n    return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n    return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n    return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n    return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n    return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n    return isObject(e) &&\n        (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n    return arg === null ||\n        typeof arg === 'boolean' ||\n        typeof arg === 'number' ||\n        typeof arg === 'string' ||\n        typeof arg === 'symbol' ||  // ES6 symbol\n        typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n    return arg && typeof arg === 'object'\n        && typeof arg.copy === 'function'\n        && typeof arg.fill === 'function'\n        && typeof arg.readUInt8 === 'function';\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n    return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n    return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n    'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n    var d = new Date();\n    var time = [pad(d.getHours()),\n        pad(d.getMinutes()),\n        pad(d.getSeconds())].join(':');\n    return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n};\n\n\nexports._extend = function(origin, add) {\n    // Don't do anything if add isn't an object\n    if (!add || !isObject(add)) return origin;\n\n    var keys = Object.keys(add);\n    var i = keys.length;\n    while (i--) {\n        origin[keys[i]] = add[keys[i]];\n    }\n    return origin;\n};\n\nexports.extend = function extend(origin, add) {\n    if (!origin || (typeof origin != 'object')) origin = {};\n    if (!add || (typeof add != 'object')) add = {};\n\n    for(var prop in add) origin[prop] = add[prop];\n    if(arguments.length > 2) {\n        var args = [].slice.call(arguments, 1);\n        args[0] = origin;\n        return extend.apply(this, args);\n    } else return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n",
  "vm.js": "// Taken from https://github.com/substack/vm-browserify\n\nvar indexOf = (function() {\n    var indexOf = [].indexOf;\n\n    return function (arr, obj) {\n        if (indexOf) return arr.indexOf(obj);\n        for (var i = 0; i < arr.length; ++i) {\n            if (arr[i] === obj) return i;\n        }\n        return -1;\n    };\n})();\n\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n    'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n    'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n    'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n    'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    //if (!(context instanceof Context)) {\n    //    throw new TypeError(\"needs a 'context' argument.\");\n    //}\n    if (typeof context != 'object') {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n\n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n\n    document.body.appendChild(iframe);\n\n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n\n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n\n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n\n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n\n    document.body.removeChild(iframe);\n\n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    forEach(Object_keys(ctx), function (key) {\n        context[key] = ctx[key];\n    });\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\n//exports.createContext = Script.createContext = function (context) {\nexports.createContext = function (context) {\n    return context;\n    //var copy = new Context();\n    //if(typeof context === 'object') {\n    //    forEach(Object_keys(context), function (key) {\n    //        copy[key] = context[key];\n    //    });\n    //}\n    //return copy;\n};\n\nexports.runInThisContext = function(code) {\n    var script = new Script(code);\n    script.runInThisContext();\n};\n",
  "zlib.js": "// https://github.com/brianloveswords/zlib-browserify/blob/master/zlib.js\n/** @license zlib.js 0.1.7 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */\n(function(){\"use strict\";function r(r){throw r}function t(t,e){this.index=\"number\"==typeof e?e:0,this.m=0,this.buffer=t instanceof(j?Uint8Array:Array)?t:new(j?Uint8Array:Array)(32768),2*this.buffer.length<=this.index&&r(Error(\"invalid index\")),this.buffer.length<=this.index&&this.f()}function e(r,t,e){var i,n=\"number\"==typeof t?t:t=0,s=\"number\"==typeof e?e:r.length;for(i=-1,n=7&s;n--;++t)i=i>>>8^M[255&(i^r[t])];for(n=s>>3;n--;t+=8)i=i>>>8^M[255&(i^r[t])],i=i>>>8^M[255&(i^r[t+1])],i=i>>>8^M[255&(i^r[t+2])],i=i>>>8^M[255&(i^r[t+3])],i=i>>>8^M[255&(i^r[t+4])],i=i>>>8^M[255&(i^r[t+5])],i=i>>>8^M[255&(i^r[t+6])],i=i>>>8^M[255&(i^r[t+7])];return(4294967295^i)>>>0}function i(){}function n(r){this.buffer=new(j?Uint16Array:Array)(2*r),this.length=0}function s(r){var t,e,i,n,s,a,h,f,o,u=r.length,c=0,l=Number.POSITIVE_INFINITY;for(f=0;u>f;++f)r[f]>c&&(c=r[f]),r[f]<l&&(l=r[f]);for(t=1<<c,e=new(j?Uint32Array:Array)(t),i=1,n=0,s=2;c>=i;){for(f=0;u>f;++f)if(r[f]===i){for(a=0,h=n,o=0;i>o;++o)a=a<<1|1&h,h>>=1;for(o=a;t>o;o+=s)e[o]=i<<16|f;++n}++i,n<<=1,s<<=1}return[e,c,l]}function a(r,t){this.k=J,this.F=0,this.input=j&&r instanceof Array?new Uint8Array(r):r,this.b=0,t&&(t.lazy&&(this.F=t.lazy),\"number\"==typeof t.compressionType&&(this.k=t.compressionType),t.outputBuffer&&(this.a=j&&t.outputBuffer instanceof Array?new Uint8Array(t.outputBuffer):t.outputBuffer),\"number\"==typeof t.outputIndex&&(this.b=t.outputIndex)),this.a||(this.a=new(j?Uint8Array:Array)(32768))}function h(r,t){this.length=r,this.N=t}function f(t,e){function i(t,e){var i,n=t.N,s=[],a=0;i=Y[t.length],s[a++]=65535&i,s[a++]=i>>16&255,s[a++]=i>>24;var h;switch(I){case 1===n:h=[0,n-1,0];break;case 2===n:h=[1,n-2,0];break;case 3===n:h=[2,n-3,0];break;case 4===n:h=[3,n-4,0];break;case 6>=n:h=[4,n-5,1];break;case 8>=n:h=[5,n-7,1];break;case 12>=n:h=[6,n-9,2];break;case 16>=n:h=[7,n-13,2];break;case 24>=n:h=[8,n-17,3];break;case 32>=n:h=[9,n-25,3];break;case 48>=n:h=[10,n-33,4];break;case 64>=n:h=[11,n-49,4];break;case 96>=n:h=[12,n-65,5];break;case 128>=n:h=[13,n-97,5];break;case 192>=n:h=[14,n-129,6];break;case 256>=n:h=[15,n-193,6];break;case 384>=n:h=[16,n-257,7];break;case 512>=n:h=[17,n-385,7];break;case 768>=n:h=[18,n-513,8];break;case 1024>=n:h=[19,n-769,8];break;case 1536>=n:h=[20,n-1025,9];break;case 2048>=n:h=[21,n-1537,9];break;case 3072>=n:h=[22,n-2049,10];break;case 4096>=n:h=[23,n-3073,10];break;case 6144>=n:h=[24,n-4097,11];break;case 8192>=n:h=[25,n-6145,11];break;case 12288>=n:h=[26,n-8193,12];break;case 16384>=n:h=[27,n-12289,12];break;case 24576>=n:h=[28,n-16385,13];break;case 32768>=n:h=[29,n-24577,13];break;default:r(\"invalid distance\")}i=h,s[a++]=i[0],s[a++]=i[1],s[a++]=i[2];var f,o;for(f=0,o=s.length;o>f;++f)p[g++]=s[f];A[s[0]]++,v[s[3]]++,d=t.length+e-1,l=null}var n,s,a,h,f,u,c,l,y,b={},p=j?new Uint16Array(2*e.length):[],g=0,d=0,A=new(j?Uint32Array:Array)(286),v=new(j?Uint32Array:Array)(30),w=t.F;if(!j){for(a=0;285>=a;)A[a++]=0;for(a=0;29>=a;)v[a++]=0}for(A[256]=1,n=0,s=e.length;s>n;++n){for(a=f=0,h=3;h>a&&n+a!==s;++a)f=f<<8|e[n+a];if(b[f]===C&&(b[f]=[]),u=b[f],!(0<d--)){for(;0<u.length&&32768<n-u[0];)u.shift();if(n+3>=s){for(l&&i(l,-1),a=0,h=s-n;h>a;++a)y=e[n+a],p[g++]=y,++A[y];break}0<u.length?(c=o(e,n,u),l?l.length<c.length?(y=e[n-1],p[g++]=y,++A[y],i(c,0)):i(l,-1):c.length<w?l=c:i(c,0)):l?i(l,-1):(y=e[n],p[g++]=y,++A[y])}u.push(n)}return p[g++]=256,A[256]++,t.U=A,t.T=v,j?p.subarray(0,g):p}function o(r,t,e){var i,n,s,a,f,o,u=0,c=r.length;a=0,o=e.length;r:for(;o>a;a++){if(i=e[o-a-1],s=3,u>3){for(f=u;f>3;f--)if(r[i+f-1]!==r[t+f-1])continue r;s=u}for(;258>s&&c>t+s&&r[i+s]===r[t+s];)++s;if(s>u&&(n=i,u=s),258===s)break}return new h(u,t-n)}function u(r,t){var e,i,s,a,h,f=r.length,o=new n(572),u=new(j?Uint8Array:Array)(f);if(!j)for(a=0;f>a;a++)u[a]=0;for(a=0;f>a;++a)0<r[a]&&o.push(a,r[a]);if(e=Array(o.length/2),i=new(j?Uint32Array:Array)(o.length/2),1===e.length)return u[o.pop().index]=1,u;for(a=0,h=o.length/2;h>a;++a)e[a]=o.pop(),i[a]=e[a].value;for(s=c(i,i.length,t),a=0,h=e.length;h>a;++a)u[e[a].index]=s[a];return u}function c(r,t,e){function i(r){var e=y[r][b[r]];e===t?(i(r+1),i(r+1)):--c[e],++b[r]}var n,s,a,h,f,o=new(j?Uint16Array:Array)(e),u=new(j?Uint8Array:Array)(e),c=new(j?Uint8Array:Array)(t),l=Array(e),y=Array(e),b=Array(e),p=(1<<e)-t,g=1<<e-1;for(o[e-1]=t,s=0;e>s;++s)g>p?u[s]=0:(u[s]=1,p-=g),p<<=1,o[e-2-s]=(o[e-1-s]/2|0)+t;for(o[0]=u[0],l[0]=Array(o[0]),y[0]=Array(o[0]),s=1;e>s;++s)o[s]>2*o[s-1]+u[s]&&(o[s]=2*o[s-1]+u[s]),l[s]=Array(o[s]),y[s]=Array(o[s]);for(n=0;t>n;++n)c[n]=e;for(a=0;a<o[e-1];++a)l[e-1][a]=r[a],y[e-1][a]=a;for(n=0;e>n;++n)b[n]=0;for(1===u[e-1]&&(--c[0],++b[e-1]),s=e-2;s>=0;--s){for(h=n=0,f=b[s+1],a=0;a<o[s];a++)h=l[s+1][f]+l[s+1][f+1],h>r[n]?(l[s][a]=h,y[s][a]=t,f+=2):(l[s][a]=r[n],y[s][a]=n,++n);b[s]=0,1===u[s]&&i(s)}return c}function l(r){var t,e,i,n,s=new(j?Uint16Array:Array)(r.length),a=[],h=[],f=0;for(t=0,e=r.length;e>t;t++)a[r[t]]=(0|a[r[t]])+1;for(t=1,e=16;e>=t;t++)h[t]=f,f+=0|a[t],f<<=1;for(t=0,e=r.length;e>t;t++)for(f=h[r[t]],h[r[t]]+=1,i=s[t]=0,n=r[t];n>i;i++)s[t]=s[t]<<1|1&f,f>>>=1;return s}function y(r,t){this.input=r,this.b=this.c=0,this.g={},t&&(t.flags&&(this.g=t.flags),\"string\"==typeof t.filename&&(this.filename=t.filename),\"string\"==typeof t.comment&&(this.w=t.comment),t.deflateOptions&&(this.l=t.deflateOptions)),this.l||(this.l={})}function b(t,e){switch(this.o=[],this.p=32768,this.e=this.j=this.c=this.s=0,this.input=j?new Uint8Array(t):t,this.u=!1,this.q=_,this.K=!1,(e||!(e={}))&&(e.index&&(this.c=e.index),e.bufferSize&&(this.p=e.bufferSize),e.bufferType&&(this.q=e.bufferType),e.resize&&(this.K=e.resize)),this.q){case $:this.b=32768,this.a=new(j?Uint8Array:Array)(32768+this.p+258);break;case _:this.b=0,this.a=new(j?Uint8Array:Array)(this.p),this.f=this.S,this.z=this.O,this.r=this.Q;break;default:r(Error(\"invalid inflate mode\"))}}function p(t,e){for(var i,n=t.j,s=t.e,a=t.input,h=t.c;e>s;)i=a[h++],i===C&&r(Error(\"input buffer is broken\")),n|=i<<s,s+=8;return i=n&(1<<e)-1,t.j=n>>>e,t.e=s-e,t.c=h,i}function g(r,t){for(var e,i,n,s=r.j,a=r.e,h=r.input,f=r.c,o=t[0],u=t[1];u>a&&(e=h[f++],e!==C);)s|=e<<a,a+=8;return i=o[s&(1<<u)-1],n=i>>>16,r.j=s>>n,r.e=a-n,r.c=f,65535&i}function d(r){function t(r,t,e){var i,n,s,a;for(a=0;r>a;)switch(i=g(this,t)){case 16:for(s=3+p(this,2);s--;)e[a++]=n;break;case 17:for(s=3+p(this,3);s--;)e[a++]=0;n=0;break;case 18:for(s=11+p(this,7);s--;)e[a++]=0;n=0;break;default:n=e[a++]=i}return e}var e,i,n,a,h=p(r,5)+257,f=p(r,5)+1,o=p(r,4)+4,u=new(j?Uint8Array:Array)(it.length);for(a=0;o>a;++a)u[it[a]]=p(r,3);e=s(u),i=new(j?Uint8Array:Array)(h),n=new(j?Uint8Array:Array)(f),r.r(s(t.call(r,h,e,i)),s(t.call(r,f,e,n)))}function A(r){this.input=r,this.c=0,this.G=[],this.R=!1}function v(r){if(\"string\"==typeof r){var t,e,i=r.split(\"\");for(t=0,e=i.length;e>t;t++)i[t]=(255&i[t].charCodeAt(0))>>>0;r=i}for(var n,s=1,a=0,h=r.length,f=0;h>0;){n=h>1024?1024:h,h-=n;do s+=r[f++],a+=s;while(--n);s%=65521,a%=65521}return(a<<16|s)>>>0}function w(t,e){var i,n;switch(this.input=t,this.c=0,(e||!(e={}))&&(e.index&&(this.c=e.index),e.verify&&(this.V=e.verify)),i=t[this.c++],n=t[this.c++],15&i){case At:this.method=At;break;default:r(Error(\"unsupported compression method\"))}0!==((i<<8)+n)%31&&r(Error(\"invalid fcheck flag:\"+((i<<8)+n)%31)),32&n&&r(Error(\"fdict flag is not supported\")),this.J=new b(t,{index:this.c,bufferSize:e.bufferSize,bufferType:e.bufferType,resize:e.resize})}function k(r,t){this.input=r,this.a=new(j?Uint8Array:Array)(32768),this.k=vt.t;var e,i={};!t&&(t={})||\"number\"!=typeof t.compressionType||(this.k=t.compressionType);for(e in t)i[e]=t[e];i.outputBuffer=this.a,this.I=new a(this.input,i)}function U(r,t,e){process.nextTick(function(){var i,n;try{n=m(r,e)}catch(s){i=s}t(i,n)})}function m(r,t){var e;return e=new k(r).h(),t||(t={}),t.H?e:B(e)}function x(r,t,e){process.nextTick(function(){var i,n;try{n=E(r,e)}catch(s){i=s}t(i,n)})}function E(r,t){var e;return r.subarray=r.slice,e=new w(r).i(),t||(t={}),t.noBuffer?e:B(e)}function z(r,t,e){process.nextTick(function(){var i,n;try{n=T(r,e)}catch(s){i=s}t(i,n)})}function T(r,t){var e;return r.subarray=r.slice,e=new y(r).h(),t||(t={}),t.H?e:B(e)}function S(r,t,e){process.nextTick(function(){var i,n;try{n=N(r,e)}catch(s){i=s}t(i,n)})}function N(r,t){var e;return r.subarray=r.slice,e=new A(r).i(),t||(t={}),t.H?e:B(e)}function B(r){var t,e,i=new Buffer(r.length);for(t=0,e=r.length;e>t;++t)i[t]=r[t];return i}var C=void 0,I=!0,j=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array;t.prototype.f=function(){var r,t=this.buffer,e=t.length,i=new(j?Uint8Array:Array)(e<<1);if(j)i.set(t);else for(r=0;e>r;++r)i[r]=t[r];return this.buffer=i},t.prototype.d=function(r,t,e){var i,n=this.buffer,s=this.index,a=this.m,h=n[s];if(e&&t>1&&(r=t>8?(F[255&r]<<24|F[r>>>8&255]<<16|F[r>>>16&255]<<8|F[r>>>24&255])>>32-t:F[r]>>8-t),8>t+a)h=h<<t|r,a+=t;else for(i=0;t>i;++i)h=h<<1|r>>t-i-1&1,8===++a&&(a=0,n[s++]=F[h],h=0,s===n.length&&(n=this.f()));n[s]=h,this.buffer=n,this.m=a,this.index=s},t.prototype.finish=function(){var r,t=this.buffer,e=this.index;return 0<this.m&&(t[e]<<=8-this.m,t[e]=F[t[e]],e++),j?r=t.subarray(0,e):(t.length=e,r=t),r};var L,O=new(j?Uint8Array:Array)(256);for(L=0;256>L;++L){for(var D=L,P=D,q=7,D=D>>>1;D;D>>>=1)P<<=1,P|=1&D,--q;O[L]=(P<<q&255)>>>0}var F=O,G=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],M=j?new Uint32Array(G):G;n.prototype.getParent=function(r){return 2*((r-2)/4|0)},n.prototype.push=function(r,t){var e,i,n,s=this.buffer;for(e=this.length,s[this.length++]=t,s[this.length++]=r;e>0&&(i=this.getParent(e),s[e]>s[i]);)n=s[e],s[e]=s[i],s[i]=n,n=s[e+1],s[e+1]=s[i+1],s[i+1]=n,e=i;return this.length},n.prototype.pop=function(){var r,t,e,i,n,s=this.buffer;for(t=s[0],r=s[1],this.length-=2,s[0]=s[this.length],s[1]=s[this.length+1],n=0;(i=2*n+2,!(i>=this.length))&&(i+2<this.length&&s[i+2]>s[i]&&(i+=2),s[i]>s[n]);)e=s[n],s[n]=s[i],s[i]=e,e=s[n+1],s[n+1]=s[i+1],s[i+1]=e,n=i;return{index:r,value:t,length:this.length}};var H,J=2,K={NONE:0,L:1,t:J,X:3},R=[];for(H=0;288>H;H++)switch(I){case 143>=H:R.push([H+48,8]);break;case 255>=H:R.push([H-144+400,9]);break;case 279>=H:R.push([H-256+0,7]);break;case 287>=H:R.push([H-280+192,8]);break;default:r(\"invalid literal: \"+H)}a.prototype.h=function(){var e,i,n,s,a=this.input;switch(this.k){case 0:for(n=0,s=a.length;s>n;){i=j?a.subarray(n,n+65535):a.slice(n,n+65535),n+=i.length;var h=i,o=n===s,c=C,y=C,b=C,p=C,g=C,d=this.a,A=this.b;if(j){for(d=new Uint8Array(this.a.buffer);d.length<=A+h.length+5;)d=new Uint8Array(d.length<<1);d.set(this.a)}if(c=o?1:0,d[A++]=0|c,y=h.length,b=~y+65536&65535,d[A++]=255&y,d[A++]=y>>>8&255,d[A++]=255&b,d[A++]=b>>>8&255,j)d.set(h,A),A+=h.length,d=d.subarray(0,A);else{for(p=0,g=h.length;g>p;++p)d[A++]=h[p];d.length=A}this.b=A,this.a=d}break;case 1:var v=new t(j?new Uint8Array(this.a.buffer):this.a,this.b);v.d(1,1,I),v.d(1,2,I);var w,k,U,m=f(this,a);for(w=0,k=m.length;k>w;w++)if(U=m[w],t.prototype.d.apply(v,R[U]),U>256)v.d(m[++w],m[++w],I),v.d(m[++w],5),v.d(m[++w],m[++w],I);else if(256===U)break;this.a=v.finish(),this.b=this.a.length;break;case J:var x,E,z,T,S,N,B,L,O,D,P,q,F,G,M,H=new t(j?new Uint8Array(this.a.buffer):this.a,this.b),K=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],V=Array(19);for(x=J,H.d(1,1,I),H.d(x,2,I),E=f(this,a),N=u(this.U,15),B=l(N),L=u(this.T,7),O=l(L),z=286;z>257&&0===N[z-1];z--);for(T=30;T>1&&0===L[T-1];T--);var Y,Q,W,X,Z,$,_=z,rt=T,tt=new(j?Uint32Array:Array)(_+rt),et=new(j?Uint32Array:Array)(316),it=new(j?Uint8Array:Array)(19);for(Y=Q=0;_>Y;Y++)tt[Q++]=N[Y];for(Y=0;rt>Y;Y++)tt[Q++]=L[Y];if(!j)for(Y=0,X=it.length;X>Y;++Y)it[Y]=0;for(Y=Z=0,X=tt.length;X>Y;Y+=Q){for(Q=1;X>Y+Q&&tt[Y+Q]===tt[Y];++Q);if(W=Q,0===tt[Y])if(3>W)for(;0<W--;)et[Z++]=0,it[0]++;else for(;W>0;)$=138>W?W:138,$>W-3&&W>$&&($=W-3),10>=$?(et[Z++]=17,et[Z++]=$-3,it[17]++):(et[Z++]=18,et[Z++]=$-11,it[18]++),W-=$;else if(et[Z++]=tt[Y],it[tt[Y]]++,W--,3>W)for(;0<W--;)et[Z++]=tt[Y],it[tt[Y]]++;else for(;W>0;)$=6>W?W:6,$>W-3&&W>$&&($=W-3),et[Z++]=16,et[Z++]=$-3,it[16]++,W-=$}for(e=j?et.subarray(0,Z):et.slice(0,Z),D=u(it,7),G=0;19>G;G++)V[G]=D[K[G]];for(S=19;S>4&&0===V[S-1];S--);for(P=l(D),H.d(z-257,5,I),H.d(T-1,5,I),H.d(S-4,4,I),G=0;S>G;G++)H.d(V[G],3,I);for(G=0,M=e.length;M>G;G++)if(q=e[G],H.d(P[q],D[q],I),q>=16){switch(G++,q){case 16:F=2;break;case 17:F=3;break;case 18:F=7;break;default:r(\"invalid code: \"+q)}H.d(e[G],F,I)}var nt,st,at,ht,ft,ot,ut,ct,lt=[B,N],yt=[O,L];for(ft=lt[0],ot=lt[1],ut=yt[0],ct=yt[1],nt=0,st=E.length;st>nt;++nt)if(at=E[nt],H.d(ft[at],ot[at],I),at>256)H.d(E[++nt],E[++nt],I),ht=E[++nt],H.d(ut[ht],ct[ht],I),H.d(E[++nt],E[++nt],I);else if(256===at)break;this.a=H.finish(),this.b=this.a.length;break;default:r(\"invalid compression type\")}return this.a};var V=function(){function t(t){switch(I){case 3===t:return[257,t-3,0];case 4===t:return[258,t-4,0];case 5===t:return[259,t-5,0];case 6===t:return[260,t-6,0];case 7===t:return[261,t-7,0];case 8===t:return[262,t-8,0];case 9===t:return[263,t-9,0];case 10===t:return[264,t-10,0];case 12>=t:return[265,t-11,1];case 14>=t:return[266,t-13,1];case 16>=t:return[267,t-15,1];case 18>=t:return[268,t-17,1];case 22>=t:return[269,t-19,2];case 26>=t:return[270,t-23,2];case 30>=t:return[271,t-27,2];case 34>=t:return[272,t-31,2];case 42>=t:return[273,t-35,3];case 50>=t:return[274,t-43,3];case 58>=t:return[275,t-51,3];case 66>=t:return[276,t-59,3];case 82>=t:return[277,t-67,4];case 98>=t:return[278,t-83,4];case 114>=t:return[279,t-99,4];case 130>=t:return[280,t-115,4];case 162>=t:return[281,t-131,5];case 194>=t:return[282,t-163,5];case 226>=t:return[283,t-195,5];case 257>=t:return[284,t-227,5];case 258===t:return[285,t-258,0];default:r(\"invalid length: \"+t)}}var e,i,n=[];for(e=3;258>=e;e++)i=t(e),n[e]=i[2]<<24|i[1]<<16|i[0];return n}(),Y=j?new Uint32Array(V):V;y.prototype.h=function(){var r,t,i,n,s,h,f,o,u=new(j?Uint8Array:Array)(32768),c=0,l=this.input,y=this.c,b=this.filename,p=this.w;if(u[c++]=31,u[c++]=139,u[c++]=8,r=0,this.g.fname&&(r|=X),this.g.fcomment&&(r|=Z),this.g.fhcrc&&(r|=W),u[c++]=r,t=(Date.now?Date.now():+new Date)/1e3|0,u[c++]=255&t,u[c++]=t>>>8&255,u[c++]=t>>>16&255,u[c++]=t>>>24&255,u[c++]=0,u[c++]=Q,this.g.fname!==C){for(f=0,o=b.length;o>f;++f)h=b.charCodeAt(f),h>255&&(u[c++]=h>>>8&255),u[c++]=255&h;u[c++]=0}if(this.g.comment){for(f=0,o=p.length;o>f;++f)h=p.charCodeAt(f),h>255&&(u[c++]=h>>>8&255),u[c++]=255&h;u[c++]=0}return this.g.fhcrc&&(i=65535&e(u,0,c),u[c++]=255&i,u[c++]=i>>>8&255),this.l.outputBuffer=u,this.l.outputIndex=c,s=new a(l,this.l),u=s.h(),c=s.b,j&&(c+8>u.buffer.byteLength?(this.a=new Uint8Array(c+8),this.a.set(new Uint8Array(u.buffer)),u=this.a):u=new Uint8Array(u.buffer)),n=e(l,C,C),u[c++]=255&n,u[c++]=n>>>8&255,u[c++]=n>>>16&255,u[c++]=n>>>24&255,o=l.length,u[c++]=255&o,u[c++]=o>>>8&255,u[c++]=o>>>16&255,u[c++]=o>>>24&255,this.c=y,j&&c<u.length&&(this.a=u=u.subarray(0,c)),u};var Q=255,W=2,X=8,Z=16,$=0,_=1;b.prototype.i=function(){for(;!this.u;){var t=p(this,3);switch(1&t&&(this.u=I),t>>>=1){case 0:var e=this.input,i=this.c,n=this.a,s=this.b,a=C,h=C,f=C,o=n.length,u=C;switch(this.e=this.j=0,a=e[i++],a===C&&r(Error(\"invalid uncompressed block header: LEN (first byte)\")),h=a,a=e[i++],a===C&&r(Error(\"invalid uncompressed block header: LEN (second byte)\")),h|=a<<8,a=e[i++],a===C&&r(Error(\"invalid uncompressed block header: NLEN (first byte)\")),f=a,a=e[i++],a===C&&r(Error(\"invalid uncompressed block header: NLEN (second byte)\")),f|=a<<8,h===~f&&r(Error(\"invalid uncompressed block header: length verify\")),i+h>e.length&&r(Error(\"input buffer is broken\")),this.q){case $:for(;s+h>n.length;){if(u=o-s,h-=u,j)n.set(e.subarray(i,i+u),s),s+=u,i+=u;else for(;u--;)n[s++]=e[i++];this.b=s,n=this.f(),s=this.b}break;case _:for(;s+h>n.length;)n=this.f({B:2});break;default:r(Error(\"invalid inflate mode\"))}if(j)n.set(e.subarray(i,i+h),s),s+=h,i+=h;else for(;h--;)n[s++]=e[i++];this.c=i,this.b=s,this.a=n;break;case 1:this.r(pt,dt);break;case 2:d(this);break;default:r(Error(\"unknown BTYPE: \"+t))}}return this.z()};var rt,tt,et=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],it=j?new Uint16Array(et):et,nt=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],st=j?new Uint16Array(nt):nt,at=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],ht=j?new Uint8Array(at):at,ft=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],ot=j?new Uint16Array(ft):ft,ut=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],ct=j?new Uint8Array(ut):ut,lt=new(j?Uint8Array:Array)(288);for(rt=0,tt=lt.length;tt>rt;++rt)lt[rt]=143>=rt?8:255>=rt?9:279>=rt?7:8;var yt,bt,pt=s(lt),gt=new(j?Uint8Array:Array)(30);for(yt=0,bt=gt.length;bt>yt;++yt)gt[yt]=5;var dt=s(gt);b.prototype.r=function(r,t){var e=this.a,i=this.b;this.A=r;for(var n,s,a,h,f=e.length-258;256!==(n=g(this,r));)if(256>n)i>=f&&(this.b=i,e=this.f(),i=this.b),e[i++]=n;else for(s=n-257,h=st[s],0<ht[s]&&(h+=p(this,ht[s])),n=g(this,t),a=ot[n],0<ct[n]&&(a+=p(this,ct[n])),i>=f&&(this.b=i,e=this.f(),i=this.b);h--;)e[i]=e[i++-a];for(;8<=this.e;)this.e-=8,this.c--;this.b=i},b.prototype.Q=function(r,t){var e=this.a,i=this.b;this.A=r;for(var n,s,a,h,f=e.length;256!==(n=g(this,r));)if(256>n)i>=f&&(e=this.f(),f=e.length),e[i++]=n;else for(s=n-257,h=st[s],0<ht[s]&&(h+=p(this,ht[s])),n=g(this,t),a=ot[n],0<ct[n]&&(a+=p(this,ct[n])),i+h>f&&(e=this.f(),f=e.length);h--;)e[i]=e[i++-a];for(;8<=this.e;)this.e-=8,this.c--;this.b=i},b.prototype.f=function(){var r,t,e=new(j?Uint8Array:Array)(this.b-32768),i=this.b-32768,n=this.a;if(j)e.set(n.subarray(32768,e.length));else for(r=0,t=e.length;t>r;++r)e[r]=n[r+32768];if(this.o.push(e),this.s+=e.length,j)n.set(n.subarray(i,i+32768));else for(r=0;32768>r;++r)n[r]=n[i+r];return this.b=32768,n},b.prototype.S=function(r){var t,e,i,n,s=this.input.length/this.c+1|0,a=this.input,h=this.a;return r&&(\"number\"==typeof r.B&&(s=r.B),\"number\"==typeof r.M&&(s+=r.M)),2>s?(e=(a.length-this.c)/this.A[2],n=258*(e/2)|0,i=n<h.length?h.length+n:h.length<<1):i=h.length*s,j?(t=new Uint8Array(i),t.set(h)):t=h,this.a=t},b.prototype.z=function(){var r,t,e,i,n,s=0,a=this.a,h=this.o,f=new(j?Uint8Array:Array)(this.s+(this.b-32768));if(0===h.length)return j?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);for(t=0,e=h.length;e>t;++t)for(r=h[t],i=0,n=r.length;n>i;++i)f[s++]=r[i];for(t=32768,e=this.b;e>t;++t)f[s++]=a[t];return this.o=[],this.buffer=f},b.prototype.O=function(){var r,t=this.b;return j?this.K?(r=new Uint8Array(t),r.set(this.a.subarray(0,t))):r=this.a.subarray(0,t):(this.a.length>t&&(this.a.length=t),r=this.a),this.buffer=r},A.prototype.i=function(){for(var t=this.input.length;this.c<t;){var n=new i,s=C,a=C,h=C,f=C,o=C,u=C,c=C,l=C,y=C,p=this.input,g=this.c;switch(n.C=p[g++],n.D=p[g++],(31!==n.C||139!==n.D)&&r(Error(\"invalid file signature:\"+n.C+\",\"+n.D)),n.v=p[g++],n.v){case 8:break;default:r(Error(\"unknown compression method: \"+n.v))}if(n.n=p[g++],l=p[g++]|p[g++]<<8|p[g++]<<16|p[g++]<<24,n.$=new Date(1e3*l),n.ba=p[g++],n.aa=p[g++],0<(4&n.n)&&(n.W=p[g++]|p[g++]<<8,g+=n.W),0<(n.n&X)){for(c=[],u=0;0<(o=p[g++]);)c[u++]=String.fromCharCode(o);n.name=c.join(\"\")}if(0<(n.n&Z)){for(c=[],u=0;0<(o=p[g++]);)c[u++]=String.fromCharCode(o);n.w=c.join(\"\")}0<(n.n&W)&&(n.P=65535&e(p,0,g),n.P!==(p[g++]|p[g++]<<8)&&r(Error(\"invalid header crc16\"))),s=p[p.length-4]|p[p.length-3]<<8|p[p.length-2]<<16|p[p.length-1]<<24,p.length-g-4-4<512*s&&(f=s),a=new b(p,{index:g,bufferSize:f}),n.data=h=a.i(),g=a.c,n.Y=y=(p[g++]|p[g++]<<8|p[g++]<<16|p[g++]<<24)>>>0,e(h,C,C)!==y&&r(Error(\"invalid CRC-32 checksum: 0x\"+e(h,C,C).toString(16)+\" / 0x\"+y.toString(16))),n.Z=s=(p[g++]|p[g++]<<8|p[g++]<<16|p[g++]<<24)>>>0,(4294967295&h.length)!==s&&r(Error(\"invalid input size: \"+(4294967295&h.length)+\" / \"+s)),this.G.push(n),this.c=g}this.R=I;var d,A,v,w=this.G,k=0,U=0;for(d=0,A=w.length;A>d;++d)U+=w[d].data.length;if(j)for(v=new Uint8Array(U),d=0;A>d;++d)v.set(w[d].data,k),k+=w[d].data.length;else{for(v=[],d=0;A>d;++d)v[d]=w[d].data;v=Array.prototype.concat.apply([],v)}return v},w.prototype.i=function(){var t,e,i=this.input;return t=this.J.i(),this.c=this.J.c,this.V&&(e=(i[this.c++]<<24|i[this.c++]<<16|i[this.c++]<<8|i[this.c++])>>>0,e!==v(t)&&r(Error(\"invalid adler-32 checksum\"))),t};var At=8,vt=K;k.prototype.h=function(){var t,e,i,n,s,a,h,f=0;switch(h=this.a,t=At){case At:e=Math.LOG2E*Math.log(32768)-8;break;default:r(Error(\"invalid compression method\"))}switch(i=e<<4|t,h[f++]=i,t){case At:switch(this.k){case vt.NONE:s=0;break;case vt.L:s=1;break;case vt.t:s=2;break;default:r(Error(\"unsupported compression type\"))}break;default:r(Error(\"invalid compression method\"))}return n=s<<6|0,h[f++]=n|31-(256*i+n)%31,a=v(this.input),this.I.b=f,h=this.I.h(),f=h.length,j&&(h=new Uint8Array(h.buffer),h.length<=f+4&&(this.a=new Uint8Array(h.length+4),this.a.set(h),h=this.a),h=h.subarray(0,f+4)),h[f++]=a>>24&255,h[f++]=a>>16&255,h[f++]=a>>8&255,h[f++]=255&a,h},exports.deflate=U,exports.deflateSync=m,exports.inflate=x,exports.inflateSync=E,exports.gzip=z,exports.gzipSync=T,exports.gunzip=S,exports.gunzipSync=N}).call(this);\n"
}